<html>
<head>
<title>Proxy — Inherited Storage</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">代理—继承的存储</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/proxy-inherited-storage-7887f63944e6?source=collection_archive---------2-----------------------#2022-09-29">https://medium.com/coinmonks/proxy-inherited-storage-7887f63944e6?source=collection_archive---------2-----------------------#2022-09-29</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="57dd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">正如我在<a class="ae jo" rel="noopener" href="/@eszymi/variable-immutability-proxy-112b861a9cb4">上一篇文章</a>中提到的，不恰当地使用<em class="jp"> delegatecall </em>函数可能会导致安全漏洞。其中一个问题是对变量的偶然重写，因为<em class="jp">delegatecall</em>没有使用变量的名称，而是它们在存储中的位置。</p><figure class="jq jr js jt fq ju"><div class="bz el l di"><div class="jv jw l"/></div></figure><p id="5d67" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们看看这些合同。<code class="eh jx jy jz ka b">addressOfLogic</code>变量包含当前逻辑实现的地址。只有<code class="eh jx jy jz ka b">owner</code>能够改变这个变量。逻辑契约给了我们两个功能:设置值<code class="eh jx jy jz ka b">var1</code> i <code class="eh jx jy jz ka b">var2</code>。但是当我们代理使用的时候，结果会和我们想象的不一样。如果我们调用参数为5的函数<em class="jp"> setVar1 </em>，那么代理的第二个存储元素的值将等于5，所以在我们的例子中它将是<code class="eh jx jy jz ka b">var2</code>。所以如果我们不小心，我们可能会不小心改变了不正确的变量。</p><p id="87eb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">使用逻辑中实现的第二个函数，我们可以注意到代理存储和逻辑存储之间的差异会产生多大的后果。乍一看，和前面的函数差不多。但是这个函数改变了第三个存储槽中变量的值。在逻辑中是<code class="eh jx jy jz ka b">var2</code>，但在代理中是<code class="eh jx jy jz ka b">owner</code>。这是我们代理安全性的一个很大的缺口。有人可以使用<em class="jp"> setVar2 </em>作为参数设置自己的地址，这样他就成为了代理的所有者，结果，他就可以设置<code class="eh jx jy jz ka b">addressOfLogic</code>并实现自己的逻辑。</p><h1 id="a29f" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">如何调整我们的储物空间？</h1><p id="2d05" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hm dt translated">我们现在知道逻辑和代理的存储必须相同，但是当我们升级逻辑时，我们应该如何处理存储呢？我们的新逻辑必须从以前的逻辑中继承存储，所以新版本不能改变存储的结构，但是可以在下一个未被占用的存储槽中添加新的状态变量，所以在现有变量的末尾。让我们看看例子。如果我们有逻辑1</p><pre class="jq jr js jt fq le ka lf lg aw lh dt"><span id="03d5" class="li kc ht ka b fv lj lk l ll lm">contract LogicV1 {<br/>    uint256 public var1;<br/>    uint256 public var2;<br/>}</span></pre><p id="98d0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们不能像那样将其升级到LogicV2合同:</p><pre class="jq jr js jt fq le ka lf lg aw lh dt"><span id="f18c" class="li kc ht ka b fv lj lk l ll lm">contract LogicV2 {<br/>    uint256 public var1; <br/>}</span></pre><p id="dc4b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">移除<code class="eh jx jy jz ka b">var2</code>(理论上是允许的，但是我们必须记住<code class="eh jx jy jz ka b">var2</code>的值仍然在存储器的第二个槽中。因此，如果我们用新变量创建LogicV3(升级此契约LogicV2的契约)，new的值将在开始时等于<code class="eh jx jy jz ka b">var2</code>的值</p><pre class="jq jr js jt fq le ka lf lg aw lh dt"><span id="42bd" class="li kc ht ka b fv lj lk l ll lm">contract LogicV2 {<br/>    uint256 public var2;<br/>    uint256 public var1; <br/>}</span></pre><p id="3c52" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">改变var1和<code class="eh jx jy jz ka b">var2</code>的位置</p><pre class="jq jr js jt fq le ka lf lg aw lh dt"><span id="e54a" class="li kc ht ka b fv lj lk l ll lm">contract LogicV2 {<br/>    uint256 public var1;<br/>    address public var2;<br/>}</span></pre><p id="27ff" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">改变<code class="eh jx jy jz ka b">var2</code>的类型</p><pre class="jq jr js jt fq le ka lf lg aw lh dt"><span id="8f4e" class="li kc ht ka b fv lj lk l ll lm">contract LogicV2 {<br/>    uint256 public var1;<br/>    uint256 public var3;<br/>    uint256 public var2;<br/>}</span></pre><p id="d97b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在现有变量的末尾添加一个新变量。</p><p id="4220" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">新实现中新变量的正确添加如下所示</p><pre class="jq jr js jt fq le ka lf lg aw lh dt"><span id="93e9" class="li kc ht ka b fv lj lk l ll lm">contract LogicV2 {<br/>    uint256 public var1;<br/>    uint256 public var2;<br/>    uint256 public var3;<br/>}</span></pre><p id="3cf0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果我们想改变变量的名字，我们可以这样做。但是允许的只是它的名字，没有类型。所以这也是一份合适的新合同</p><pre class="jq jr js jt fq le ka lf lg aw lh dt"><span id="dd8e" class="li kc ht ka b fv lj lk l ll lm">contract LogicV2 {<br/>    uint256 public slot0;<br/>    uint256 public slot1;<br/>    uint256 public var3;<br/>}</span></pre><h1 id="441a" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">从其他契约继承的逻辑契约的升级</h1><p id="62f6" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hm dt translated">让我们假设我们的逻辑契约看起来像</p><pre class="jq jr js jt fq le ka lf lg aw lh dt"><span id="2ee0" class="li kc ht ka b fv lj lk l ll lm">contract Logic is A, B{<br/>    uint256 public var1;<br/>    uint256 public var2;<br/>}</span></pre><p id="48bb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">合同A和B看起来像</p><pre class="jq jr js jt fq le ka lf lg aw lh dt"><span id="a1e9" class="li kc ht ka b fv lj lk l ll lm">contract A {<br/>    uint256 public A0;<br/>}</span><span id="5d64" class="li kc ht ka b fv ln lk l ll lm">contract B {<br/>    uint256 public B0;<br/>}</span></pre><p id="9986" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">那么我们的存储逻辑是(存储[0]是存储的第一个槽，存储[1]是第二个槽，依此类推)</p><pre class="jq jr js jt fq le ka lf lg aw lh dt"><span id="3b3c" class="li kc ht ka b fv lj lk l ll lm">storage[0] -&gt; A0<br/>storage[1] -&gt; B0<br/>storage[2] -&gt; var1<br/>storage[3] -&gt; var2</span></pre><p id="f3fc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">很容易预测，如果有人在A或B中增加了一个新变量，逻辑的存储顺序会有所不同。同样，如果我们写</p><pre class="jq jr js jt fq le ka lf lg aw lh dt"><span id="ba7b" class="li kc ht ka b fv lj lk l ll lm">contract Logic is B, A{<br/>    uint256 public var1;<br/>    uint256 public var2;<br/>}</span></pre><p id="f9c6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">未来的存储将会有所不同。</p><p id="ca39" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果我们不确定在母公司的合同中不需要更多的变量，我们可以使用存储间隙来保留存储。为此，我们像这样声明固定数组</p><pre class="jq jr js jt fq le ka lf lg aw lh dt"><span id="85f6" class="li kc ht ka b fv lj lk l ll lm">contract A {<br/>    uint256 public A0;<br/>    uint256[100] public __gap;<br/>}</span></pre><p id="732a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果将来我们需要添加一个新的变量，我们只需要写</p><pre class="jq jr js jt fq le ka lf lg aw lh dt"><span id="08bf" class="li kc ht ka b fv lj lk l ll lm">contract A {<br/>    uint256 public A0;<br/>    uint256 public A1;<br/>    uint256[99] public __gap;<br/>}</span></pre><p id="85d2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">__gap这个名字来自于OpenZeppelin创建的一个约定。当我们谈论OpenZeppelin时，我使用了他们的<a class="ae jo" href="https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable" rel="noopener ugc nofollow" target="_blank">伟大文章</a>中的信息。</p><h2 id="4898" class="li kc ht bd kd lo lp lq kh lr ls lt kl jb lu lv kp jf lw lx kt jj ly lz kx ma dt translated">另一种可能性</h2><p id="ee12" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hm dt translated">另一种选择是创建包含所有状态变量的契约。逻辑和代理都将继承它。谢谢，我们确信它们的存储顺序完全相同。</p><h1 id="e142" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">摘要</h1><p id="0862" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hm dt translated">我们熟悉了继承存储代理模式的概念。我们来看看这样做的利弊。</p><h2 id="4ae7" class="li kc ht bd kd lo lp lq kh lr ls lt kl jb lu lv kp jf lw lx kt jj ly lz kx ma dt translated">优势</h2><ul class=""><li id="eca7" class="mb mc ht is b it kz ix la jb md jf me jj mf jn mg mh mi mj dt translated">这给了我们更新合同的可能性</li><li id="184e" class="mb mc ht is b it mk ix ml jb mm jf mn jj mo jn mg mh mi mj dt translated">这只是简单的方法</li></ul><h2 id="46b0" class="li kc ht bd kd lo lp lq kh lr ls lt kl jb lu lv kp jf lw lx kt jj ly lz kx ma dt translated">不足之处</h2><ul class=""><li id="f8c5" class="mb mc ht is b it kz ix la jb md jf me jj mf jn mg mh mi mj dt translated">新版本需要继承可能包含许多他们不使用的状态变量的存储。因此，随着时间的推移，这种方法的实施成本可能会很高。</li><li id="b001" class="mb mc ht is b it mk ix ml jb mm jf mn jj mo jn mg mh mi mj dt translated">该逻辑的所有实现变得与特定的代理契约紧密耦合，并且不能被声明不同状态变量的其他代理契约使用。</li></ul></div><div class="ab cl mp mq hb mr" role="separator"><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu mv"/><span class="ms bw bk mt mu"/></div><div class="hm hn ho hp hq"><p id="c2f0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我希望这篇文章对你有用。如果你有任何想法，我如何能使我的帖子更好，请告诉我。我随时准备学习。你可以在<a class="ae jo" href="https://pl.linkedin.com/in/szymon-skrzy%C5%84ski-881462214" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>和<a class="ae jo" href="https://t.me/eszymi" rel="noopener ugc nofollow" target="_blank"> Telegram </a>上和我联系。</p><p id="0b39" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果你想和我谈论这个话题或者我写的其他话题，请随意。我乐于交谈。</p><p id="f9fe" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">快乐学习！</p><blockquote class="mw"><p id="481f" class="mx my ht bd mz na nb nc nd ne nf jn ek translated">交易新手？尝试<a class="ae jo" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae jo" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>