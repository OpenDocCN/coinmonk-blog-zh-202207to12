<html>
<head>
<title>Decoding Load Average in Linux</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Linux中解码平均负载</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/decoding-load-average-in-linux-cdc98b30e0c6?source=collection_archive---------16-----------------------#2022-09-02">https://medium.com/coinmonks/decoding-load-average-in-linux-cdc98b30e0c6?source=collection_archive---------16-----------------------#2022-09-02</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="6dbb" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">了解Linux命令输出中的平均负载，如uptime和top。</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/e23de969e6f3b8a73bd2a03707fcbc78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*BXbpe3t5a7kMTrKb"/></div></div><figcaption class="ju jv fg fe ff jw jx bd b be z ek">Photo by <a class="ae jy" href="https://unsplash.com/@ocollet?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Olivier Collet</a> on <a class="ae jy" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="4890" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">介绍</h2><p id="7241" class="pw-post-body-paragraph kx ky ht kz b la lb iu lc ld le ix lf kk lg lh li ko lj lk ll ks lm ln lo lp hm dt translated">如果您经常使用Linux及其命令行工具，您应该已经使用过top和uptime命令来检查系统CPU使用情况、内存和输入/输出统计信息。该输出的一个常见部分是平均负载。我一直以为我通过查看输出就明白了，这似乎是不言自明的。但是，我错了！它不是我最初想的那样。在一次采访中，我被问及关于这个参数的更深层次的问题，当时我发现，我的假设没有达到平均负载的程度。这给了我动力去更深入地了解它，理解它到底是关于什么的。所以如果你和我一样，希望这篇文章能让你大开眼界。</p><h2 id="7a71" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">那么什么是平均负载呢？</h2><p id="78b8" class="pw-post-body-paragraph kx ky ht kz b la lb iu lc ld le ix lf kk lg lh li ko lj lk ll ks lm ln lo lp hm dt translated">简单地说，它给出了过去1分钟、5分钟和15分钟的系统平均负载。听起来很简单，直到你开始质疑，什么是系统负载，它是如何计算的？</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff lq"><img src="../Images/7f84a2523cb6043b21c0c579e22c46f7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yi2mWgVpOiLNxZGq5brx9w.png"/></div></div><figcaption class="ju jv fg fe ff jw jx bd b be z ek">Uptime Command Load Average</figcaption></figure><h2 id="5b6f" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">系统平均负载和进程</h2><p id="424a" class="pw-post-body-paragraph kx ky ht kz b la lb iu lc ld le ix lf kk lg lh li ko lj lk ll ks lm ln lo lp hm dt translated">System Load average是处于可运行或不可中断睡眠状态的平均进程数。系统中的每个流程都包含一个流程状态。为了管理一个进程，内核需要知道这个进程在做什么，例如:它是在CPU上运行还是被阻塞了。这个角色被分配给流程描述符，流程描述符是一个存储有关流程的所有信息的结构。流程状态是流程描述符中的一个这样的信息或字段。流程状态描述了流程当前发生的情况。<strong class="kz hu">可运行</strong>和<strong class="kz hu">不可中断</strong>睡眠就是两种这样的状态。让我们试着去理解它们。</p><h2 id="9ce3" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">运行与可运行状态</h2><p id="120d" class="pw-post-body-paragraph kx ky ht kz b la lb iu lc ld le ix lf kk lg lh li ko lj lk ll ks lm ln lo lp hm dt translated">这两个州都有同一个国旗，就是“R”。那么区别在哪里呢？在特定时刻正在执行和使用CPU的进程是正在运行的进程。一个进程正在等待CPU，但是有其他所有的资源可以运行，这就是可运行进程。当CPU可用时，可运行的进程(在运行队列中)在被执行时变成运行中的进程。虽然，它们是不同的状态，但它们是集体分组的。因此，这两种状态下的进程都被考虑用于平均负载计算。下图显示了进程处于不同状态时的<strong class="kz hu"> top </strong>命令输出，如S-Sleep、R-Running或Runnable、I- Idle等。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff lr"><img src="../Images/334d28be29782b187e8fd6da5ee61378.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oHm6-WfqehpesIwIBopT0Q.png"/></div></div><figcaption class="ju jv fg fe ff jw jx bd b be z ek">Top Command Output Indicating State</figcaption></figure><h2 id="2716" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">可中断与不可中断睡眠状态</h2><p id="e4c8" class="pw-post-body-paragraph kx ky ht kz b la lb iu lc ld le ix lf kk lg lh li ko lj lk ll ks lm ln lo lp hm dt translated">当进程等待特定事件发生时，它可能处于可中断的睡眠状态。这意味着它可以通过满足条件/事件或发送信号来唤醒。由<strong class="kz hu"> top </strong>命令中的“S”输出指示。</p><p id="2ab8" class="pw-post-body-paragraph kx ky ht kz b la ls iu lc ld lt ix lf kk lu lh li ko lv lk ll ks lw ln lo lp hm dt translated">与可中断类似的是不可中断的睡眠状态。这些可能是不响应SIGTERM或SIGKILL等信号的系统调用。一个例子是设备驱动程序发出的访问硬件资源的调用，它需要资源可用才能从睡眠状态中出来。否则，它可能会使硬件处于不可预知的状态。处于这种状态的进程也被考虑用于平均负载计算。这些由顶部命令输出中的“D”标志指示。</p><h2 id="2bed" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">那么，如何解释负载平均值呢？</h2><p id="397f" class="pw-post-body-paragraph kx ky ht kz b la lb iu lc ld le ix lf kk lg lh li ko lj lk ll ks lm ln lo lp hm dt translated">为了解释负载平均输出，您需要确定您拥有什么样的CPU。是多处理器还是多核系统？</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff lx"><img src="../Images/e56e0f892b372877392406fdddded23a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xZp8EsJJUou8UKYt9X4t7g.png"/></div></div><figcaption class="ju jv fg fe ff jw jx bd b be z ek">How To Find Out Number Of CPU Cores</figcaption></figure><p id="beaa" class="pw-post-body-paragraph kx ky ht kz b la ls iu lc ld lt ix lf kk lu lh li ko lv lk ll ks lw ln lo lp hm dt translated">如果系统有一个CPU，平均负载为0，这意味着没有活动进程正在使用该CPU。值1表示CPU利用率为100 %, CPU很忙。在这种情况下，平均负载为2意味着CPU很忙，并且有活动的进程在等待CPU。这种情况偶尔会发生，但是如果这种情况持续一段时间，就意味着出现了问题。这就是为什么查看15分钟时间范围内的负载平均输出中的最后一个值可以很好地指示系统上的负载。在多核系统上，您需要考虑可用的内核数量，例如，在一个具有两个内核的CPU上，平均负载为1大约是50%的利用率。根据机器上可用的处理器或内核数量，该值会有所不同。下图显示了uptime命令的平均负载输出。负载平均值跨越1分钟、5分钟和15分钟的时间段。因此，对于单核CPU来说，在1分钟和5分钟的时间框架内，这些值很高，分别达到4和2.5，活动进程正在等待CPU。在过去15分钟内，CPU利用率超过1，这对于单核CPU来说仍然很高，如果不加控制，随着时间的推移，它可能会增加并影响系统性能。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ly"><img src="../Images/099abd064f58e5aeb9ab242ad328a40f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RBOFuhgZvGzVIgBv9SaE1A.png"/></div></div><figcaption class="ju jv fg fe ff jw jx bd b be z ek">High Load Average Uptime Command</figcaption></figure><p id="4a55" class="pw-post-body-paragraph kx ky ht kz b la ls iu lc ld lt ix lf kk lu lh li ko lv lk ll ks lw ln lo lp hm dt translated">下图是同一时间的<strong class="kz hu"> top </strong>命令输出，您可以看到平均负载在增加，CPU利用率也很高，徘徊在98–99%左右。</p><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff lz"><img src="../Images/93dd3d3997c3a3a7bf586f08665ba899.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*uSo3b0YI-qf6-zkMJFxobg.png"/></div></div><figcaption class="ju jv fg fe ff jw jx bd b be z ek">Top Command Load Average and High CPU Usage</figcaption></figure><h2 id="65c5" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">结论</h2><p id="c835" class="pw-post-body-paragraph kx ky ht kz b la lb iu lc ld le ix lf kk lg lh li ko lj lk ll ks lm ln lo lp hm dt translated">希望本文能让您对如何计算平均负载以及如何解释其输出来跟踪CPU使用情况有所了解。它确实是一个非常有用的工具，当与其他性能指标结合使用时，可以提供系统性能的度量。让我知道你对评论的宝贵反馈。</p><blockquote class="ma"><p id="93d8" class="mb mc ht bd md me mf mg mh mi mj lp ek translated">交易新手？试试<a class="ae jy" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a>或者<a class="ae jy" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>