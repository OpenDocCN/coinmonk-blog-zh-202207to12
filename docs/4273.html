<html>
<head>
<title>What You Need To Do To Increase The Security Of Your Smart Contracts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">您需要做些什么来提高智能合同的安全性</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/what-you-need-to-do-to-increase-the-security-of-your-smart-contracts-f0e2f244affb?source=collection_archive---------27-----------------------#2022-09-27">https://medium.com/coinmonks/what-you-need-to-do-to-increase-the-security-of-your-smart-contracts-f0e2f244affb?source=collection_archive---------27-----------------------#2022-09-27</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/3fcd10d9109a8e6222748023786a58ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Aepya02SYnPSBj-xRZiI2g.jpeg"/></div></div></figure><p id="d71c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">仅在Q1 2022年，DeFi行业就因利用漏洞损失了超过16亿美元，超过了2020年和2021年被盗总额的总和。基本的编程错误导致了一些协议被黑，而无效的契约逻辑或不准确的计算导致了其他协议被黑。我们将更详细地讨论我们团队经常遇到并成功解决的几个智能合同问题。</p><h2 id="a95e" class="jz ka ht bd kb kc kd ke kf kg kh ki kj jm kk kl km jq kn ko kp ju kq kr ks kt dt translated">访问控制</h2><p id="6308" class="pw-post-body-paragraph jb jc ht jd b je ku jg jh ji kv jk jl jm kw jo jp jq kx js jt ju ky jw jx jy hm dt translated">访问控制是一种安全技术，它规定谁或什么(即主体)可以对资源(即对象)执行什么操作。这意味着这是一种你信任的人的注册。不良的访问控制会导致数据丢失或被篡改、机密信息泄露，或者执行超出用户能力的管理任务。</p><h2 id="63d5" class="jz ka ht bd kb kc kd ke kf kg kh ki kj jm kk kl km jq kn ko kp ju kq kr ks kt dt translated"><strong class="ak">浮动编译指令</strong></h2><p id="7506" class="pw-post-body-paragraph jb jc ht jd b je ku jg jh ji kv jk jl jm kw jo jp jq kx js jt ju ky jw jx jy hm dt translated">例如，当pragma被锁定时，不打算部署契约的情况不会发生，最新的编译器可能具有未检测到错误的更大风险。应该在部署中使用编译器版本和标志，使用这些版本和标志对合同进行了最多的测试。</p><p id="8e47" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">编写任何智能契约的第一步是定义它的pragma。pragma不会更改编译器的版本。它只能告诉编译器检查它是否符合pragma。对于智能合约的编译，浮动Pragma提供了一组编译器版本。</p><p id="80f5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当使用严格的pragma函数时，强烈建议提及编译器版本。这可以防止使用具有未修复漏洞的过期编译器意外部署协定。</p><h2 id="98e6" class="jz ka ht bd kb kc kd ke kf kg kh ki kj jm kk kl km jq kn ko kp ju kq kr ks kt dt translated">关键功能的零地址检查</h2><p id="fa91" class="pw-post-body-paragraph jb jc ht jd b je ku jg jh ji kv jk jl jm kw jo jp jq kx js jt ju ky jw jx jy hm dt translated">在以太坊中，160位或20字节大小的帐户地址以20字节数据类型的形式存储，称为地址。该地址提供了一些将乙醚转移到帐户和调用契约函数的函数，以及一个返回帐户中当前乙醚量的balance属性。</p><p id="c9d7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">发送方和接收方参与在区块链上部署智能合约的交易。EVM在接收字段中识别零地址，这表示新合同的建立。</p><p id="1960" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">类似于标准以太坊地址，零地址有20个字节长，但只有空字节。由于零帐户没有私钥，因此无法撤消到零地址的智能合约交易。</p><p id="d654" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">因此，你的资金永远被锁定在一个零地址。</p><h2 id="8c8d" class="jz ka ht bd kb kc kd ke kf kg kh ki kj jm kk kl km jq kn ko kp ju kq kr ks kt dt translated">低可见性说明符</h2><p id="ebd6" class="pw-post-body-paragraph jb jc ht jd b je ku jg jh ji kv jk jl jm kw jo jp jq kx js jt ju ky jw jx jy hm dt translated">可见性决定了是否可以从外部访问对象(或契约或库)的属性或功能。显式标记函数和状态变量的可见性。函数可以分为内部函数、外部函数、公共函数或私有函数。外部可能就足够了，而不是公共的。理解这种差异是很重要的。如果显式标记了可见性，就可以更容易地发现关于谁可以调用函数或访问变量的错误假设。</p><p id="4e25" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">可见性说明符的不正确实现可能会对智能协定产生严重影响。</p><h2 id="5214" class="jz ka ht bd kb kc kd ke kf kg kh ki kj jm kk kl km jq kn ko kp ju kq kr ks kt dt translated">除法之前的乘法减少了舍入误差</h2><p id="1da5" class="pw-post-body-paragraph jb jc ht jd b je ku jg jh ji kv jk jl jm kw jo jp jq kx js jt ju ky jw jx jy hm dt translated">除法之前，先乘法！其实JavaScript是支持这个的。打开浏览器的控制台，输入观察为什么这是相当可观的。</p><p id="7ffc" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh kz la lb lc b">console.log((30 * 100 * 13) / 13)</code></p><p id="f445" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh kz la lb lc b">&lt; 3000</code></p><p id="4619" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们现在解同一个方程，先除法再乘法。</p><p id="6509" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh kz la lb lc b">console.log((30 / 13) * 100 * 13)</code></p><p id="b107" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh kz la lb lc b">&lt; 2999.9999999999995</code></p><p id="5afd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这是由于JavaScript中的浮点问题。舍入误差是我们用实性而不是浮点得到的。实度的第二次运算实际上会产生2999。</p><h2 id="f591" class="jz ka ht bd kb kc kd ke kf kg kh ki kj jm kk kl km jq kn ko kp ju kq kr ks kt dt translated">可重入</h2><p id="1a37" class="pw-post-body-paragraph jb jc ht jd b je ku jg jh ji kv jk jl jm kw jo jp jq kx js jt ju ky jw jx jy hm dt translated">以太坊依赖于消息、回调和复杂的执行堆栈。如果在逻辑排序中有一个错误，这将为漏洞打开大门。</p><p id="4e9a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">事务只能调用一个智能契约函数，该函数与链下游的契约进行对话，有时会“回调”原始契约。这导致了复杂的执行堆栈。</p><p id="797b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">由于所有这些交互，Solidity智能合约的开发人员必须时刻警惕他们的合约与其他智能合约中的潜在恶意代码之间的交互。</p><h2 id="0949" class="jz ka ht bd kb kc kd ke kf kg kh ki kj jm kk kl km jq kn ko kp ju kq kr ks kt dt translated">领跑</h2><p id="ea91" class="pw-post-body-paragraph jb jc ht jd b je ku jg jh ji kv jk jl jm kw jo jp jq kx js jt ju ky jw jx jy hm dt translated">当事务被添加到区块链时，它被广播到内存池，然后等待被包括在下一个块中。为了整理即将到来的块的事务，矿工正在查询事务池。由于其基于激励的取向，他们经常将下一个块中费用较高的交易放在第一位。</p><p id="9d4a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">网络上的观察者可以在事务被包含到下一个块之前查看和响应事务，因为所有的事务在事务池(mempool)中都是可用的。它被称为前跑。</p><p id="2ba3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">恶意参与者可能会使用进程来监视事务池。程序确定有利可图的交易可以被复制并以更高的燃气费提交。因此，恶意参与者的事务将在下一个事务之前添加到下面的块中。</p><p id="78a0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">区块链的公共性质使得这一点可以想象，一个前置运行的机器人也可以用来完成这一点。要解决这类问题，代码重构或重新设计通常是必要的。</p><h2 id="9478" class="jz ka ht bd kb kc kd ke kf kg kh ki kj jm kk kl km jq kn ko kp ju kq kr ks kt dt translated">缺少撤销功能</h2><p id="9dbd" class="pw-post-body-paragraph jb jc ht jd b je ku jg jh ji kv jk jl jm kw jo jp jq kx js jt ju ky jw jx jy hm dt translated">在你的智能合约中有一个可支付的功能，但没有提款选项，这是一个典型的漏洞。言下之意是，你的智能合约只提供一个支付选项，如果你是交易中的发送方，你的资金将不可避免地被锁定在你的合约中。</p><h2 id="a7f6" class="jz ka ht bd kb kc kd ke kf kg kh ki kj jm kk kl km jq kn ko kp ju kq kr ks kt dt translated">整数溢出和下溢</h2><p id="f934" class="pw-post-body-paragraph jb jc ht jd b je ku jg jh ji kv jk jl jm kw jo jp jq kx js jt ju ky jw jx jy hm dt translated">当无符号整数(uint)达到其字节限制时，就会溢出。下次添加元素时，将返回第一个可变元素。</p><p id="3dcd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">考虑一个只有8位的uint8。因此，我们能够存储的最大数字是二进制1111111(在十进制2⁸中，1 = 255)。</p><p id="c71e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh kz la lb lc b">uint8 balance = 255;<br/>balance++;</code></p><p id="bf2a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果运行前面提到的代码，“balance”将被设置为零。这是一个简单的溢出案例。如果加1，二进制数1111111将重置为00000000。</p><p id="b6bd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果从为0的uint8中减去1，在下溢的情况下，它将变成255。这将违反合同的内在逻辑，并导致合同的资金被没收。</p><p id="4322" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果坚固性代码解决了上溢或下溢问题，则计算的实际结果和预测结果可能会发生显著变化。</p><p id="cb95" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">但是，溢出漏洞确实有版本限制。0.8之前的Solidity版本在发生溢出时不会出现错误，而0.8之后的版本会出现错误。</p><h2 id="3a71" class="jz ka ht bd kb kc kd ke kf kg kh ki kj jm kk kl km jq kn ko kp ju kq kr ks kt dt translated">随机性(矿工操纵)</h2><p id="d636" class="pw-post-body-paragraph jb jc ht jd b je ku jg jh ji kv jk jl jm kw jo jp jq kx js jt ju ky jw jx jy hm dt translated">虽然没有在Solidity中创建随机数的方法，但是已经开发了几个变通方法来响应开发人员包含随机性的需求。矿工可以利用这些随机数发生器作为一种利用。</p><p id="fd5c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">使用伪随机数发生器(PRNG)是一种常用的技术，它创建看似随机但实际上根据初始私有种子值和内部状态是可预测的字节串。</p><h2 id="5432" class="jz ka ht bd kb kc kd ke kf kg kh ki kj jm kk kl km jq kn ko kp ju kq kr ks kt dt translated">使用事件监控合同活动</h2><p id="d748" class="pw-post-body-paragraph jb jc ht jd b je ku jg jh ji kv jk jl jm kw jo jp jq kx js jt ju ky jw jx jy hm dt translated">拥有一种在部署后跟踪契约活动的机制会很有帮助。查看合同的所有交易是做到这一点的一种方法，但是由于合同之间的消息调用在区块链中没有记录，这种方法可能是不够的。</p><p id="ff8b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">事件在应用程序的创建中起着重要的作用。这是因为我们做的任务需要时间，偶尔，一个特定事务的结果会影响我们完成下一个活动的能力。事件本质上是节点可以轻松访问的独特数据存储。我们可以通过订阅智能合约中的事件来更新UI的事务和状态。</p><h2 id="83fc" class="jz ka ht bd kb kc kd ke kf kg kh ki kj jm kk kl km jq kn ko kp ju kq kr ks kt dt translated"><strong class="ak">总结一下</strong></h2><p id="64fa" class="pw-post-body-paragraph jb jc ht jd b je ku jg jh ji kv jk jl jm kw jo jp jq kx js jt ju ky jw jx jy hm dt translated">由于区块链是不可变的，所以智能合约一旦被部署就不能被改变，然而，在逻辑有问题的情况下，合约之间的连接可以被移除，并且新的智能合约可以被用于用升级的逻辑来替换它。因此，使用代理代码来确保可升级性是至关重要的。另一个关键因素是开发人员必须创建单元测试并使用升级后的库。</p><p id="f67e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">开源库提供可重用的标准代码；它们是已经过漏洞检查的代码块。因此，使用最新版本的库大大降低了智能合约漏洞的可能性。毫无疑问，区块链行业正处于发展的初级阶段，随着它的发展，安全问题和漏洞也在增加。因此，定期审计有助于确保您的智能合约免受Web3.0空间中不断变化的错误的影响。</p><blockquote class="ld"><p id="8f0e" class="le lf ht bd lg lh li lj lk ll lm jy ek translated">交易新手？试试<a class="ae ln" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或者<a class="ae ln" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>