# 消化固体

> 原文：<https://medium.com/coinmonks/digesting-the-solidity-911f96445394?source=collection_archive---------29----------------------->

还记得我们在上一篇文章中提到的地方吗？
***合同支付{
函数支付者()公共应付{
}}***

上面的代码片段是发送一些加密支付到一个特定的地址，但它似乎是一种外来的语言。没有吗？为了更好地理解这一点，让我们再深入了解一下关于坚固的一切。但是在此之前，我认为我们可以用迄今为止所获得的任何信息来描述和理解下面编写的基本代码。

合同标识{
字符串名称；
单位年龄；
constructor()public {
name = ' Ravi '；
年龄= 17；
}
函数 getName()查看公共返回(字符串内存){
返回名称；
}
函数 getAge()查看公共返回(uint){
返回年龄；
}

函数 setAge()public {
age = age+1；
}
}

在上面的代码片段中，我们试图用 solidity 编写一个程序，其中我们编写了一个身份对象，用键值对作为姓名和年龄。我们将进一步从上面声明的接口中获取姓名和年龄，并在需要设置年龄值时将它增加 1。

**Getter 和 Setter**

在上面的代码片段中，我们遇到了 getter 和 setter 术语。这些只是表达方法的术语。Getter 是用来表示我们试图从程序中得到一些东西的术语，而 setter 是用来表示我们将要用一些新的数据编辑任何先前的变量，并用一组新的变化来交换它的存在。
比如，这里——

构造局部{
单元年龄= 10；

函数 getter()public view returns(unit){
return age；
}

函数 setter()public {
age = age+1；
}

////或////

函数 setter(unit new age)public {
age = new age；
}

伙计们，等一下…这里刚刚发生了什么？老实说，稳健是我们的主人，因此稳健必须满足我们的好奇心。不要评判我们，我们只需要相信可靠。
所以，在上面的代码中，首先，我们声明了年龄变量，其值为 10。后来，通过“getter”函数，我们得到了年龄的值。
接下来，使用‘setter’函数，我们首先用固定值 1 来设置年龄变量的值，然后用用户输入的任意值来设置。
现在你一定在想，我为什么要用(或)？这是因为我们不能在定义多个函数时使用同一个函数名。当然，我们可以为第二个 getter 函数使用其他名称，比如 getter_two 或 abra_ka_dabra。
还有，这里需要注意的一点是，在创建界面的时候，我们写了***unit age = 10；*** 必须理解的是，如果我们把 ***写成单位公龄= 10；*** 那么我们甚至不需要做任何的 getter 函数或者就这样来获取 age 的值。这是因为我们已经初始化了关键字“public ”,这将默认显示变量 age 的值。
现在让我们看看 getter 和 setter 函数的一些特征

*   调用 setter 函数会创建一个需要挖掘的事务，因为它会改变区块链，而 getter 函数则不会这样，
*   当我们声明公共状态变量时，会自动创建一个 getter 函数，
*   默认情况下，变量可见性是私有的。

## 观点与纯粹

到目前为止，在大多数编程函数中，我们在声明任何函数时都会看到“视图”和“纯”这样的词。
让我们更多地了解他们-

*   “视图”和“纯”用于我们不进行任何更新/写入的地方，
*   “纯”用于不需要从状态变量中读取的情况，
*   当需要从状态变量中读取时，使用“视图”。

## 存储与内存

我们能遇到的下一个最重要的概念是固体的储存和记忆方面。
**存储**

*   保存状态变量，
*   它在整个程序中是持久的，
*   它需要油费，
*   它或多或少有点像电脑硬盘

## **记忆**

*   如果局部变量是引用类型，则在函数中保存局部变量，
*   不执着，
*   不需要汽油费，
*   它就像一个电脑内存

**坚实度中的全局变量**

这些是用于 vpurpose 目的的内置变量，如知道时间戳、块创建者等。
使用全局变量的例子-
构造 demo{
函数 get()public view returns(unit block _ no . uint timestamp，address，msgSender){
return (block。编号，块。时间戳。发件人)；
}
}

现在，看完了各种各样的 Solidity 代码片段，让我们回到我们开始的地方——
我们的 payable 函数——(未完待续)。这个恶棍还没有落入我们的圈套。我将在我们的下一篇文章中解释清楚，直到那时让我们继续链接这些块。

谢谢你们的时间，伙计们！

> 交易新手？试试[加密交易机器人](/coinmonks/crypto-trading-bot-c2ffce8acb2a)或者[复制交易](/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c)