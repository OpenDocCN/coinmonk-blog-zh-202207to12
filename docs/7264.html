<html>
<head>
<title>Polygon ID Part-3 : On chain verification by Verifier</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">多边形标识第3部分:由验证者进行链上验证</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/polygon-id-part-3-on-chain-verification-by-verifier-e68338cd4846?source=collection_archive---------1-----------------------#2022-12-10">https://medium.com/coinmonks/polygon-id-part-3-on-chain-verification-by-verifier-e68338cd4846?source=collection_archive---------1-----------------------#2022-12-10</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/6826ec041955a820107567ea0779e15a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*2XAzzut9W8VX9y8h.png"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">Source : Polygon ID Docs</figcaption></figure><p id="0ed1" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">这是正在进行的多边形ID系列的第三篇文章，我们将在其中讨论验证器的链上验证。</p><p id="c0b6" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">然而，如果您直接从本文开始，我建议您阅读一下本系列的第<a class="ae kd" rel="noopener" href="/coinmonks/polygon-id-part-1-introduction-to-core-concepts-394681549f7c">部分-1 </a> &amp; <a class="ae kd" rel="noopener" href="/coinmonks/polygon-id-part-2-creating-and-issuing-claims-4fda0d992b1d">部分-2 </a>，它们分别涵盖了核心概念和索赔的发布。</p><p id="3eee" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">我将从我们在第2部分中离开的地方继续这篇文章，在第2部分中，我们向持有人发出了索赔。在本文中，我们将通过验证者设置请求，验证者将验证索赔持有人是否满足证明请求。</p><p id="5d40" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">从教程开始，我会要求你克隆这个<a class="ae kd" href="https://github.com/pikachua7/On-Chain-Verification-Age" rel="noopener ugc nofollow" target="_blank">库</a>。它包含了本文中讨论的代码的完整实现。</p><h1 id="2903" class="ke kf ht bd kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb dt translated">设计ERC20 zk合同</h1><p id="bb9d" class="pw-post-body-paragraph jf jg ht jh b ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx jy lg ka kb kc hm dt translated">ERC20Verifier是ERC20类固醇的标准合约。零知识证明验证提供了额外的功能。所有专用于zk验证的函数都包含在<a class="ae kd" href="https://github.com/0xPolygonID/contracts/blob/main/contracts/verifiers/ZKPVerifier.sol" rel="noopener ugc nofollow" target="_blank"> ZKPVerifier </a>契约中，并在ERC20Verifier中继承。</p><p id="b98f" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">例如，用户将通过调用<em class="lh"> submitZKPResponse </em>函数提交他们的证据来要求令牌。</p><p id="3bcd" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">ERC20Verifier协定必须至少定义一个TRANSFER_REQUEST_ID，该ID类似于协定向用户提出的请求的标识符。</p><pre class="li lj lk ll fq lm ln lo bn lp lq bi"><span id="8e7e" class="lr kf ht ln b be ls lt l lu lv">// SPDX-License-Identifier: MIT<br/>pragma solidity ^0.8.0;<br/><br/>import "@openzeppelin/contracts/token/ERC20/ERC20.sol";<br/>import "./lib/GenesisUtils.sol";<br/>import "./interfaces/ICircuitValidator.sol";<br/>import "./verifiers/ZKPVerifier.sol";<br/><br/>contract ERC20Verifier is ERC20, ZKPVerifier {<br/><br/>    uint64 public constant TRANSFER_REQUEST_ID = 1;<br/><br/>    mapping(uint256 =&gt; address) public idToAddress;<br/>    mapping(address =&gt; uint256) public addressToId;<br/><br/>    uint256 public TOKEN_AMOUNT_PER_ID = 5 * 10**uint(decimals());<br/><br/>    constructor(string memory name_, string memory symbol_)<br/>        ERC20(name_, symbol_)<br/>    {}    <br/><br/>    function _beforeProofSubmit(<br/>        uint64, /* requestId */<br/>        uint256[] memory inputs,<br/>        ICircuitValidator validator<br/>    ) internal view override {<br/>        // check that challenge input of the proof is equal to the msg.sender <br/>        address addr = GenesisUtils.int256ToAddress(<br/>            inputs[validator.getChallengeInputIndex()]<br/>        );<br/>        require(<br/>            _msgSender() == addr,<br/>            "address in proof is not a sender address"<br/>        );<br/>    }<br/><br/>    function _afterProofSubmit(<br/>        uint64 requestId,<br/>        uint256[] memory inputs,<br/>        ICircuitValidator validator<br/>    ) internal override {<br/>        require(<br/>            requestId == TRANSFER_REQUEST_ID &amp;&amp; addressToId[_msgSender()] == 0,<br/>            "proof can not be submitted more than once"<br/>        );<br/><br/>        uint256 id = inputs[validator.getChallengeInputIndex()];<br/>        // execute the logic<br/>        if (idToAddress[id] == address(0)) {<br/>            super._mint(_msgSender(), TOKEN_AMOUNT_PER_ID);<br/>            addressToId[_msgSender()] = id;<br/>            idToAddress[id] = _msgSender();<br/>        }<br/>    }<br/><br/>    function _beforeTokenTransfer(<br/>        address, /* from */<br/>        address to,<br/>        uint256 /* amount */<br/>    ) internal view override {<br/>        require(<br/>            proofs[to][TRANSFER_REQUEST_ID] == true,<br/>            "only identities who provided proof are allowed to receive tokens"<br/>        );<br/>    }<br/>}</span></pre><p id="c830" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">在合同中，你会注意到两个挂钩—</p><ol class=""><li id="cbde" class="lw lx ht jh b ji jj jm jn jq ly ju lz jy ma kc mb mc md me dt translated">_beforeProofSubmit</li><li id="af15" class="lw lx ht jh b ji mf jm mg jq mh ju mi jy mj kc mb mc md me dt translated">_afterProofSubmit</li></ol><p id="a729" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">让我们看看为什么这两个钩子很重要。</p><p id="b1d8" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><strong class="jh hu"> _beforeProofSubmit </strong>检查证明的发送者是否与证明质询中包含的地址相匹配。</p><p id="bfae" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><strong class="jh hu"> _afterProofSubmit </strong>包含了我们需要在用例中编写的逻辑。它还包含这样一个条件，即对于特定的TRANSFER_REQUEST_ID，证明只执行一次。</p><p id="b3b1" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">接下来，我们注意到ERC20覆盖了<strong class="jh hu"> _beforeTokenTransfer </strong>，ERC 20禁止任何类型的令牌传输(即使在空投之后)，除非用户通过了证据验证。</p><p id="bf70" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">这就完成了我们的ERC20Verifier合同。现在让我们转向合同的部署。</p></div><div class="ab cl mk ml hb mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hm hn ho hp hq"><h1 id="8a74" class="ke kf ht bd kg kh mr kj kk kl ms kn ko kp mt kr ks kt mu kv kw kx mv kz la lb dt translated">部署ERC20Verifier合同并设置ZKP请求</h1><p id="5a5d" class="pw-post-body-paragraph jf jg ht jh b ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx jy lg ka kb kc hm dt translated">在克隆的存储库中，您将看到两个hardhat脚本，其中一个脚本包含合同的部署，另一个脚本包含ZKP请求的设置。</p><p id="0fb4" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">让我们设置<em class="lh"> set-request.js </em>文件，它将为验证者设置证明请求。</p><p id="0e15" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">如果您在<em class="lh"> set-request.js </em>文件中注意到，函数<strong class="jh hu"> <em class="lh"> setZKPRequest </em> </strong>是从ERC20Verifier契约中调用的，它接受3个参数—</p><ol class=""><li id="ceca" class="lw lx ht jh b ji jj jm jn jq ly ju lz jy ma kc mb mc md me dt translated">请求ID</li><li id="9a5c" class="lw lx ht jh b ji mf jm mg jq mh ju mi jy mj kc mb mc md me dt translated">验证器</li><li id="0d4b" class="lw lx ht jh b ji mf jm mg jq mh ju mi jy mj kc mb mc md me dt translated">询问</li></ol><p id="aa2f" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><strong class="jh hu"> requestID </strong>定义了与请求相关联的ID。</p><p id="a069" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><strong class="jh hu">验证器</strong>这里指的是<a class="ae kd" href="https://github.com/0xPolygonID/contracts/blob/main/contracts/validators/CredentialAtomicQuerySigValidator.sol" rel="noopener ugc nofollow" target="_blank">验证器智能合约</a>部署在<a class="ae kd" href="https://mumbai.polygonscan.com/address/0xb1e86C4c687B85520eF4fd2a0d14e81970a15aFB" rel="noopener ugc nofollow" target="_blank">孟买测试网</a>上。这是在用户提交的zk证明上实际执行验证的合同。</p><p id="89da" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><strong class="jh hu">查询</strong>这里指的是验证者在他对身份持有者的证明请求中指定的一组规则。</p><p id="71b3" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">查询是一个包含一些参数的对象—</p><ol class=""><li id="673a" class="lw lx ht jh b ji jj jm jn jq ly ju lz jy ma kc mb mc md me dt translated">(计划或理论的)纲要</li><li id="1761" class="lw lx ht jh b ji mf jm mg jq mh ju mi jy mj kc mb mc md me dt translated">插槽索引</li><li id="5929" class="lw lx ht jh b ji mf jm mg jq mh ju mi jy mj kc mb mc md me dt translated">操作员</li><li id="ac07" class="lw lx ht jh b ji mf jm mg jq mh ju mi jy mj kc mb mc md me dt translated">价值</li><li id="925d" class="lw lx ht jh b ji mf jm mg jq mh ju mi jy mj kc mb mc md me dt translated">电路ID</li></ol><p id="f75d" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><strong class="jh hu">模式</strong>是您可以从Polygon ID Platform上的发行者仪表板中检索的模式的散列。为了在查询中使用它，应该将它从hex转换为bigint。</p><blockquote class="mw mx my"><p id="dbd5" class="jf jg lh jh b ji jj jk jl jm jn jo jp mz jr js jt na jv jw jx nb jz ka kb kc hm dt translated">注意:如果你是Polygon ID文档的早期用户，文档中没有提到模式哈希转换，这在初始阶段导致了很多错误。然而没有得到解决:)</p></blockquote><p id="dc2c" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><strong class="jh hu"> slotIndex </strong>是您正在查询的属性的索引。请注意，在创建索赔时，我们提到最多可以提到2个属性。在我们的例子中，我们只提到了年龄(如果你对属性感到困惑，请参考我的<a class="ae kd" rel="noopener" href="/coinmonks/polygon-id-part-2-creating-and-issuing-claims-4fda0d992b1d">系列文章的第二部分</a>)。</p><p id="8d75" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">slotIndex值可以是2或3，其中2表示属性-1，3表示属性-2。在我们的例子中，因为我们将年龄信息存储在属性-1中，所以我们将slotIndex值取为2。</p><p id="1ada" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><strong class="jh hu">运算符</strong>的范围从1到5，其中每个运算符的意思是—</p><p id="850c" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">运算符1:等于</p><p id="53a0" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">操作员2:小于</p><p id="a44b" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">运算符3:大于</p><p id="fc1f" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">操作员4:在</p><p id="fea8" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">接线员5:不在</p><p id="a65a" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">因此，您可以根据您的用例选择您想要的操作符，在我们的场景中，我们将选择操作符3，因为我们想要年龄大于18岁的所有身份持有者。</p><p id="761d" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><strong class="jh hu">值</strong>表示您正在查询的阈值。在我们的例子中，阈值是18，因为我们希望所有用户都年满18岁。</p><p id="45fb" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated"><strong class="jh hu"> circuitID </strong>是您用于验证的电路的ID。它可以是<a class="ae kd" href="https://docs.iden3.io/protocol/main-circuits/#credentialatomicquerymtp" rel="noopener ugc nofollow" target="_blank">credentialaatomicquerymtp</a>或<a class="ae kd" href="https://docs.iden3.io/protocol/main-circuits/#credentialatomicquerysig" rel="noopener ugc nofollow" target="_blank">credentialaatomicquerysig</a>。出于演示目的，我们使用了credentialAtomicQuerySig。</p><p id="eeee" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">现在你已经设置好了你的<em class="lh"> set-request.js </em>文件。但是在继续之前，请确保您已经在github repo文件中做了以下更改——</p><ol class=""><li id="cef9" class="lw lx ht jh b ji jj jm jn jq ly ju lz jy ma kc mb mc md me dt translated">更改了模式哈希(您可以从多边形ID平台获取它，请确保您复制了想要验证的模式哈希)</li><li id="d523" class="lw lx ht jh b ji mf jm mg jq mh ju mi jy mj kc mb mc md me dt translated">更改查询参数:运算符&amp; value</li><li id="5634" class="lw lx ht jh b ji mf jm mg jq mh ju mi jy mj kc mb mc md me dt translated">添加ERC20Verifier契约部署地址(只需运行deploy.js文件)</li></ol><p id="80c4" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">现在，您可以成功设置您的ZKP请求了。如果您将在Polygonscan上打开您的ERC20Verifier合同地址(如果您已经在Polygon上部署了您的合同),您可能会注意到我们的ZKP请求设置成功。</p><figure class="li lj lk ll fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff nc"><img src="../Images/16f069fc364d7ffe2163b936bbf17df7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cIRCioRHyKutASInjL4TUg.png"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">SetZKPRequest</figcaption></figure><p id="6dbe" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">现在，让我们将这个证明请求添加到一个QR码中，并让我们的用户通过该证明请求。</p></div><div class="ab cl mk ml hb mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hm hn ho hp hq"><h1 id="219e" class="ke kf ht bd kg kh mr kj kk kl ms kn ko kp mt kr ks kt mu kv kw kx mv kz la lb dt translated">在QR码中设置证明请求</h1><p id="4f6a" class="pw-post-body-paragraph jf jg ht jh b ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx jy lg ka kb kc hm dt translated">让我们前往前端文件夹，在App.js文件中，我们已经准备好了QR码，但我们需要做一些更改，以便QR码现在包含我们的证明请求。</p><ol class=""><li id="bfcc" class="lw lx ht jh b ji jj jm jn jq ly ju lz jy ma kc mb mc md me dt translated">使用您部署的ERC20Verifier协定地址更改协定地址。</li><li id="0fc7" class="lw lx ht jh b ji mf jm mg jq mh ju mi jy mj kc mb mc md me dt translated">在qrProofRequestJson中，在<strong class="jh hu"> req </strong>下添加您在声明时给出的属性名称。对我们来说，是年龄。然后，您可以告诉操作员它是小于请求值还是大于请求值以及阈值。</li><li id="77d3" class="lw lx ht jh b ji mf jm mg jq mh ju mi jy mj kc mb mc md me dt translated">在<strong class="jh hu"> schema </strong>部分下，您需要指定模式URL和类型，即您为模式指定的名称。在我们的例子中，它是一个年龄证书。</li></ol><pre class="li lj lk ll fq lm ln lo bn lp lq bi"><span id="fde8" class="lr kf ht ln b be ls lt l lu lv">id: "c811849d-6bfb-4d85-936e-3d9759c7f105",<br/>  typ: "application/iden3comm-plain-json",<br/>  type: "https://iden3-communication.io/proofs/1.0/contract-invoke-request",<br/>  body: {<br/>    transaction_data: {<br/>      contract_address: deployedContractAddress,<br/>      method_id: "b68967e2",<br/>      chain_id: 80001,<br/>      network: "polygon-mumbai"<br/>    },<br/>    reason: "ERC20 Transfer using On chain Verification",<br/>    scope: [<br/>      {<br/>        id: 1,<br/>        circuit_id: "credentialAtomicQuerySig",<br/>        rules: {<br/>          query: {<br/>            allowed_issuers: ["*"],<br/>            req: {<br/>              Age: {<br/>                $gt: 18<br/>              }<br/>            },<br/>            schema: {<br/>              url:<br/>                "https://s3.eu-west-1.amazonaws.com/polygonid-schemas/33f9238b-dad0-440e-aa20-4561606c289b.json-ld",<br/>              type: "AgeCredential"<br/>            }<br/>          }<br/>        }<br/>      }<br/>    ]<br/>  }</span></pre><p id="f555" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">现在我们都设置好了，让我们用验证者的证明请求来验证我们的用户是否超过18岁。</p><p id="c69e" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">打开Polygon ID wallet应用程序，扫描react应用程序中生成的二维码。</p><p id="9763" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">你会看到这样的过程—</p><figure class="li lj lk ll fq iu fe ff paragraph-image"><div class="fe ff nd"><img src="../Images/e83e84fda2fdd3f67a876155ffa501c3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*PseuhM8vQGvu0F537-XSxg.jpeg"/></div></figure><figure class="li lj lk ll fq iu fe ff paragraph-image"><div class="fe ff nd"><img src="../Images/9037b5bc02dc23b6901553c436c50d77.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*HQhhRlROLI_x4z2_8iYBOA.jpeg"/></div></figure><figure class="li lj lk ll fq iu fe ff paragraph-image"><div class="fe ff nd"><img src="../Images/d71932f4f69ca9e8ad884e6aac1012dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*BMmfGKqeRk-ugLehnkmVEA.jpeg"/></div></figure><figure class="li lj lk ll fq iu fe ff paragraph-image"><div class="fe ff nd"><img src="../Images/6c0900f874d9df418fd8268b4f490f6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*O53saDAUMukPqGGORA9aIg.jpeg"/></div></figure><figure class="li lj lk ll fq iu fe ff paragraph-image"><div class="fe ff nd"><img src="../Images/4b83ab0da415e36a40fda2e621ba990e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*lrKwi5hOkYfS0KKXlGItFg.jpeg"/></div></figure><figure class="li lj lk ll fq iu fe ff paragraph-image"><div class="fe ff nd"><img src="../Images/5d368ada803d7acbb443b494a0d1a70d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*qy040QnWgDRPvxOm6rWqCA.jpeg"/></div></figure><figure class="li lj lk ll fq iu fe ff paragraph-image"><div class="fe ff nd"><img src="../Images/6c0900f874d9df418fd8268b4f490f6f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*O53saDAUMukPqGGORA9aIg.jpeg"/></div></figure><figure class="li lj lk ll fq iu fe ff paragraph-image"><div class="fe ff nd"><img src="../Images/f3ea0d5bdea6185683dc24174ebf76ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*aOOxtzxnRfUS7DFChjC7aA.jpeg"/></div></figure><p id="71ba" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">在对多边形扫描检查之后，我们将会看到——</p><figure class="li lj lk ll fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff ne"><img src="../Images/684015f01c88f7e91d8ba800c67a792c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nNc1rkEI8ZinY6WnLF_DuA.png"/></div></div></figure><p id="2d59" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">我们的请求已成功提交，我们的用户获得了ERC20Verfier令牌，因为他已超过18岁。</p><figure class="li lj lk ll fq iu fe ff paragraph-image"><div class="fe ff nd"><img src="../Images/f9877a65e3b566561846991b1f1106fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*s1UYWhCBKk-AUcJLRRoBxQ.jpeg"/></div></figure><p id="e7f4" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">这就结束了Polygon ID简介系列，该系列详细介绍了核心概念、声明的发布、声明的验证。</p><p id="2b4a" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">我给那些跟随教程的人的建议是尝试一些不同的用例，并在你的dapps中使用多边形ID。</p><p id="fb21" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">如果你觉得我的文章很有用，或者如果你把这个概念用到你的dapps中，请在twitter上给我加标签。如果你觉得这篇文章有用，请给我鼓掌或在<a class="ae kd" rel="noopener" href="/@atharvapaliwal7">媒体</a>上留言。你也可以在<a class="ae kd" href="https://www.linkedin.com/in/atharva-paliwal-70676a175/?originalSubdomain=in" rel="noopener ugc nofollow" target="_blank"> Linkedin </a>上找到我，并与你想了解Polygon ID的朋友分享。</p></div><div class="ab cl mk ml hb mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hm hn ho hp hq"><h1 id="2f1b" class="ke kf ht bd kg kh mr kj kk kl ms kn ko kp mt kr ks kt mu kv kw kx mv kz la lb dt translated">重要资源</h1><p id="985c" class="pw-post-body-paragraph jf jg ht jh b ji lc jk jl jm ld jo jp jq le js jt ju lf jw jx jy lg ka kb kc hm dt translated">本文github Repo—<a class="ae kd" href="https://github.com/pikachua7/Polygon-ID-On-Chain-Verification-Age" rel="noopener ugc nofollow" target="_blank">https://github . com/pikachua 7/Polygon-ID-On-Chain-Verification-Age</a></p><p id="e11c" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">Manny编码—<a class="ae kd" href="https://github.com/codingwithmanny/polygonid-on-chain-verification" rel="noopener ugc nofollow" target="_blank">https://github . com/codingwithmanny/polygonid-on-chain-verification</a></p><p id="cdb4" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">多边形ID文档—<a class="ae kd" href="https://0xpolygonid.github.io/tutorials/" rel="noopener ugc nofollow" target="_blank">https://0xpolygonid.github.io/tutorials/</a></p><p id="dfe5" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">iden 3 docs—<a class="ae kd" href="https://docs.iden3.io/" rel="noopener ugc nofollow" target="_blank">https://docs.iden3.io/</a></p><p id="1c6b" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">多边形ID平台—<a class="ae kd" href="https://platform-test.polygonid.com/sign-in" rel="noopener ugc nofollow" target="_blank">https://platform-test.polygonid.com/sign-in</a></p><p id="ab8b" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">多边形ID平台视频—<a class="ae kd" href="https://youtu.be/VClUFjs8lh8" rel="noopener ugc nofollow" target="_blank">https://youtu.be/VClUFjs8lh8</a></p><p id="1549" class="pw-post-body-paragraph jf jg ht jh b ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc hm dt translated">声明和模式—<a class="ae kd" href="https://docs.iden3.io/protocol/claims-structure/" rel="noopener ugc nofollow" target="_blank">https://docs.iden3.io/protocol/claims-structure/</a></p><blockquote class="nf"><p id="776c" class="ng nh ht bd ni nj nk nl nm nn no kc ek translated">交易新手？试试<a class="ae kd" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或者<a class="ae kd" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>