<html>
<head>
<title>Solidity: usage of code designed on outdated pragma</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可靠性:使用设计在过时的pragma上的代码</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/solidity-usage-of-code-designed-on-outdated-pragma-52069c27976?source=collection_archive---------13-----------------------#2022-10-24">https://medium.com/coinmonks/solidity-usage-of-code-designed-on-outdated-pragma-52069c27976?source=collection_archive---------13-----------------------#2022-10-24</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/8daf194f005d97b30f93a68a19e257e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*ilYS-arMdKmN_tp1.png"/></div></div></figure><h2 id="7869" class="jb jc ht bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy dt translated">介绍</h2><p id="71f5" class="pw-post-body-paragraph jz ka ht kb b kc kd ke kf kg kh ki kj jm kk kl km jq kn ko kp ju kq kr ks kt hm dt translated">Solidity是一种用于在EVM兼容平台上实现智能合约的编程语言。随着it的高速发展，包含重大变更的新版本会定期出现。</p><p id="e89d" class="pw-post-body-paragraph jz ka ht kb b kc ku ke kf kg kv ki kj jm kw kl km jq kx ko kp ju ky kr ks kt hm dt translated">然而，solidity发布了<a class="ae kz" href="https://docs.soliditylang.org/en/v0.8.17/080-breaking-changes.html#solidity-v0-8-0-breaking-changes" rel="noopener ugc nofollow" target="_blank">重大变更列表</a>和<a class="ae kz" href="https://docs.soliditylang.org/en/v0.8.17/080-breaking-changes.html#how-to-update-your-code" rel="noopener ugc nofollow" target="_blank">对编译指示迁移的建议</a>。pragma会被错误地迁移，一些功能会被破坏。</p><h2 id="0412" class="jb jc ht bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy dt translated">为什么pragma迁移错误？</h2><ul class=""><li id="4f73" class="la lb ht kb b kc kd kg kh jm lc jq ld ju le kt lf lg lh li dt translated">开发人员不了解代码依赖于旧的行为</li><li id="b881" class="la lb ht kb b kc lj kg lk jm ll jq lm ju ln kt lf lg lh li dt translated">开发人员不理解其中的逻辑，并提供无意识的修复，直到编译器停止显示警告</li></ul><h1 id="f874" class="lo jc ht bd jd lp lq lr jh ls lt lu jl lv lw lx jp ly lz ma jt mb mc md jx me dt translated">pragma迁移可能出错的示例</h1><p id="db33" class="pw-post-body-paragraph jz ka ht kb b kc kd ke kf kg kh ki kj jm kk kl km jq kn ko kp ju kq kr ks kt hm dt translated">例如，UniSwap <a class="ae kz" href="https://github.com/Uniswap/v3-core/blob/fc2107bd5709cdee6742d5164c1eb998566bcb75/contracts/libraries/FullMath.sol" rel="noopener ugc nofollow" target="_blank"> FullMath </a>库是为<em class="mf"> solidity &lt; 0.8.0 </em>设计的。<br/>迁移到<em class="mf"> solidity ~0.8.0 </em>时有哪些常见错误？</p><p id="d4e9" class="pw-post-body-paragraph jz ka ht kb b kc ku ke kf kg kv ki kj jm kw kl km jq kx ko kp ju ky kr ks kt hm dt translated"><strong class="kb hu">首先，开发者要注意</strong> <a class="ae kz" href="https://github.com/Uniswap/v3-core/blob/fc2107bd5709cdee6742d5164c1eb998566bcb75/contracts/libraries/FullMath.sol#L91-L96" rel="noopener ugc nofollow" target="_blank"> <strong class="kb hu">第91–96行</strong> </a> <strong class="kb hu"> : </strong></p><pre class="mg mh mi mj fq mk ml mm mn aw mo dt"><span id="1934" class="jb jc ht ml b fv mp mq l mr ms">inv *= 2 — denominator * inv; // inv and denominator are uint256</span></pre><p id="d5df" class="pw-post-body-paragraph jz ka ht kb b kc ku ke kf kg kv ki kj jm kw kl km jq kx ko kp ju ky kr ks kt hm dt translated">想要的数学下溢经常发生在那里。但是在<em class="mf"> solidity ~0.8.0中，</em>数学上溢和下溢是被阻止的，开发者经常会错过，所以代码可能会返回一个不想要的异常。</p><p id="898c" class="pw-post-body-paragraph jz ka ht kb b kc ku ke kf kg kv ki kj jm kw kl km jq kx ko kp ju ky kr ks kt hm dt translated"><strong class="kb hu">二、</strong> <a class="ae kz" href="https://github.com/Uniswap/v3-core/blob/fc2107bd5709cdee6742d5164c1eb998566bcb75/contracts/libraries/FullMath.sol#L64" rel="noopener ugc nofollow" target="_blank"> <strong class="kb hu">线64 </strong> </a> <strong class="kb hu"> : </strong>处有一个不可比拟的瞬间</p><pre class="mg mh mi mj fq mk ml mm mn aw mo dt"><span id="f225" class="jb jc ht ml b fv mp mq l mr ms">// Factor powers of two out of the denominator<br/>// Compute the largest power of two divisors of the denominator<br/>uint256 twos = -denominator &amp; denominator;</span></pre><p id="df54" class="pw-post-body-paragraph jz ka ht kb b kc ku ke kf kg kv ki kj jm kw kl km jq kx ko kp ju ky kr ks kt hm dt translated">返回编译异常，<em class="mf"> solidity ~0.8.0 </em>编译器为一元运算符“-”不能应用于类型<em class="mf"> uint256 </em>。建议开发商把这个数字做成有符号的整数。因此，最终迁移的代码看起来可能是这样的:</p><pre class="mg mh mi mj fq mk ml mm mn aw mo dt"><span id="95be" class="jb jc ht ml b fv mp mq l mr ms">uint256 twos = uint256(-int256(denominator) &amp; int256(denominator));<br/>// is equal to<br/>uint256 twos = uint256(-int256(denominator)) &amp; denominator;</span></pre><p id="770c" class="pw-post-body-paragraph jz ka ht kb b kc ku ke kf kg kv ki kj jm kw kl km jq kx ko kp ju ky kr ks kt hm dt translated">但是这两个修改都因为<em class="mf">分母= 2**255 </em>而被打破。由于<em class="mf"> MAX_INT256 = 2**255-1 </em>和<em class="mf"> int256(2**255) = -2**255 </em>，所以对<em class="mf"> int256(2**255) </em>应用一元运算符“-”会溢出<em class="mf"> int256 </em>类型。</p><p id="ca8b" class="pw-post-body-paragraph jz ka ht kb b kc ku ke kf kg kv ki kj jm kw kl km jq kx ko kp ju ky kr ks kt hm dt translated"><strong class="kb hu">第三，台词</strong> <a class="ae kz" href="https://github.com/Uniswap/v3-core/blob/fc2107bd5709cdee6742d5164c1eb998566bcb75/contracts/libraries/FullMath.sol#L80" rel="noopener ugc nofollow" target="_blank"> <strong class="kb hu"> 80 </strong> </a> <strong class="kb hu">，</strong> <a class="ae kz" href="https://github.com/Uniswap/v3-core/blob/fc2107bd5709cdee6742d5164c1eb998566bcb75/contracts/libraries/FullMath.sol#L87" rel="noopener ugc nofollow" target="_blank"> <strong class="kb hu"> 87 </strong> </a> <strong class="kb hu">，</strong><a class="ae kz" href="https://github.com/Uniswap/v3-core/blob/fc2107bd5709cdee6742d5164c1eb998566bcb75/contracts/libraries/FullMath.sol#L104" rel="noopener ugc nofollow" target="_blank"><strong class="kb hu">104</strong></a><strong class="kb hu">:</strong></p><p id="1493" class="pw-post-body-paragraph jz ka ht kb b kc ku ke kf kg kv ki kj jm kw kl km jq kx ko kp ju ky kr ks kt hm dt translated">由于没有提供算法的数学证明，因此不清楚是否应该防止溢出。所以动作也可能被忘记包装到未检查的块中。</p><p id="ec29" class="pw-post-body-paragraph jz ka ht kb b kc ku ke kf kg kv ki kj jm kw kl km jq kx ko kp ju ky kr ks kt hm dt translated">但是，可以通过简单的测试来检查行中是否抛出了错误。根据下面的例子，溢出应该在那里，所以需要包装到未检查的块。</p><p id="abfb" class="pw-post-body-paragraph jz ka ht kb b kc ku ke kf kg kv ki kj jm kw kl km jq kx ko kp ju ky kr ks kt hm dt translated">mulDiv(2**253，2**254，2**255)导致第<a class="ae kz" href="https://github.com/Uniswap/v3-core/blob/fc2107bd5709cdee6742d5164c1eb998566bcb75/contracts/libraries/FullMath.sol#L104" rel="noopener ugc nofollow" target="_blank"> 104 </a>行溢出；mulDiv(2 * * 253–2，2 * * 254–3，2**255n-4)导致第<a class="ae kz" href="https://github.com/Uniswap/v3-core/blob/fc2107bd5709cdee6742d5164c1eb998566bcb75/contracts/libraries/FullMath.sol#L80" rel="noopener ugc nofollow" target="_blank"> 80 </a>，<a class="ae kz" href="https://github.com/Uniswap/v3-core/blob/fc2107bd5709cdee6742d5164c1eb998566bcb75/contracts/libraries/FullMath.sol#L91-L96" rel="noopener ugc nofollow" target="_blank">91–96</a><br/>行溢出</p><p id="4f34" class="pw-post-body-paragraph jz ka ht kb b kc ku ke kf kg kv ki kj jm kw kl km jq kx ko kp ju ky kr ks kt hm dt translated"><strong class="kb hu">虽然所有的点都可能被正确地修正，但是修改节能代码被认为是一个坏主意。</strong></p><h1 id="6454" class="lo jc ht bd jd lp lq lr jh ls lt lu jl lv lw lx jp ly lz ma jt mb mc md jx me dt translated">如何使用带有过时pragma的代码？</h1><p id="c539" class="pw-post-body-paragraph jz ka ht kb b kc kd ke kf kg kh ki kj jm kk kl km jq kn ko kp ju kq kr ks kt hm dt translated">解决方案是将设计在过时pragma上的代码分离到一个单独的库中，然后链接目标契约。</p><ul class=""><li id="bac8" class="la lb ht kb b kc ku kg kv jm mt jq mu ju mv kt lf lg lh li dt translated">使用旧的solidity编译器将所有硬更新逻辑移到库中</li></ul><pre class="mg mh mi mj fq mk ml mm mn aw mo dt"><span id="a752" class="jb jc ht ml b fv mp mq l mr ms">pragma solidity outdated;</span><span id="e10f" class="jb jc ht ml b fv mw mq l mr ms">library Lib {<br/>    function foo(params) external/public pure? returns (types) {<br/>        *logic requires an old compiler version*</span><span id="2ca1" class="jb jc ht ml b fv mw mq l mr ms">        ...<br/>    }</span><span id="95c0" class="jb jc ht ml b fv mw mq l mr ms">    ...<br/>}</span></pre><ul class=""><li id="2c5d" class="la lb ht kb b kc ku kg kv jm mt jq mu ju mv kt lf lg lh li dt translated">使用实际的pragma创建一个具有相同函数签名的库模型</li></ul><pre class="mg mh mi mj fq mk ml mm mn aw mo dt"><span id="a0de" class="jb jc ht ml b fv mp mq l mr ms">pragma solidity actual;</span><span id="d9b8" class="jb jc ht ml b fv mw mq l mr ms">library LibMockup {<br/>    function foo(params) external pure? returns (types) {}</span><span id="807e" class="jb jc ht ml b fv mw mq l mr ms">    ...<br/>}</span></pre><ul class=""><li id="68ef" class="la lb ht kb b kc ku kg kv jm mt jq mu ju mv kt lf lg lh li dt translated">将模型库导入目标合同，并在需要的地方使用它</li></ul><pre class="mg mh mi mj fq mk ml mm mn aw mo dt"><span id="c977" class="jb jc ht ml b fv mp mq l mr ms">pragma solidity <!-- -->actual<!-- -->;</span><span id="ff21" class="jb jc ht ml b fv mw mq l mr ms">import "<!-- -->LibMockup<!-- -->";</span><span id="4b37" class="jb jc ht ml b fv mw mq l mr ms">contract Target {<br/>    function func(params) public? pure? returns (types) {<br/>        ...</span><span id="3680" class="jb jc ht ml b fv mw mq l mr ms">        results = <!-- -->LibMockup<!-- -->.foo(lib_params);</span><span id="5ac1" class="jb jc ht ml b fv mw mq l mr ms">        ...<br/>    }</span><span id="ac13" class="jb jc ht ml b fv mw mq l mr ms">    ...<br/>}</span></pre><ul class=""><li id="e569" class="la lb ht kb b kc ku kg kv jm mt jq mu ju mv kt lf lg lh li dt translated">配置HardHat，用环境配置文件中部署的库地址替换契约中的模型引用</li></ul><pre class="mg mh mi mj fq mk ml mm mn aw mo dt"><span id="9f34" class="jb jc ht ml b fv mp mq l mr ms">const LibFactory = await hardhat.ethers.getContractFactory("Lib")<br/>const LibInstance = await LibFactory.deploy()</span><span id="cc13" class="jb jc ht ml b fv mw mq l mr ms">const ContractFactory = await hardhat.ethers.getContractFactory("Target", {<br/>  libraries: {<br/>    LibMockup: LibInstance.address,<br/>  },<br/>})<br/>const ContractInstance = await ContractFactory.deploy()</span></pre><p id="9ddb" class="pw-post-body-paragraph jz ka ht kb b kc ku ke kf kg kv ki kj jm kw kl km jq kx ko kp ju ky kr ks kt hm dt translated">详细工作代码示例<a class="ae kz" href="https://github.com/SteMak/solidity_outdated_lib_usage" rel="noopener ugc nofollow" target="_blank">见这里</a>。</p><h1 id="658f" class="lo jc ht bd jd lp lq lr jh ls lt lu jl lv lw lx jp ly lz ma jt mb mc md jx me dt translated">尾声</h1><p id="249a" class="pw-post-body-paragraph jz ka ht kb b kc kd ke kf kg kh ki kj jm kk kl km jq kn ko kp ju kq kr ks kt hm dt translated">如果将节能代码迁移到新的编译指令:</p><ul class=""><li id="4bef" class="la lb ht kb b kc ku kg kv jm mt jq mu ju mv kt lf lg lh li dt translated">记住！强制杂注迁移可能会导致意外的结果</li><li id="f5d9" class="la lb ht kb b kc lj kg lk jm ll jq lm ju ln kt lf lg lh li dt translated">仔细检查每一行，将其与重大变更列表进行比较</li><li id="62af" class="la lb ht kb b kc lj kg lk jm ll jq lm ju ln kt lf lg lh li dt translated"><strong class="kb hu">彻底测试移植的代码！</strong></li></ul><p id="847a" class="pw-post-body-paragraph jz ka ht kb b kc ku ke kf kg kv ki kj jm kw kl km jq kx ko kp ju ky kr ks kt hm dt translated">如果你不确定你在做什么，使用上面的指南来避免代码修改。</p><p id="2925" class="pw-post-body-paragraph jz ka ht kb b kc ku ke kf kg kv ki kj jm kw kl km jq kx ko kp ju ky kr ks kt hm dt translated"><strong class="kb hu">被迁移的代码在被可信的审计公司检查之前是不安全的！</strong></p><blockquote class="mx"><p id="6854" class="my mz ht bd na nb nc nd ne nf ng kt ek translated">交易新手？尝试<a class="ae kz" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae kz" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>