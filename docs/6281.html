<html>
<head>
<title>Learn Solidity lesson 35. Libraries.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习第35课固体。图书馆。</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/learn-solidity-lesson-35-libraries-74beb9fff0e6?source=collection_archive---------2-----------------------#2022-11-13">https://medium.com/coinmonks/learn-solidity-lesson-35-libraries-74beb9fff0e6?source=collection_archive---------2-----------------------#2022-11-13</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/b5fb5457c2ce8b1b3fe78b04df3784f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OeJsqeRvGESWqw7G2R1nag.jpeg"/></div></div></figure><p id="7ce3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">库的目的是作为一个可重用的代码库。这样的代码可以合并到合同中，也可以发布到一个外部地址，最好是发布一次，然后从那里使用。在第二种情况下，使用操作码<em class="jz"> delegatecall </em>调用库，因为库是无状态的。</p><p id="bdb5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">有一点应该明确:库应该被其他契约使用。因此，库没有状态变量。试图声明状态变量将产生编译错误。</p><p id="5e28" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在一个库中，具有内部可见性的函数将被使用该库的契约合并，并且将被执行，就像它们是契约本身的内部函数一样。这意味着它们将出现在合同字节码中。</p><p id="1b88" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">参考库的外部地址来执行库的外部函数。也就是说，库必须被部署，并且在契约的字节码中将只是对该函数的引用(以及库地址)。</p><p id="1a45" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们从创建一个具有内部可见性的函数的库开始，通过一个契约来合并。使用<strong class="jd hu">库</strong>关键字声明库。</p><pre class="ka kb kc kd fq ke kf kg bn kh ki bi"><span id="8451" class="kj kk ht kf b be kl km l kn ko">pragma solidity ^0.8.7;<br/><br/>library MathLib {<br/><br/>  function square(uint x) internal pure returns (uint) {<br/>    return x*x;<br/>  }<br/>}<br/><br/>contract MyContract {<br/><br/>  uint public number;<br/><br/>  function numberSquare(uint _x) public {<br/>    number = MathLib.square(_x);<br/>  }<br/>}</span></pre><p id="aae6" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在上面的代码中，声明了<code class="eh kp kq kr kf b">MathLib </code>库，契约<br/> <code class="eh kp kq kr kf b">MyContract </code>使用该库，就像它是契约基的一部分一样。注意，我们使用库函数作为<code class="eh kp kq kr kf b">MathLib.square()</code>，即使没有明确声明库是契约的基础。也就是说，我们不像在继承中那样使用is关键字。编译器负责这项任务。</p><p id="04a5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">库不需要和契约位于同一个文件中，用<strong class="jd hu"> import </strong>关键字导入即可。让我们导入保存在文件<code class="eh kp kq kr kf b">MathLib.sol</code>中的库。</p><pre class="ka kb kc kd fq ke kf kg bn kh ki bi"><span id="0994" class="kj kk ht kf b be kl km l kn ko">import "./MathLib.sol";</span></pre><p id="4896" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在让我们从外部使用一个库。</p><h1 id="de21" class="ks kk ht bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo dt translated">外部库</h1><p id="6011" class="pw-post-body-paragraph jb jc ht jd b je lp jg jh ji lq jk jl jm lr jo jp jq ls js jt ju lt jw jx jy hm dt translated">库也可以部署到一个地址，然后由其他契约使用。因此，要调用的函数的字节码不包含在契约字节码中，只是对将要执行的库的引用。</p><p id="1ea0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">库与契约调用的其他契约中的函数有一些相似之处，但有两个主要区别。第一个是使用操作码<em class="jz"> delegatecall </em>调用该函数，因此它是在调用契约的上下文中调用的。在库的上下文中调用它是没有意义的，因为库是无状态的。</p><p id="16f0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">第二个区别是我们如何在合同中引用库。编译器有生成引用的功能，所以在我们编译契约的时候需要声明。因此，不同的平台有不同的引用方法。</p><p id="f204" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们编写一个带有外部函数的库，并在契约中调用该外部函数。为此，只需将库函数的可见性更改为external。</p><pre class="ka kb kc kd fq ke kf kg bn kh ki bi"><span id="a527" class="kj kk ht kf b be kl km l kn ko">library MathLib {<br/><br/>  function square(uint x) external pure returns (uint) {<br/>    return x*x;<br/>  }<br/>}</span></pre><p id="a0e2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在我要编译契约<code class="eh kp kq kr kf b">MyContract</code>，它使用了这个函数。下图显示了生成的部分字节码。</p><figure class="ka kb kc kd fq iu fe ff paragraph-image"><div class="fe ff lu"><img src="../Images/912fb0cafc8cccedf077ef9f8bbc7a0a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1330/format:webp/1*OR1at0oW4wWwLO_U5vah7g.png"/></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">The bytecode contains a placeholder for the address of the library.</figcaption></figure><p id="1ecc" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">代码<code class="eh kp kq kr kf b">__$469293c1fbd40e30447e104b71d3281fa6$__</code>是库地址的占位符。在发布合同之前，您必须用图书馆的地址替换此代码。在混音中，这是在元数据中指定的。</p><p id="be46" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当使用Remix虚拟机时，在部署时没有问题，因为Remix会自动包含库地址。当我们部署到真正的区块链时，我们需要手动完成。我首先将库部署到Goerli，如下图所示。该库现在位于以下地址:0 xbe 34 e 7005 FD 7 f 6 c 87 f 84224443 bcfb 69 F2 a 45005。</p><figure class="ka kb kc kd fq iu fe ff paragraph-image"><div class="fe ff lz"><img src="../Images/22ed4c6579de174c0b224c6e49768d74.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*ctBgTMPnx8XSfdSrvo1DGg.png"/></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">Deployment of the library on the Goerli network.</figcaption></figure><p id="da9c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在元数据文件<em class="jz"> MyContract.json </em>中，我们找到一个可以包含库地址的地方。这一点可以从下图中看出。</p><figure class="ka kb kc kd fq iu fe ff paragraph-image"><div class="fe ff ma"><img src="../Images/974ec4898ffb3e796298f475cbf30321.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*-z3-kjSdyrjKVXQTNESLZQ.png"/></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">The library address must be included in the metadata.</figcaption></figure><p id="c4cc" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">将占位符“<address>”更改为库的地址，并将选项“autoDeployLib”更改为false，因为我们不想部署库。</address></p><p id="3657" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在部署时，Remix会表明它已经将契约与库链接起来，如下图所示。</p><figure class="ka kb kc kd fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mb"><img src="../Images/c39b3ffd9f9fe51777df9b99df827643.png" data-original-src="https://miro.medium.com/v2/resize:fit:1320/format:webp/1*bCFUZAgKhtPvpDP_2xNjxg.png"/></div></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">Remix indicates that the library has been linked to the contract.</figcaption></figure><p id="10a0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">然后将库地址放入字节码<em class="jz">中</em>，并将其发送给元掩码。例如，在块浏览器中搜索字节码中的库地址，可以清楚地看到地址就在那里，如下图所示。</p><figure class="ka kb kc kd fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mc"><img src="../Images/42052e3bf49491e3060a202beef5a97a.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*ns2UBFnzqzfkx5vWhOND8w.png"/></div></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">The library address can be found in the contract bytecode.</figcaption></figure><p id="66d2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">因此，我们可以使用任何已经部署的库。为此，我们需要库代码，因为契约编译必须与库代码一起完成。此外，我们只需要图书馆地址，以链接到合同。</p><h1 id="94c5" class="ks kk ht bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo dt translated">阅读和修改合同状态</h1><p id="61a6" class="pw-post-body-paragraph jb jc ht jd b je lp jg jh ji lq jk jl jm lr jo jp jq ls js jt ju lt jw jx jy hm dt translated">由于库是无状态的，访问契约状态的唯一方法是将其作为参数显式发送给要调用的函数。最好是，库不应该改变契约状态，但是没有什么可以阻止这样做。</p><p id="d6a8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在下面的代码中，我们将创建一个函数库，该函数将对类型为<em class="jz"> uint </em>的数组的所有元素求和。</p><pre class="ka kb kc kd fq ke kf kg bn kh ki bi"><span id="bb22" class="kj kk ht kf b be kl km l kn ko">library ArrayLib {<br/><br/>  function soma(uint[] storage array) external view returns (uint) {<br/><br/>    uint total = 0;<br/>    for (uint i = 0; i &lt; array.length; i++) {<br/>      total = total + array[i];<br/>    }<br/>    return total;<br/>  }<br/>}</span></pre><p id="a415" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">该数组作为函数的参数发送到库中。在参数中，我们必须指出变量在存储中。请记住，库函数是在调用契约的上下文中运行的，因此这是对调用契约的存储的引用。</p><p id="7bf7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在让我们编写将使用该函数的契约。</p><pre class="ka kb kc kd fq ke kf kg bn kh ki bi"><span id="82e2" class="kj kk ht kf b be kl km l kn ko">pragma solidity ^0.8.7;<br/><br/>import "./ArrayLib.sol";<br/><br/>contract MyContract {<br/><br/>  uint[] public myArray = [1,2,3,4,5];<br/><br/>  function sumArray() public view returns (uint) {<br/>    return ArrayLib.sum(myArray);<br/>  }<br/>}</span></pre><p id="7c6c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">除了读取状态变量，还可以改变调用契约的状态。举例来说，我们通过将引用传递给映射来实现这一点。让我们创建一个新的库。</p><pre class="ka kb kc kd fq ke kf kg bn kh ki bi"><span id="d945" class="kj kk ht kf b be kl km l kn ko">pragma solidity ^0.8.7;<br/><br/>library MappingLib {<br/><br/>  function addMap(mapping(uint =&gt; address) storage map, uint key, address value ) external {<br/>    map[key] = value;<br/>  }<br/>}</span></pre><p id="e4c8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">上面的函数很简单，它只是给<em class="jz">映射</em>。然而，这表明改变区块链的状态是完全可能的。</p><p id="0ebc" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在契约中，我们可以如下调用这样的函数。</p><pre class="ka kb kc kd fq ke kf kg bn kh ki bi"><span id="c10c" class="kj kk ht kf b be kl km l kn ko">function addItem(uint key, address value) public {<br/>  MappingLib.addItem(myMap, key, value);<br/>}</span></pre><h1 id="7d45" class="ks kk ht bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo dt translated">扩展类型</h1><p id="2151" class="pw-post-body-paragraph jb jc ht jd b je lp jg jh ji lq jk jl jm lr jo jp jq ls js jt ju lt jw jx jy hm dt translated">库也可以用来扩展类型的功能。在上一节中，我们创建了一个库来对一个类型为<em class="jz"> uint </em>的数组的所有元素求和，我们如下使用这个库。</p><pre class="ka kb kc kd fq ke kf kg bn kh ki bi"><span id="9e1e" class="kj kk ht kf b be kl km l kn ko">ArrayLib.sum(myArray);</span></pre><p id="3337" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这种方法很实用，但不太优雅。如果能够使用函数<code class="eh kp kq kr kf b">sum</code>作为类型<em class="jz"> uint[] </em>的方法，那就更好了，这是可能的。</p><p id="ef41" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">为此，只需使用库扩展<em class="jz"> uint[] </em>类型。这是通过使用关键字使用<strong class="jd hu">完成的，如下所示。</strong></p><pre class="ka kb kc kd fq ke kf kg bn kh ki bi"><span id="0a44" class="kj kk ht kf b be kl km l kn ko">contract MyContract {<br/>  using ArrayLib for uint[];<br/>  ...<br/>}</span></pre><p id="b01a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在<code class="eh kp kq kr kf b">ArrayLib</code>库方法扩展了<em class="jz"> uint[] </em>类型，我们可以如下使用<code class="eh kp kq kr kf b">sum</code>方法。</p><pre class="ka kb kc kd fq ke kf kg bn kh ki bi"><span id="ed38" class="kj kk ht kf b be kl km l kn ko">myArray.sum();</span></pre><p id="0c12" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh kp kq kr kf b">sum</code>函数期望类型为<em class="jz"> uint[] </em>的值作为第一个参数，执行该方法的变量作为第一个参数发送。如果函数与变量不兼容(例如，如果它的第一个参数不是类型<em class="jz"> uint[] </em>)，编译器将抛出一个错误。</p><p id="45d2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">感谢阅读！</strong></p><p id="ef1a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎对本文提出意见和建议。</p><p id="665d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎任何投稿。<a class="ae md" href="http://www.buymeacoffee.com/jpmorais" rel="noopener ugc nofollow" target="_blank">www.buymeacoffee.com/jpmorais</a>。</p><blockquote class="me"><p id="5c1e" class="mf mg ht bd mh mi mj mk ml mm mn jy ek translated">交易新手？尝试<a class="ae md" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae md" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>