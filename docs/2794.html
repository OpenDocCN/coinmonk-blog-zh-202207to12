<html>
<head>
<title>Learn Solidity lesson 31. Inheritance.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习第31课坚固性。遗产。</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/learn-solidity-lesson-31-inheritance-761ee4c66c0f?source=collection_archive---------4-----------------------#2022-08-27">https://medium.com/coinmonks/learn-solidity-lesson-31-inheritance-761ee4c66c0f?source=collection_archive---------4-----------------------#2022-08-27</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/e26145a3e808adbd094718ca63eb4910.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HbGwQI0zxLNNkQmCgVGo0g.jpeg"/></div></div></figure><p id="8d27" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">面向对象编程的支柱之一是继承的概念。一个类可以从另一个类继承属性和方法，形成一个继承树。我们将在本课和下一课中详细研究这一点。</p><p id="d1ea" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在下面的代码中，定义了一个名为<code class="eh jz ka kb kc b">Foo</code>的契约，带有一个状态变量。合同<code class="eh jz ka kb kc b">Bar</code>继承自合同<code class="eh jz ka kb kc b">Foo</code>。为了表明这一点，我们使用关键字<strong class="jd hu">是</strong>，就像<code class="eh jz ka kb kc b">Bar is Foo</code>一样。</p><pre class="kd ke kf kg fq kh kc ki kj aw kk dt"><span id="daf8" class="kl km ht kc b fv kn ko l kp kq">pragma solidity ^0.8.7;</span><span id="bb2d" class="kl km ht kc b fv kr ko l kp kq">contract Foo {<br/>   uint value = 30;<br/>}</span><span id="177f" class="kl km ht kc b fv kr ko l kp kq">contract Bar is Foo {<br/>   function getValue() public view returns (uint) {<br/>      return value;<br/>   }<br/>}</span></pre><p id="0243" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当契约<code class="eh jz ka kb kc b">Bar</code>继承自<code class="eh jz ka kb kc b">Foo</code>时，它继承了所有未声明为私有的状态变量和函数。在上面的例子中，函数<code class="eh jz ka kb kc b">getValue</code>将返回值<code class="eh jz ka kb kc b">30</code>，其值在契约<code class="eh jz ka kb kc b">Foo</code>中被赋值。</p><p id="3e99" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">应该清楚的是,<code class="eh jz ka kb kc b">Bar</code>契约继承的所有东西都被插入到它的字节码中。就好像<code class="eh jz ka kb kc b">value</code>状态变量是由<code class="eh jz ka kb kc b">Bar</code>契约本身定义的。</p><p id="742f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在，或许私有变量和内部变量之间的区别会变得更加清晰。内部变量由子契约继承，而私有变量则不是。如果我们更改Foo合同中的以下行:</p><pre class="kd ke kf kg fq kh kc ki kj aw kk dt"><span id="533e" class="kl km ht kc b fv kn ko l kp kq">uint private value = 30;</span></pre><p id="7068" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">变量<code class="eh jz ka kb kc b">value </code>将不再被<code class="eh jz ka kb kc b">Bar</code>继承，编译器将抛出一个错误。</p><h1 id="663d" class="ks km ht bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo dt translated">继承函数</h1><p id="0878" class="pw-post-body-paragraph jb jc ht jd b je lp jg jh ji lq jk jl jm lr jo jp jq ls js jt ju lt jw jx jy hm dt translated">现在让我们编写一个从另一个契约继承函数的契约。让我们看看下面的代码。</p><pre class="kd ke kf kg fq kh kc ki kj aw kk dt"><span id="e7cb" class="kl km ht kc b fv kn ko l kp kq">pragma solidity ^0.8.7;</span><span id="7a2c" class="kl km ht kc b fv kr ko l kp kq">contract Foo {<br/>   function calculate(uint x, uint y) public pure returns (uint) {<br/>      return x+y;<br/>   } <br/>}</span><span id="b730" class="kl km ht kc b fv kr ko l kp kq">contract Bar is Foo {}</span></pre><p id="d179" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">虽然<code class="eh jz ka kb kc b">Bar</code>契约被定义为空，但是它从<code class="eh jz ka kb kc b">Foo</code>契约继承了<code class="eh jz ka kb kc b">calculate</code>函数。通过在Remix中编译和部署<code class="eh jz ka kb kc b">Bar</code>契约，我们可以看到可以调用<code class="eh jz ka kb kc b">calculate</code>函数。如下图所示。</p><figure class="kd ke kf kg fq iu fe ff paragraph-image"><div class="fe ff lu"><img src="../Images/5fb46eee37cd6911d1c81d6411dc39b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:834/format:webp/1*4LS9YqvvIbbnLyS-aC8ueA.png"/></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">The Bar contract inherits the function of the Foo contract.</figcaption></figure><p id="56a1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">有时，我们希望定义一个从另一个继承而来的契约，但是使用一些行为不同的函数。然后，您需要覆盖被继承的函数。为此，我们使用关键字<strong class="jd hu">虚拟</strong>和<strong class="jd hu">覆盖</strong>。</p><p id="061f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们在<code class="eh jz ka kb kc b">Bar</code>合同上覆盖<code class="eh jz ka kb kc b">Foo</code>合同的<code class="eh jz ka kb kc b">calculate </code>功能。为此，您必须在<code class="eh jz ka kb kc b">Bar</code>合同中使用<code class="eh jz ka kb kc b">override</code>关键字。</p><pre class="kd ke kf kg fq kh kc ki kj aw kk dt"><span id="1aed" class="kl km ht kc b fv kn ko l kp kq">contract Bar is Foo {<br/>   function calculate(uint x, uint y) public override <br/>      pure returns (uint) {<br/>      return x-y;<br/>   }<br/>}</span></pre><p id="2693" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">请注意，<code class="eh jz ka kb kc b">calculate</code>函数现在将值<code class="eh jz ka kb kc b">x</code>和<code class="eh jz ka kb kc b">y</code>相减，而不是相加。</p><p id="9614" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">重写函数只是完成了一半。只能覆盖标记为<code class="eh jz ka kb kc b">virtual</code>的功能。在上面的例子中，编译器会抛出一个错误，如下图所示。</p><figure class="kd ke kf kg fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff lz"><img src="../Images/6a79f7ec74f1d95c29cd81d7dab9a3a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kw8_kSKM3yt6n9DZnqu30w.png"/></div></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">Only functions marked as virtual can be overridden.</figcaption></figure><p id="5f5a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">要修复这个错误，只需将<code class="eh jz ka kb kc b">Foo</code>契约的<code class="eh jz ka kb kc b">calculate</code>函数标记为<code class="eh jz ka kb kc b">virtual</code>，如下所示。</p><pre class="kd ke kf kg fq kh kc ki kj aw kk dt"><span id="4604" class="kl km ht kc b fv kn ko l kp kq">function calculate(uint x, uint y) public virtual pure returns (uint) {<br/>   return x+y;<br/>}</span></pre><p id="be48" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在<code class="eh jz ka kb kc b">Bar</code>契约中，每次调用<code class="eh jz ka kb kc b">calculate</code>函数时，都会调用重叠函数，这会减少值，而不是增加值。然而，只要明确声明，仍然可以调用<code class="eh jz ka kb kc b">Foo</code>契约的<code class="eh jz ka kb kc b">calculate</code>函数。</p><p id="d7be" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在下面的代码中，在Bar契约内部，我们创建了一个新函数，名为<code class="eh jz ka kb kc b">oldCalculate</code>。在这个函数中，我们通过表达式<code class="eh jz ka kb kc b">Foo.calculate</code>调用契约<code class="eh jz ka kb kc b">Foo</code>的<code class="eh jz ka kb kc b">calculate</code>函数。</p><pre class="kd ke kf kg fq kh kc ki kj aw kk dt"><span id="60af" class="kl km ht kc b fv kn ko l kp kq">function oldCalculate(uint x, uint y) public pure returns (uint) {<br/>   return Foo.calculate(x,y);<br/>}</span></pre><p id="83fa" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们也可以使用表达式<code class="eh jz ka kb kc b">super.calculate</code>，其中关键字<strong class="jd hu"> super </strong>指的是当前合同的父合同。</p><h1 id="ec9f" class="ks km ht bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo dt translated">修饰语</h1><p id="ca39" class="pw-post-body-paragraph jb jc ht jd b je lp jg jh ji lq jk jl jm lr jo jp jq ls js jt ju lt jw jx jy hm dt translated">修饰符是继承的，也可以被覆盖，类似于函数。许多库是由修饰符组成的，并且被广泛使用，比如<em class="ma"> Ownable </em>库。</p><p id="8cca" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们看看下面的代码，它只实现了本库的修饰符。</p><pre class="kd ke kf kg fq kh kc ki kj aw kk dt"><span id="813d" class="kl km ht kc b fv kn ko l kp kq">pragma solidity ^0.8.7;</span><span id="c795" class="kl km ht kc b fv kr ko l kp kq">contract Ownable {<br/>   address public owner = msg.sender;<br/>   modifier onlyOwner() {<br/>      require(msg.sender == owner);<br/>      _;<br/>   }<br/>}</span><span id="252f" class="kl km ht kc b fv kr ko l kp kq">contract Foo is Ownable {<br/>   function transferOwnership(address _new) public onlyOwner {<br/>      owner = _new;<br/>   } <br/>}</span></pre><p id="84dd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">由于契约<code class="eh jz ka kb kc b">Foo</code>继承了契约<code class="eh jz ka kb kc b">Ownable</code>，所以可以使用它的修饰符。</p><p id="b330" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">要覆盖父合同中的修改量，关键字<code class="eh jz ka kb kc b">override</code>必须包含在新修改量中，并且父修改量必须已声明为<code class="eh jz ka kb kc b">virtual</code>。就像函数一样。</p><h1 id="a709" class="ks km ht bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo dt translated">构造函数参数</h1><p id="cd85" class="pw-post-body-paragraph jb jc ht jd b je lp jg jh ji lq jk jl jm lr jo jp jq ls js jt ju lt jw jx jy hm dt translated">如果父协定具有需要参数的构造函数，则必须通过子协定将参数传递给父构造函数。有两种方法可以做到这一点。</p><p id="aaec" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">第一个是在子契约构造函数中。在实现OpenZeppelin的标准ERC20令牌契约时，我们已经看到了如何做到这一点。让我们看看下面的代码。</p><pre class="kd ke kf kg fq kh kc ki kj aw kk dt"><span id="2262" class="kl km ht kc b fv kn ko l kp kq">contract MyToken is ERC20 {<br/>   constructor() ERC20("MyToken", "MTK") {}<br/>}</span></pre><p id="c501" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当执行子契约的构造函数时，我们还使用父契约的名称调用父契约的构造函数，在本例中是ERC20。此构造函数需要两个字符串参数。</p><p id="ae79" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">第二种方法是在协定声明时传递构造函数参数，如下所示:</p><pre class="kd ke kf kg fq kh kc ki kj aw kk dt"><span id="aeef" class="kl km ht kc b fv kn ko l kp kq">contract MyToken is ERC20("My Token", "MTK") {}</span></pre><p id="ece8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果父协定的构造函数参数独立于子协定的构造函数参数，那么第二种方法更简单。如果参数不是字面量，则必须使用第二种方法。</p><p id="5437" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">例如，如果在部署时指定了两个字符串，如下所示，则必须使用第一个方法。</p><pre class="kd ke kf kg fq kh kc ki kj aw kk dt"><span id="ec4b" class="kl km ht kc b fv kn ko l kp kq">contract MyToken is ERC20 {<br/>   constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) {}<br/>}</span></pre><p id="0b68" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">感谢阅读！</strong></p><p id="a3be" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎对本文提出意见和建议。</p><p id="5952" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎任何投稿。www.buymeacoffee.com/jpmorais<a class="ae mb" href="http://www.buymeacoffee.com/jpmorais" rel="noopener ugc nofollow" target="_blank">。</a></p><blockquote class="mc"><p id="0845" class="md me ht bd mf mg mh mi mj mk ml jy ek translated">交易新手？试试<a class="ae mb" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a>或<a class="ae mb" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>