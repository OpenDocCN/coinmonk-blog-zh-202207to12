<html>
<head>
<title>Learn Solidity lesson 24. Function overloading, fallback and receive.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习第24课固体。函数重载、回退和接收。</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/learn-solidity-lesson-24-function-overloading-fallback-and-receive-5de5b39851b6?source=collection_archive---------5-----------------------#2022-08-17">https://medium.com/coinmonks/learn-solidity-lesson-24-function-overloading-fallback-and-receive-5de5b39851b6?source=collection_archive---------5-----------------------#2022-08-17</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/086edfcd50c3c3432c04cdce6a7e1e79.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pFz__T99GyncCg49SwRJcw.jpeg"/></div></div></figure><p id="7338" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在Solidity中，可以创建同名的多个函数，只要参数不同。这叫做<em class="jz">功能重载</em>。例如，我们可以创建一个名为<code class="eh ka kb kc kd b">foo</code>的函数，它有1个参数，另一个名为<code class="eh ka kb kc kd b">foo</code>的函数有2个参数，如下所示。</p><pre class="ke kf kg kh fq ki kd kj kk aw kl dt"><span id="7b01" class="km kn ht kd b fv ko kp l kq kr">function foo(uint256 x) public {...}<br/>function foo(uint256 x, uint8 y) public {...}</span></pre><p id="f3cd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当在事务或调用中被调用时，函数由它们的签名来表示，签名由它们的名字和参数的散列的前4个字节组成。由于参数不同，上述两个函数的哈希也会不同，因此签名也会不同。</p><p id="115f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">第一个函数的签名是<em class="jz"> 0x2fbebd38 </em>，而第二个函数的签名是<em class="jz"> 0xafe2f480 </em>。这样，在调用函数时就不会有歧义。甚至有可能用相同数量的参数声明两个函数，只要参数是不同的类型。</p><pre class="ke kf kg kh fq ki kd kj kk aw kl dt"><span id="a6c0" class="km kn ht kd b fv ko kp l kq kr">function bar(uint256 x) public {...}<br/>function bar(address x) public {...}</span></pre><p id="c8b0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">上面的两个函数<code class="eh ka kb kc kd b">bar</code>将有不同的签名，因此在外部调用时不会有歧义，但是在契约内部调用时必须小心。如果函数参数之间的隐式转换是可能的，当试图在内部调用函数时，编译器将指示一个错误。因此，最好避免用相同数量的参数声明两个函数。</p><p id="ff27" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">函数重载在ERC-721标准中用于不可替换的令牌。它的接口需要声明两个同名的函数，如下所示。</p><pre class="ke kf kg kh fq ki kd kj kk aw kl dt"><span id="10e4" class="km kn ht kd b fv ko kp l kq kr">function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;</span><span id="0bce" class="km kn ht kd b fv ks kp l kq kr">function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;</span></pre><p id="e9fc" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">两个函数以相同的名称<code class="eh ka kb kc kd b">safeTransferFrom</code>声明，但是参数数量不同。这解决了任何不明确的问题。</p><h1 id="4d06" class="kt kn ht bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">撤退</h1><p id="61f5" class="pw-post-body-paragraph jb jc ht jd b je lq jg jh ji lr jk jl jm ls jo jp jq lt js jt ju lu jw jx jy hm dt translated">我们在事务(或调用)中发送给契约的数据称为<strong class="jd hu">有效负载</strong>。有效载荷通常包含我们想要调用的函数的签名，以及要传递给函数的参数，以EVM ABI标准进行编码。我们已经在前面的课程中看到了这种编码是如何完成的。</p><p id="1ddf" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果有效载荷中包含的函数签名不适合合同的任何函数，则调用<strong class="jd hu">回退</strong>函数。这可能是由于失误或故意造成的。</p><p id="7baa" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">回退函数是在没有<em class="jz">函数</em>关键字的情况下声明的。它必须是外部的，可以接收和返回一个字节类型的参数，并且可以标记为payable。下面的语法定义了最常用的回退函数。</p><pre class="ke kf kg kh fq ki kd kj kk aw kl dt"><span id="3d7e" class="km kn ht kd b fv ko kp l kq kr">fallback (bytes calldata input) external [payable] returns (bytes memory output)</span></pre><p id="7097" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们使用Remix测试回退功能。首先，让我们学习如何使用任意有效负载执行事务。为此，我们使用输入<em class="jz">低级交互</em>。在<em class="jz"> CALLDATA </em>字段中输入有效载荷，点击<em class="jz"> Transact </em>。</p><p id="1341" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在下图中，我使用了以下有效负载:</p><pre class="ke kf kg kh fq ki kd kj kk aw kl dt"><span id="1c57" class="km kn ht kd b fv ko kp l kq kr">0x2fbebd380000000000000000000000000000000000000000000000000000000000000001</span></pre><p id="2143" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">前4个字节是函数<code class="eh ka kb kc kd b">foo(uint256)</code>的签名，而接下来的32个字节代表参数值1，用32个字节的十六进制写成。</p><figure class="ke kf kg kh fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff lv"><img src="../Images/6c4195a7fa1c18ebf33a678010ed6394.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tumjTIGEZQYPtXVvnujeBw.png"/></div></div><figcaption class="lw lx fg fe ff ly lz bd b be z ek">To send a transaction with a specific payload, use the Remix area named Low-Level interaction.</figcaption></figure><p id="0ca4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在右侧，我们找到了事务数据，我们清楚地看到，事务是由名为Overload的契约的函数<code class="eh ka kb kc kd b">foo(uint256)</code>接收的，正如所预期的那样。</p><p id="1f69" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在让我们发送另一个事务，但是这次使用任意的有效负载，这不适合任何现有的函数。您可以输入任何有效负载，只要它是十六进制的。在下图中，我正在发送任意有效载荷<em class="jz"> 0x112233445566 </em>。</p><figure class="ke kf kg kh fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff ma"><img src="../Images/a9d4e21a3ce49b8e29cd7be8e1d482a0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vmJbIbJEPvnfKbvmzy2TEQ.png"/></div></div><figcaption class="lw lx fg fe ff ly lz bd b be z ek">When the function signature does not fit any existing function, the fallback function is executed.</figcaption></figure><h1 id="9161" class="kt kn ht bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">接收和回退</h1><p id="2a81" class="pw-post-body-paragraph jb jc ht jd b je lq jg jh ji lr jk jl jm ls jo jp jq lt js jt ju lu jw jx jy hm dt translated">如果有效载荷是空的，会发生什么？当事务伴随以太网传输时，发送空有效负载是有意义的。在这种情况下，会调用另一个函数(如果存在的话)。函数<strong class="jd hu">接收</strong>。</p><p id="669f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">与fallback函数不同，receive函数不包含输入或输出参数，它的声明非常简单。</p><pre class="ke kf kg kh fq ki kd kj kk aw kl dt"><span id="e4a7" class="km kn ht kd b fv ko kp l kq kr">receive() external payable {}</span></pre><p id="edb1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">receive函数必须是可支付的，因为它的目的是接收以太。在下图的右侧，请注意，当发送带有空有效负载的事务时，receive函数被调用。</p><figure class="ke kf kg kh fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mb"><img src="../Images/b1eac80ec4f444998367eef27e1dc5c4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QMQBrEhVzkBl6zBWII306Q.png"/></div></div><figcaption class="lw lx fg fe ff ly lz bd b be z ek">When we send a transaction to a contract, without defining the payload, the receive function is invoked.</figcaption></figure><p id="ab02" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果没有定义接收函数，那么在有效载荷为空的情况下将调用回退函数。需要注意的是，为了接收以太网，后退功能必须是可支付的。</p><p id="6822" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果协定没有接收函数，并且其回退函数是不可支付的，则尝试向协定发送以太网将会生成错误。当然，除非交易被发送到另一个可支付函数。</p><p id="f0a7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">感谢阅读！</strong></p><p id="0bfd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎对本文提出意见和建议。</p><p id="f110" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎任何投稿。www.buymeacoffee.com/jpmorais。</p><blockquote class="md"><p id="1d65" class="me mf ht bd mg mh mi mj mk ml mm jy ek translated">交易新手？尝试<a class="ae mc" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae mc" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>