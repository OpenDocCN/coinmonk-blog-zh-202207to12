<html>
<head>
<title>Learn Solidity lesson 26. Error handling.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习第26课固体。错误处理。</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/learn-solidity-lesson-26-error-handling-ccf350bc9374?source=collection_archive---------3-----------------------#2022-08-20">https://medium.com/coinmonks/learn-solidity-lesson-26-error-handling-ccf350bc9374?source=collection_archive---------3-----------------------#2022-08-20</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/dede37d08bfe5c7bc69d7d6278ac085d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QCdSDxqjyX8QkRhyA_AE2w.jpeg"/></div></div></figure><p id="2295" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们已经看到了如何使用<code class="eh jz ka kb kc b">require</code>函数检查坚固性条件。例如，如果我们想检查一个帐户的余额是否大于某个金额，我们可以编写以下语句。</p><pre class="kd ke kf kg fq kh kc ki kj aw kk dt"><span id="3cb1" class="kl km ht kc b fv kn ko l kp kq">require(balanceOf[account] &gt; 100);</span></pre><p id="3b6b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">因此，如果括号内的表达式为false，事务将回滚。在上面的例子中，一个一般性的错误将被发送回发送者。但是，有可能返回一个指示发生了哪个错误的字符串。为此，只需向require函数传递第二个参数，如下所示。</p><pre class="kd ke kf kg fq kh kc ki kj aw kk dt"><span id="f95d" class="kl km ht kc b fv kn ko l kp kq">require(balanceOf[account] &gt; 100, "Insufficient Balance");</span></pre><p id="8b50" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">您可以在Remix中看到错误，以及事务回滚的信息。在下图中，请注意合同提供的句子“<em class="kr">原因:余额不足“</em>”。</p><figure class="kd ke kf kg fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff ks"><img src="../Images/aca960b7fe3f4575f4f712a35dc9510e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jvXbvBCXGcdsqrj1AFjHkw.png"/></div></div><figcaption class="kt ku fg fe ff kv kw bd b be z ek">When reverting, the return data will indicate the error sent by the contract.</figcaption></figure><p id="c8fc" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">有一种更高效的方式将错误发送回发送方。在Solidity中，有可能定义错误对象。不幸的是，它们不能与<code class="eh jz ka kb kc b">require </code>功能一起使用。</p><p id="792f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">使用<strong class="jd hu"> error </strong>关键字创建错误，后跟标识符和可能的参数。自定义错误的示例如下。</p><pre class="kd ke kf kg fq kh kc ki kj aw kk dt"><span id="b3c8" class="kl km ht kc b fv kn ko l kp kq">error InsufficientBalance(uint available, uint required);</span></pre><p id="aaa7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">正如我们将看到的，自定义错误必须与恢复功能结合使用。</p><h1 id="876e" class="kx km ht bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt dt translated">归还</h1><p id="b431" class="pw-post-body-paragraph jb jc ht jd b je lu jg jh ji lv jk jl jm lw jo jp jq lx js jt ju ly jw jx jy hm dt translated"><code class="eh jz ka kb kc b">revert</code>函数用于在交易执行期间随时撤销交易。它最好与自定义错误一起使用，但是为了与早期版本的EVM兼容，<code class="eh jz ka kb kc b">revert</code>函数也可以与类型为<em class="kr">字符串</em>的参数一起使用，其目的是指示返回的原因。</p><p id="4c19" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">Revert常用于条件表达式中。上一节的同一个例子，使用<code class="eh jz ka kb kc b">revert</code>进行了重构，如下所示。</p><pre class="kd ke kf kg fq kh kc ki kj aw kk dt"><span id="9b2c" class="kl km ht kc b fv kn ko l kp kq">if (balanceOf[msg.sender] &lt;= 100) revert("Insufficient Balance");</span></pre><p id="0142" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">一般来说，使用<code class="eh jz ka kb kc b">if (!condition) revert(…)</code>和<code class="eh jz ka kb kc b">require(condition,…)</code>效果是一样的。但是，我们可以使用带有自定义错误的<code class="eh jz ka kb kc b">revert</code>函数。</p><p id="be64" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们再来看看上一节中声明的自定义错误:</p><pre class="kd ke kf kg fq kh kc ki kj aw kk dt"><span id="a8fd" class="kl km ht kc b fv kn ko l kp kq">error InsufficientBalance(uint available, uint required);</span></pre><p id="6e4d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这种自定义错误可以由revert函数实例化，如下所示。</p><pre class="kd ke kf kg fq kh kc ki kj aw kk dt"><span id="f59d" class="kl km ht kc b fv kn ko l kp kq">if (balanceOf[msg.sender] &lt;= 100)<br/>   revert InsufficientBalance(balanceOf[msg.sender], 100);</span></pre><p id="d29b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">发回的自定义错误可以被解析为一个对象。我们可以在下图中看到结果，其中显示了发送的错误及其参数值。</p><figure class="kd ke kf kg fq iu fe ff paragraph-image"><div class="fe ff lz"><img src="../Images/0a346889bb08b67f0dc8fc797ad429a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1196/format:webp/1*Y-OWJtFttYygSPhTahyNXg.png"/></div><figcaption class="kt ku fg fe ff kv kw bd b be z ek">Sending a custom error using the <code class="eh jz ka kb kc b">revert</code> function. It can be parsed by the client.</figcaption></figure><p id="ca2a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">与函数一样，错误以ABI编码返回给发送方。让我们通过使用Remix将一个交易发送到真实区块链上的一个合同来看看这一点。它将警告事务很可能会回滚。这一点可以从下图中看出。</p><figure class="kd ke kf kg fq iu fe ff paragraph-image"><div class="fe ff ma"><img src="../Images/5c834cc0e044337f2c8528ad4b78807a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1354/format:webp/1*n6Hrmh2hvGsmNR8ob1KDqA.png"/></div><figcaption class="kt ku fg fe ff kv kw bd b be z ek">Remix indicates that the transaction is likely to roll back.</figcaption></figure><p id="13fd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">Remix像许多钱包一样，可以模拟交易，并验证它(很可能)会反转。请注意返回的<em class="kr">数据</em>字段:它是ABI编码的，指示契约抛出了哪个错误。若要反序列化该错误，您必须拥有协定的ABI。</p><p id="5f37" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在上面的例子中，错误的数据如下:</p><pre class="kd ke kf kg fq kh kc ki kj aw kk dt"><span id="4c52" class="kl km ht kc b fv kn ko l kp kq">0xcf479181<br/>0000000000000000000000000000000000000000000000000000000000000000<br/>0000000000000000000000000000000000000000000000000000000000000064</span></pre><p id="76e1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">第一行是错误签名。与函数签名一样，错误签名是指示错误的字符串的Keccak-256哈希的前4个字节。在这种情况下，字符串<code class="eh jz ka kb kc b">InsufficientBalance(uint256,uint256)</code>。这可以使用在线加密工具进行验证，如下图所示。</p><figure class="kd ke kf kg fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mb"><img src="../Images/1d036b0f591a15a387fbc9f677bab2e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jDweWHXCQxTRe2US61IoXg.png"/></div></div><figcaption class="kt ku fg fe ff kv kw bd b be z ek">Calculating the hash of the error function.</figcaption></figure><p id="183c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在函数签名之后，我们有两个类型为<em class="kr"> uint256 </em>的十六进制参数:0作为第一个参数，64作为第二个参数，它对应于十进制的100。使用自定义错误的优点之一是能够在客户端反序列化参数。</p><p id="957c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">自定义错误只有一个属性，<em class="kr">选择器</em>，它返回4个字节的错误签名。</p><h1 id="f0a7" class="kx km ht bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt dt translated">维护</h1><p id="b770" class="pw-post-body-paragraph jb jc ht jd b je lu jg jh ji lv jk jl jm lw jo jp jq lx js jt ju ly jw jx jy hm dt translated">检查坚固性条件的第二种方法是使用<code class="eh jz ka kb kc b">assert</code>功能。它的用法类似于<code class="eh jz ka kb kc b">require</code>，但它主要用于确保一个应该为真的条件实际上为真。</p><p id="c506" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">换句话说，<code class="eh jz ka kb kc b">require</code>用于检查一个条件，该条件可能为真，也可能不为真，这取决于例如函数的参数。<code class="eh jz ka kb kc b">Assert</code>用于确保合同逻辑中没有任何错误，如果<code class="eh jz ka kb kc b">assert</code>发现一个真条件，这表明合同中可能存在必须修复的bug。</p><p id="87e4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当<code class="eh jz ka kb kc b">revert</code>发送类型为<em class="kr">错误(字符串)</em>的错误时，<code class="eh jz ka kb kc b">assert</code>发送类型为<em class="kr"> Panic(uint256) </em>的错误。与<code class="eh jz ka kb kc b">require,</code>不同的是<code class="eh jz ka kb kc b">assert</code>无法接收指示错误原因的文本。</p><p id="7eca" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在一些书或者旧的文章中，你会发现<code class="eh jz ka kb kc b">assert</code>函数消耗了所有可用于事务的gas的信息。在编译器0.8.0版本之前都是如此，当时<code class="eh jz ka kb kc b">assert</code>函数使用了一个操作码而不是<em class="kr"> revert </em>。目前，两个函数使用相同的操作码，剩余的gas返回给发送器，供<code class="eh jz ka kb kc b">revert</code>和<code class="eh jz ka kb kc b">assert</code>使用。</p><h1 id="e65e" class="kx km ht bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt dt translated">尝试/抓住</h1><p id="961e" class="pw-post-body-paragraph jb jc ht jd b je lu jg jh ji lv jk jl jm lw jo jp jq lx js jt ju ly jw jx jy hm dt translated">在Solidity中使用<em class="kr"> try/catch </em>比在其他编程语言中更受限制。<em class="kr"> Try/catch </em>只在两种情况下使用:调用外部调用时和创建新契约时。</p><p id="ad9c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们用一个例子来演示它的用法。名为<code class="eh jz ka kb kc b">TryCatch</code>的合同将有两个功能:<code class="eh jz ka kb kc b">called</code>和<code class="eh jz ka kb kc b">caller</code>。<code class="eh jz ka kb kc b">called</code>函数将被<code class="eh jz ka kb kc b">caller</code>函数从外部调用，所以我们可以使用<em class="kr"> try/catch </em>。一般来说,<em class="kr"> try/catch </em>主要用于调用其他契约中的函数，但是我们希望这个例子简单一些。</p><pre class="kd ke kf kg fq kh kc ki kj aw kk dt"><span id="b096" class="kl km ht kc b fv kn ko l kp kq">pragma solidity ^0.8.7;</span><span id="9c74" class="kl km ht kc b fv mc ko l kp kq">contract TryCatch {</span><span id="95e8" class="kl km ht kc b fv mc ko l kp kq">function called(uint errorType) external pure returns(bool) {<br/>   if (errorType==0) {<br/>      return true;<br/>   } else if (errorType==1) {<br/>      revert("Error!");<br/>   } else if (errorType==2) {<br/>      assert(false);<br/>   } <br/>}</span><span id="1d9f" class="kl km ht kc b fv mc ko l kp kq">function caller(uint errorType) public view returns(string memory){<br/>   try this.called(errorType) {<br/>      return "Ok";<br/>   }<br/>   catch Error(string memory) {<br/>      return "Error!";<br/>   }<br/>   catch Panic(uint256) {<br/>      return "Panic!";<br/>   }<br/>}<br/>}</span></pre><p id="02ac" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当调用<code class="eh jz ka kb kc b">called</code>函数时，<code class="eh jz ka kb kc b">caller</code>函数传递一个类型为<em class="kr"> uint </em>的参数。如果参数是值<code class="eh jz ka kb kc b">0</code>，就不会有错误。如果参数值为1，<code class="eh jz ka kb kc b">called </code>执行<code class="eh jz ka kb kc b">revert</code>语句，错误被第一个<code class="eh jz ka kb kc b">catch</code>捕获，其类型为<code class="eh jz ka kb kc b">Error</code>。如果参数是值<code class="eh jz ka kb kc b">2</code>，则<code class="eh jz ka kb kc b">called</code>执行条件为假的<code class="eh jz ka kb kc b">assert</code>。这种错误被类型<code class="eh jz ka kb kc b">Panic</code>的最后一个<code class="eh jz ka kb kc b">catch</code>捕获。</p><p id="c734" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果您对错误的类型不感兴趣，您可以使用<code class="eh jz ka kb kc b">catch {…}</code>，或者，如果您想要对错误进行ABI编码，您可以使用<code class="eh jz ka kb kc b">catch (bytes memory data)</code>。</p><p id="5e16" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">要查看最后一个功能，请将<code class="eh jz ka kb kc b">caller</code>函数更改为以下代码。</p><pre class="kd ke kf kg fq kh kc ki kj aw kk dt"><span id="5314" class="kl km ht kc b fv kn ko l kp kq">function caller(uint errorType) public view returns(bytes memory) {<br/>   try this.called(errorType) {}<br/>   catch (bytes memory data) {<br/>      return data;<br/>   }<br/>}</span></pre><p id="2a22" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当将值<code class="eh jz ka kb kc b">2</code>作为参数传递时，<code class="eh jz ka kb kc b">assert(false)</code>将被执行，这将抛出类型为<em class="kr"> Panic </em>的错误。我们可以在下图中看到这一点。字符串<code class="eh jz ka kb kc b">Panic(uint256)</code>的Keccak-256 hash的前4个字节是<code class="eh jz ka kb kc b">4e487b71</code>，与返回错误的签名相同。</p><figure class="kd ke kf kg fq iu fe ff paragraph-image"><div class="fe ff md"><img src="../Images/01d33c1629a1fde1aaaa95364dd58bbd.png" data-original-src="https://miro.medium.com/v2/resize:fit:926/format:webp/1*5ihtP0RSC0gapC0n8SjCxQ.png"/></div><figcaption class="kt ku fg fe ff kv kw bd b be z ek">The error signature indicates that it is of type Panic.</figcaption></figure><p id="88a9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在错误签名之后，是一个ABI编码的32字节数字。这个数字表示错误的原因；上例中，对于<code class="eh jz ka kb kc b">1</code>的值，表示<code class="eh jz ka kb kc b">assert</code>内部的表达式返回false。还有其他可能会产生恐慌类型的错误，比如被零除或者试图在空数组上使用<code class="eh jz ka kb kc b">.pop()</code>方法。每个错误都有自己的数字代码。</p><p id="d40f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">可以在<a class="ae me" href="https://docs.soliditylang.org/en/v0.8.15/control-structures.html\#panic-via-assert-and-error-via-require" rel="noopener ugc nofollow" target="_blank">https://docs . solidi tylang . org/en/v 0 . 8 . 15/control-structures . html \ # Panic-via-assert-and-error-via-require</a>中找到能够生成紧急类型错误的所有错误的完整列表以及错误代码。</p><p id="4377" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">感谢阅读！</strong></p><p id="8925" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎对本文提出意见和建议。</p><p id="de72" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎任何投稿。<a class="ae me" href="http://www.buymeacoffee.com/jpmorais" rel="noopener ugc nofollow" target="_blank">www.buymeacoffee.com/jpmorais</a>。</p><blockquote class="mf"><p id="542f" class="mg mh ht bd mi mj mk ml mm mn mo jy ek translated">交易新手？尝试<a class="ae me" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae me" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>