<html>
<head>
<title>Implementing Nested Arrays in Solidity Smart Contracts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Solidity智能合约中实现嵌套数组</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/implementing-nested-arrays-in-solidity-smart-contracts-514e05d251b8?source=collection_archive---------3-----------------------#2022-10-16">https://medium.com/coinmonks/implementing-nested-arrays-in-solidity-smart-contracts-514e05d251b8?source=collection_archive---------3-----------------------#2022-10-16</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="c48a" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">充分发挥结构、数组和映射的潜力</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/fbe5265e9641d2a50aceb7bb49730b4c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-20CSPIoTl4MMv515DpRUg.png"/></div></div></figure><h2 id="9df2" class="ju jv ht bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">介绍</h2><p id="9302" class="pw-post-body-paragraph ks kt ht ku b kv kw iu kx ky kz ix la kf lb lc ld kj le lf lg kn lh li lj lk hm dt translated">数组是面向对象编程中最流行的数据类型之一。根据定义，数组是一种在自身内部存储其他数据类型的多个变量的数据类型。在典型的面向对象编程中，数组非常强大，因为它们还可以将数组存储到几乎无限的级别。数组中的数组称为嵌套数组，是现实生活中数据的绝佳表示。</p><p id="6373" class="pw-post-body-paragraph ks kt ht ku b kv ll iu kx ky lm ix la kf ln lc ld kj lo lf lg kn lp li lj lk hm dt translated">然而，Solidity并不是真正的面向对象语言(它是<em class="lq"> contract </em>面向的),它的数组定义不同。首先，solidity中的数组只能接受单一的预定义数据类型的变量。因此，uint数组只能接受uint值，string数组只能接受string变量，等等。而实数组肯定不能在自身内部容纳其他数组。嵌套数组是不可能的。作为一个从Java、Python或JavaScript过渡到Solidity的程序员，一个迫在眉睫的问题是，我们究竟如何实现包含数组的数组来构建结构良好的链上元数据？答案很简单。我们结合了两种独特的数据类型，称为映射和数组结构。</p><h2 id="224f" class="ju jv ht bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">什么是结构？</h2><p id="50bd" class="pw-post-body-paragraph ks kt ht ku b kv kw iu kx ky kz ix la kf lb lc ld kj le lf lg kn lh li lj lk hm dt translated">结构是用于定义记录的实体数据类型。换句话说，结构包含特定数量的变量，所有变量都是预先声明的数据类型。结构的声明如下所示:</p><pre class="jj jk jl jm fq lr ls lt lu aw lv dt"><span id="dbca" class="ju jv ht ls b fv lw lx l ly lz">struct People {<br/>    string name;<br/>    uint height_in_cm;<br/>    bytes gender;<br/>}<br/>People memory yours_truly = People("Peter Ogwara", 155, "m");<br/></span></pre><p id="e5bd" class="pw-post-body-paragraph ks kt ht ku b kv ll iu kx ky lm ix la kf ln lc ld kj lo lf lg kn lp li lj lk hm dt translated">因此，struct声明仅仅给出了一个可以创建它的实例的模型，比如上面的yours_tuly。</p><h2 id="b536" class="ju jv ht bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">什么是映射？</h2><p id="b8d4" class="pw-post-body-paragraph ks kt ht ku b kv kw iu kx ky kz ix la kf lb lc ld kj le lf lg kn lh li lj lk hm dt translated">映射是一种数据类型，它使一种数据类型的实例能够与另一种数据类型相匹配。例如，代表唯一用户id的uint可以与代表年龄的uint的地址或代表姓名的字符串配对。ERC令牌使用该数据类型来记录每个地址的令牌余额。映射的声明和设置如下:</p><pre class="jj jk jl jm fq lr ls lt lu aw lv dt"><span id="8c6f" class="ju jv ht ls b fv lw lx l ly lz">mapping(uint=&gt;string) user_id_to_username;<br/>uint id = 1;<br/>user_id_to_username[id] = "peterogwara";</span></pre><p id="895c" class="pw-post-body-paragraph ks kt ht ku b kv ll iu kx ky lm ix la kf ln lc ld kj lo lf lg kn lp li lj lk hm dt translated">要调用映射中的信息，只需要第一个变量的值。例如，要使用上面的映射来获取id为1的用户的用户名，我们需要执行以下操作。</p><pre class="jj jk jl jm fq lr ls lt lu aw lv dt"><span id="08a2" class="ju jv ht ls b fv lw lx l ly lz">uint id = 1;<br/>username = user_id_to_username[id] //This will return "peterogwara"</span></pre><h2 id="8bd2" class="ju jv ht bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">用结构组合数组和映射</h2><p id="d5df" class="pw-post-body-paragraph ks kt ht ku b kv kw iu kx ky kz ix la kf lb lc ld kj le lf lg kn lh li lj lk hm dt translated">有趣的部分来了。结构和映射可以组合！要创建一个一级嵌套数组，我们可以创建任何原始数据类型到结构的映射。继续上面定义的人员结构和惟一id的概念，下面是一个例子:</p><pre class="jj jk jl jm fq lr ls lt lu aw lv dt"><span id="be90" class="ju jv ht ls b fv lw lx l ly lz">mapping(uint=&gt;People) user_id_to_details;</span></pre><p id="9399" class="pw-post-body-paragraph ks kt ht ku b kv ll iu kx ky lm ix la kf ln lc ld kj lo lf lg kn lp li lj lk hm dt translated">这个唯一的id可以用来调用比单个用户名更多的细节。当然，任何数量的变量都可以添加到这个结构中，使它在定义一个人时更加全面。请注意，映射包括结构的特定名称(People)，而不仅仅是“struct”。</p><h2 id="a064" class="ju jv ht bd jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr dt translated">深入到更多层次</h2><p id="f209" class="pw-post-body-paragraph ks kt ht ku b kv kw iu kx ky kz ix la kf lb lc ld kj le lf lg kn lh li lj lk hm dt translated">然而，假设我们想在他们的详细信息中包含每个人的技术堆栈列表和他们宠物猫的详细信息。我们必须再深入一层。这可以通过在people结构中为tech堆栈声明一个字符串数组来实现。不幸的是，我们不能在结构中包含结构，也不能在结构中包含嵌套映射。但是，我们可以为相同的目的构造单独的结构，并在原始结构中使用数组来跟踪它们，从而在People结构中创建CatDetails结构和CatDetails数组。我们的代码应该是这样的:</p><pre class="jj jk jl jm fq lr ls lt lu aw lv dt"><span id="3a48" class="ju jv ht ls b fv lw lx l ly lz">uint userCount;<br/>string[] _techstack;<br/>CatDetails[] _cats;</span><span id="b797" class="ju jv ht ls b fv ma lx l ly lz">struct People {<br/>    string name;<br/>    uint height;<br/>    bytes gender;<br/>    string[] tech_stack;<br/>    CatDetails[] cats;<br/>}<br/>struct CatDetails {<br/>    string name;<br/>    uint age;<br/>    string color;<br/>}<br/>mapping (uint=&gt;People) user_id_to_details;</span></pre><p id="ed9c" class="pw-post-body-paragraph ks kt ht ku b kv ll iu kx ky lm ix la kf ln lc ld kj lo lf lg kn lp li lj lk hm dt translated">然后，通过首先声明最内部的数组并设置其值，然后对最外层的结构进行同样的操作，可以设置变量值。契约开始时声明的全局数组为函数内声明提供了一个指向的存储位置。</p><pre class="jj jk jl jm fq lr ls lt lu aw lv dt"><span id="e1e3" class="ju jv ht ls b fv lw lx l ly lz">function setUser() public {<br/>    uint userId = userCount++;<br/>    string[] storage my_techstack = _techstack;<br/>    my_techstack.push("Python");<br/>    my_techstack.push("JavaScript");<br/>    my_techstack.push("Solidity");<br/>    CatDetails[] storage cats = _cats;<br/>    CatDetails memory firstcat = CatDetails("Snuffles", 3, 'white');<br/>    cats.push(firstcat);<br/>        CatDetails memory secondcat = CatDetails("Garfield", 5, 'orange');<br/>    cats.push(secondcat);<br/>People memory yours_truly = People("Peter M. Ogwara", 155, "m", my_techstack, cats);<br/>    user_id_to_details[userId] = yours_truly;<br/>}</span></pre><p id="2c64" class="pw-post-body-paragraph ks kt ht ku b kv ll iu kx ky lm ix la kf ln lc ld kj lo lf lg kn lp li lj lk hm dt translated">就这样，我们有了嵌套的数组/结构！调用数据非常简单，并且以传统的映射/结构/数组调用格式完成。例如，下面的行将返回用户#1的第二只猫的名字。</p><pre class="jj jk jl jm fq lr ls lt lu aw lv dt"><span id="1b08" class="ju jv ht ls b fv lw lx l ly lz">return user_id_to_details[1].my_cats[1].name;</span></pre><p id="4484" class="pw-post-body-paragraph ks kt ht ku b kv ll iu kx ky lm ix la kf ln lc ld kj lo lf lg kn lp li lj lk hm dt translated">最后，在调用值之前，确保包含检查以确保索引存在。</p></div><div class="ab cl mb mc hb md" role="separator"><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg mh"/><span class="me bw bk mf mg"/></div><div class="hm hn ho hp hq"><p id="0201" class="pw-post-body-paragraph ks kt ht ku b kv ll iu kx ky lm ix la kf ln lc ld kj lo lf lg kn lp li lj lk hm dt translated"><strong class="ku hu">🌟欢迎提问！🌟</strong></p><p id="2b75" class="pw-post-body-paragraph ks kt ht ku b kv ll iu kx ky lm ix la kf ln lc ld kj lo lf lg kn lp li lj lk hm dt translated"><em class="lq">关注我了解更多区块链、Javascript、PHP、Python或纯编程故事。</em></p><p id="51a0" class="pw-post-body-paragraph ks kt ht ku b kv ll iu kx ky lm ix la kf ln lc ld kj lo lf lg kn lp li lj lk hm dt translated"><a class="ae mi" rel="noopener" href="/@peterogwara">中</a> | <a class="ae mi" href="https://twitter.com/petermarie_" rel="noopener ugc nofollow" target="_blank">推特</a> | <a class="ae mi" href="https://github.com/PeterMarie" rel="noopener ugc nofollow" target="_blank"> Github </a> | <a class="ae mi" href="https://www.amazon.com/author/peterogwara" rel="noopener ugc nofollow" target="_blank">亚马逊</a></p><blockquote class="mj"><p id="ddfe" class="mk ml ht bd mm mn mo mp mq mr ms lk ek translated">交易新手？尝试<a class="ae mi" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae mi" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>