<html>
<head>
<title>Storing a large amount of arbitrary data on Ethereum efficiently</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在以太坊上高效存储大量任意数据</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/kind-of-storing-a-large-amount-of-arbitrary-data-on-ethereum-efficiently-1504335f2cd2?source=collection_archive---------28-----------------------#2022-12-20">https://medium.com/coinmonks/kind-of-storing-a-large-amount-of-arbitrary-data-on-ethereum-efficiently-1504335f2cd2?source=collection_archive---------28-----------------------#2022-12-20</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><figure class="hs ht fm fo hu hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff hr"><img src="../Images/9fc3e8d6ce4c2a3d176970b19479c2da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*8avRK26cwh4mC58K.png"/></div></div></figure><div class=""/><p id="d4ef" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">Gas一直是智能合约开发中的一个大话题。存储在区块链上的每一点数据都要耗费汽油。除非必要，否则我们不喜欢在链上存储数据。有些情况下，我们需要存储大量数据。例如，我们需要将白名单地址存储在链上，用于白名单NFT创建。<br/> LooksRare采用merkle树方法将这些数据“存储”在链上。数据实际上并没有上传到外链，但是我们上传了证明来验证用户提交的数据是否有效。</p><pre class="jz ka kb kc fq kd ke kf bn kg kh bi"><span id="236f" class="ki kj ie ke b be kk kl l km kn">    /**<br/>     * @notice Check whether it is possible to claim and how much based on previous distribution<br/>     * @param user address of the user<br/>     * @param treeId id of the merkle tree<br/>     * @param amount amount to claim<br/>     * @param merkleProof array with the merkle proof<br/>     */<br/>    function _canClaim(<br/>        address user,<br/>        uint8 treeId,<br/>        uint256 amount,<br/>        bytes32[] calldata merkleProof<br/>    ) internal view returns (bool, uint256) {<br/>        // Compute the node and verify the merkle proof<br/>        bytes32 node = keccak256(abi.encodePacked(user, amount));<br/>        bool canUserClaim = MerkleProof.verify(merkleProof, treeParameters[treeId].merkleRoot, node);<br/><br/>        if (!canUserClaim) {<br/>            return (false, 0);<br/>        } else {<br/>            uint256 adjustedAmount = amount - amountClaimedByUserPerTreeId[user][treeId];<br/>            return (true, adjustedAmount);<br/>        }s</span></pre><div class="hs ht fm fo hu ko"><a href="https://github.com/LooksRare/contracts-token-staking/blob/bc99c5c84137aa9b359780aa2967a5c319772ed6/contracts/MultiRewardsDistributor.sol#L233" rel="noopener  ugc nofollow" target="_blank"><div class="kp ab ej"><div class="kq ab kr cl cj ks"><h2 class="bd if fv z el kt eo ep ku er et id dt translated">位于BC 99 C5 c 84137 aa9b 359780 aa 2967 a5c 319772 ed 6的contracts-token-staking/multi rewards distributor . sol…</h2><div class="kv l"><h3 class="bd b fv z el kt eo ep ku er et ek translated">LOOKS are(LOOKS)token和staking contracts。通过创建……为looks rare/contracts-token-staking开发做出贡献</h3></div><div class="kw l"><p class="bd b gc z el kt eo ep ku er et ek translated">github.com</p></div></div><div class="kx l"><div class="ky l kz la lb kx lc ia ko"/></div></div></a></div><p id="2336" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">为了验证用户是否是白名单中的用户，只需要在chain上存储一个名为<code class="eh ld le lf ke b">merkleRoot</code>的变量。</p><p id="6f78" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当用户提出索赔时，他们需要提供merkle证明，以及要索赔的分配金额和用户的地址。然后，契约将验证上述内容的散列是否与merkle根匹配。如果它们匹配，则证明该用户是具有正确分配量的白名单用户。</p><p id="2072" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们深入了解一下它是如何工作的…</p></div><div class="ab cl lg lh hb li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hm hn ho hp hq"><h1 id="59fc" class="ln kj ie bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj dt translated">生成merkle根</h1><p id="8b33" class="pw-post-body-paragraph jb jc ie jd b je mk jg jh ji ml jk jl jm mm jo jp jq mn js jt ju mo jw jx jy hm dt translated">为了简单起见，我们现在忽略分配的数量。merkle根是通过递归散列前导节点(在这种情况下是地址的keccak)来计算的。在获得merkle根之后。我们将它存储在智能合约中。这比存储所有的叶子节点消耗的汽油要少得多。</p><figure class="jz ka kb kc fq hv fe ff paragraph-image"><div class="fe ff mp"><img src="../Images/c53552612e0ca692b8c47d15a7124b5a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1350/0*iKq2SP8YCOctrfb-"/></div><figcaption class="mq mr fg fe ff ms mt bd b be z ek">Creating root hash by hashing leaf nodes recursively</figcaption></figure><h1 id="020e" class="ln kj ie bd lo lp mu lr ls lt mv lv lw lx mw lz ma mb mx md me mf my mh mi mj dt translated">验证用户提供的merkle校样</h1><p id="8306" class="pw-post-body-paragraph jb jc ie jd b je mk jg jh ji ml jk jl jm mm jo jp jq mn js jt ju mo jw jx jy hm dt translated">这就是复杂性所在。用户必须提交由服务提供商离线生成的merkle证明。合同将散列用户的地址和merkle证明，看它是否能获得相同的merkle根。因为很难用自定义输入生成merkle校样。如果结果匹配，就可以肯定地说输入是有效的。</p><figure class="jz ka kb kc fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff mz"><img src="../Images/24b40fcbf7efb6b5c4ee4b539cc14cf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wll14lUC4vancBTT"/></div></div><figcaption class="mq mr fg fe ff ms mt bd b be z ek">Verifying an address with the corresponding merkle proof</figcaption></figure><h1 id="2f44" class="ln kj ie bd lo lp mu lr ls lt mv lv lw lx mw lz ma mb mx md me mf my mh mi mj dt translated">更进一步—还存储分配的数量</h1><p id="8b3a" class="pw-post-body-paragraph jb jc ie jd b je mk jg jh ji ml jk jl jm mm jo jp jq mn js jt ju mo jw jx jy hm dt translated">我们可以做得更多，而不是将用户地址作为叶节点。例如，在叶节点中存储用户地址和分配量的散列。这样，我们可以在同一个节点中存储地址和数量，但仍然只生成一个merkle根。</p><p id="de48" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">用户还需要提交一件事——分配的金额。该合同将首先使用相应的金额散列用户的地址，然后沿着merkle证明散列以检查merkle根。</p><figure class="jz ka kb kc fq hv fe ff paragraph-image"><div role="button" tabindex="0" class="hw hx di hy bf hz"><div class="fe ff na"><img src="../Images/9d5e1594a1f916757e8f2c5045fbc777.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RhO8VI7utxmdGpbC"/></div></div><figcaption class="mq mr fg fe ff ms mt bd b be z ek">Verifying address and allocated amount with the corresponding merkle proof</figcaption></figure></div><div class="ab cl lg lh hb li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hm hn ho hp hq"><p id="c0b6" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">理论上，我们可以存储任何可以散列并适合叶节点的东西。</p><p id="fb84" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">可能的使用案例:</p><ul class=""><li id="b487" class="nb nc ie jd b je jf ji jj jm nd jq ne ju nf jy ng nh ni nj dt translated">通过散列语句存储预测，并将其放入叶节点</li><li id="0327" class="nb nc ie jd b je nk ji nl jm nm jq nn ju no jy ng nh ni nj dt translated">存储更复杂的数据结构，如{地址，数量，时间，标准1，标准2，…}</li></ul></div><div class="ab cl lg lh hb li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hm hn ho hp hq"><p id="3731" class="pw-post-body-paragraph jb jc ie jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">好看的工具:<br/> Solidity实用工具:<a class="ae np" href="https://docs.openzeppelin.com/contracts/3.x/api/cryptography#MerkleProof" rel="noopener ugc nofollow" target="_blank">https://docs . open zeppelin . com/contracts/3 . x/API/cryptography # merkle proof</a>T3】Javascript库:【https://github.com/OpenZeppelin/merkle-treeT6】Python库:<a class="ae np" href="https://github.com/Tierion/pymerkletools" rel="noopener ugc nofollow" target="_blank">https://github.com/Tierion/pymerkletools</a>T9】Go libray:<a class="ae np" href="https://github.com/txaty/go-merkletree" rel="noopener ugc nofollow" target="_blank">https://github.com/txaty/go-merkletree</a></p><blockquote class="nq"><p id="6869" class="nr ns ie bd nt nu nv nw nx ny nz jy ek translated">交易新手？尝试<a class="ae np" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae np" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p><p id="8735" class="nr ns ie bd nt nu nv nw nx ny nz jy ek translated">多样化的密码持有，了解币安的选择</p><p id="debb" class="nr ns ie bd nt nu nv nw nx ny nz jy ek translated">加入Coinmonks <a class="ae np" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae np" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>获取每日<a class="ae np" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank">加密新闻</a></p></blockquote><h2 id="15d6" class="oa kj ie bd lo ob oc od ls oe of og lw jm oh oi ma jq oj ok me ju ol om mi on dt translated">另外，阅读</h2><ul class=""><li id="20fb" class="nb nc ie jd b je mk ji ml jm oo jq op ju oq jy ng nh ni nj dt translated"><a class="ae np" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a> | <a class="ae np" rel="noopener" href="/coinmonks/crypto-tax-software-ed4b4810e338">加密税务软件</a></li><li id="723e" class="nb nc ie jd b je nk ji nl jm nm jq nn ju no jy ng nh ni nj dt translated"><a class="ae np" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">网格交易</a> | <a class="ae np" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">加密硬件钱包</a></li><li id="874f" class="nb nc ie jd b je nk ji nl jm nm jq nn ju no jy ng nh ni nj dt translated"><a class="ae np" rel="noopener" href="/coinmonks/top-3-telegram-channels-for-crypto-traders-in-2021-8385f4411ff4">密码电报信号</a> | <a class="ae np" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="f33b" class="nb nc ie jd b je nk ji nl jm nm jq nn ju no jy ng nh ni nj dt translated"><a class="ae np" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a> | <a class="ae np" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度最佳加密交易所</a></li><li id="47a8" class="nb nc ie jd b je nk ji nl jm nm jq nn ju no jy ng nh ni nj dt translated"><a class="ae np" rel="noopener" href="/coinmonks/best-crypto-apis-for-developers-5efe3a597a9f">开发人员的最佳加密API</a></li><li id="b359" class="nb nc ie jd b je nk ji nl jm nm jq nn ju no jy ng nh ni nj dt translated">最佳<a class="ae np" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">密码借贷平台</a></li><li id="3c98" class="nb nc ie jd b je nk ji nl jm nm jq nn ju no jy ng nh ni nj dt translated"><a class="ae np" rel="noopener" href="/coinmonks/free-crypto-signals-48b25e61a8da">免费加密信号</a> | <a class="ae np" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a></li><li id="9487" class="nb nc ie jd b je nk ji nl jm nm jq nn ju no jy ng nh ni nj dt translated"><a class="ae np" rel="noopener" href="/coinmonks/leveraged-token-3f5257808b22">杠杆代币的终极指南</a></li></ul></div></div>    
</body>
</html>