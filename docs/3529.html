<html>
<head>
<title>How to create a Beacon Proxy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何创建信标代理</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/how-to-create-a-beacon-proxy-3d55335f7353?source=collection_archive---------1-----------------------#2022-09-12">https://medium.com/coinmonks/how-to-create-a-beacon-proxy-3d55335f7353?source=collection_archive---------1-----------------------#2022-09-12</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="5672" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Beacon proxy是一种代理模式，其中多个代理引用单个智能协定，以便为它们提供实现协定的地址。为代理提供实现契约地址的契约称为信标契约。</p><p id="f3dd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">关于什么是代理以及为什么应该使用它的更详细的解释，请查看这篇更早的文章。</p><p id="4a7d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当您有多个代理引用一个随我们的进展而升级的实现契约时，就使用信标代理。如果您要使用<a class="ae jo" rel="noopener" href="/@HashHaran/how-to-create-a-transparent-proxy-1683d21468bf">透明代理</a>或<a class="ae jo" rel="noopener" href="/@HashHaran/how-to-create-an-uups-proxy-66eca257b2f9"> UUPS代理</a>，您将不得不一个接一个地升级所有代理中的实现契约地址。如果您的项目需要多个代理来引用同一个实现，那么beacon代理是一个不错的选择。</p><p id="b90b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当我们试图升级使用信标模式部署的智能契约时，我们调用信标契约并升级存储在那里的实现契约地址。只有所有者地址能够进行这种升级，默认情况下，这是部署信标的地址。一旦该信标被更新，引用该信标的所有代理将开始引用新的契约，并且代理将被立即升级到新的实现。</p><p id="a2d4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们开始使用UUPS代理模式部署一个智能契约。</p><h1 id="f236" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">项目设置</h1><p id="9be2" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">我们将使用<a class="ae jo" href="https://hardhat.org/" rel="noopener ugc nofollow" target="_blank">安全帽</a>用于我们的以太坊开发工作流程。在本演练中，我在windows机器上使用WSL2。如果使用不同的设置，您可以稍微调整这些步骤。我们开始吧！</p><p id="361f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">运行以下命令创建一个目录，并将其初始化为节点项目。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="e486" class="lb jq ht kx b fv lc ld l le lf"><strong class="kx hu">mkdir hardhat-upgrades &amp;&amp; cd hardhat-upgradesnpm init -y</strong></span></pre><p id="d98b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这个目录中安装hardhat。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="41e1" class="lb jq ht kx b fv lc ld l le lf"><strong class="kx hu">npm i --save-dev hardhat</strong></span></pre><p id="d65e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在目录中初始化一个hardhat类型的脚本项目。运行下面的命令并选择“<em class="lg">创建一个TypeScript项目”</em>选项。对于其余的提示，请使用默认参数。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="3cdd" class="lb jq ht kx b fv lc ld l le lf"><strong class="kx hu">npx hardhat</strong></span></pre><p id="68da" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">安装开放的zeppelin hardhat升级插件，我们将使用它来轻松部署我们的代理。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="b3f1" class="lb jq ht kx b fv lc ld l le lf"><strong class="kx hu">npm i --save-dev @openzeppelin/hardhat-upgrades</strong></span></pre><p id="3400" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">还要安装来自Open zeppelin的可升级合同，它是Open zeppelin合同的可升级对应物。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="162c" class="lb jq ht kx b fv lc ld l le lf"><strong class="kx hu">npm i --save-dev @openzeppelin/contracts-upgradeable</strong></span></pre><p id="e5dd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">将以下内容复制并粘贴到hardhat.config.ts文件中。这将做这个项目所需的基本安全帽设置。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="f501" class="lb jq ht kx b fv lc ld l le lf">import { HardhatUserConfig } from "hardhat/config";<br/>import "@nomicfoundation/hardhat-toolbox";<br/>import "@openzeppelin/hardhat-upgrades";<br/>import "@typechain/hardhat";</span><span id="308c" class="lb jq ht kx b fv lh ld l le lf">const config: HardhatUserConfig = {<br/>solidity: {<br/>version: "0.8.9",<br/>settings: {<br/>optimizer: {<br/>enabled: true,<br/>runs: 200,<br/>},<br/>},<br/>},<br/>defaultNetwork: "localhost",<br/>};</span><span id="248a" class="lb jq ht kx b fv lh ld l le lf">export default config;</span></pre><h1 id="7f4f" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">部署信标代理的实施合同</h1><p id="e1cd" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">在contracts文件夹中，为我们将要部署信标代理的实现契约创建一个文件夹。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="9f31" class="lb jq ht kx b fv lc ld l le lf"><strong class="kx hu">mkdir contracts/beacon</strong></span></pre><p id="c133" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在<em class="lg"> contracts </em>目录下创建一个名为<em class="lg"> VersionAware.sol </em>的文件，并将以下代码复制粘贴到其中。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="6149" class="lb jq ht kx b fv lc ld l le lf"><em class="lg">// SPDX-License-Identifier: Unlicense<br/></em>pragma solidity ^0.8.0;</span><span id="0246" class="lb jq ht kx b fv lh ld l le lf">abstract contract VersionAware {</span><span id="ec8c" class="lb jq ht kx b fv lh ld l le lf">string public versionAwareContractName;</span><span id="6741" class="lb jq ht kx b fv lh ld l le lf">function getContractNameWithVersion() external pure virtual<br/>returns (string memory);<br/>}</span></pre><p id="49a0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这里，我们创建了实现契约的基本框架，以便在部署和升级之后，我们可以轻松地看到版本升级。</p><p id="d099" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在<em class="lg"> contracts/beacon </em>目录下创建两个名为<em class="lg"> BeaconProxyPatternV1.sol </em>和<em class="lg"> BeaconProxyPatternV2.sol </em>的文件，并将下面的代码复制粘贴到其中。</p><p id="2a78" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="lg"> BeaconProxyPatternV1.sol </em></p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="47b4" class="lb jq ht kx b fv lc ld l le lf"><em class="lg">// SPDX-License-Identifier: Unlicense</em></span><span id="b3a3" class="lb jq ht kx b fv lh ld l le lf">pragma solidity ^0.8.0;</span><span id="0653" class="lb jq ht kx b fv lh ld l le lf">import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";</span><span id="9d58" class="lb jq ht kx b fv lh ld l le lf">import {VersionAware} from "../VersionAware.sol";</span><span id="49b9" class="lb jq ht kx b fv lh ld l le lf">contract BeaconProxyPatternV1 is Initializable, VersionAware {</span><span id="6ebb" class="lb jq ht kx b fv lh ld l le lf">constructor() {<br/>_disableInitializers();<br/>}</span><span id="1266" class="lb jq ht kx b fv lh ld l le lf">function initialize() external initializer {<br/>versionAwareContractName = "Beacon Proxy Pattern: V1";<br/>}</span><span id="2534" class="lb jq ht kx b fv lh ld l le lf">function getContractNameWithVersion() public pure override returns (string memory){<br/>return "Beacon Proxy Pattern: V1";<br/>}<br/>}</span></pre><p id="5508" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="lg"> BeaconProxyPatternV2.sol </em></p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="1cc0" class="lb jq ht kx b fv lc ld l le lf"><em class="lg">// SPDX-License-Identifier: Unlicense<br/></em>pragma solidity ^0.8.0;</span><span id="9d1e" class="lb jq ht kx b fv lh ld l le lf">import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";</span><span id="f802" class="lb jq ht kx b fv lh ld l le lf">import {VersionAware} from "../VersionAware.sol";</span><span id="d527" class="lb jq ht kx b fv lh ld l le lf">contract BeaconProxyPatternV2 is Initializable, VersionAware {</span><span id="f375" class="lb jq ht kx b fv lh ld l le lf">constructor() {<br/>_disableInitializers();<br/>}</span><span id="f099" class="lb jq ht kx b fv lh ld l le lf">function initialize() external initializer {<br/>versionAwareContractName = "Beacon Proxy Pattern: V2";<br/>}</span><span id="1d0a" class="lb jq ht kx b fv lh ld l le lf">function getContractNameWithVersion() public pure override returns (string memory){<br/>return "Beacon Proxy Pattern: V2";<br/>}<br/>}</span></pre><p id="7c07" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们的两个契约都是简单的可初始化契约，我们现在将使用beacon代理模式来部署它们。</p><p id="e2e9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这里，我试图解释上述合同的一些高级细节。如果你在第一次阅读时理解有困难，考虑现在跳过它，以后再回来。典型的可升级协定不应该有构造函数，因为实现协定的构造函数永远不能在代理协定的上下文中运行。我们在这里添加了一个安全的构造函数，因为它没有设置任何存储变量。不初始化就退出协定会造成安全威胁。在构造函数中调用<em class="lg">_ disable initializer</em>方法使得实现契约不可初始化，这比让实现没有构造函数也不初始化要安全得多。注意，我在V1的<em class="lg">初始化</em>方法中使用了<em class="lg">初始化器</em>修饰符。这个修饰符确保这个initialize方法只被调用一次，就像solidity确保构造函数一样。还要注意，在V2中，<em class="lg">初始化</em>方法的修饰符是<em class="lg">重新初始化器(2)。</em>这里2代表实现契约的版本。必须使用<em class="lg">重新初始化器</em>修改器，而不是<em class="lg">初始化器</em>，因为代理契约已经在V1初始化过一次。关于所有可升级智能契约都应该继承的Initializer.sol契约，还有更多事情和细节需要了解。我将在以后写更多关于它的详细文章。</p><p id="8828" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，运行以下命令来编译智能合约。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="5ab2" class="lb jq ht kx b fv lc ld l le lf"><strong class="kx hu">npx hardhat compile</strong></span></pre><h1 id="d9bf" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">信标代理部署和升级</h1><p id="c709" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">首先，我们将使用Beacon代理部署版本1，然后将其升级到版本2。我们将使用一个安全帽脚本来做到这一点。在scripts文件夹中创建一个名为<em class="lg"> beacon.js </em>的脚本，并将下面的代码复制粘贴到其中。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="de66" class="lb jq ht kx b fv lc ld l le lf">const { ethers, upgrades } = require("hardhat");</span><span id="9d16" class="lb jq ht kx b fv lh ld l le lf">async function main() {</span><span id="8186" class="lb jq ht kx b fv lh ld l le lf">const BeaconProxyPatternV1 = await ethers.getContractFactory("BeaconProxyPatternV1");<br/>const beacon = await upgrades.deployBeacon(BeaconProxyPatternV1, {unsafeAllow: ['constructor']});<br/>await beacon.deployed();<br/>console.log(`Beacon with Beacon Proxy Pattern V1 as implementation is deployed to address: ${beacon.address}`);<br/>const beaconProxy1 = await upgrades.deployBeaconProxy(beacon.address, BeaconProxyPatternV1, []);</span><span id="4316" class="lb jq ht kx b fv lh ld l le lf">let versionAwareContractName = await beaconProxy1.getContractNameWithVersion();</span><span id="08e0" class="lb jq ht kx b fv lh ld l le lf">console.log(`Proxy Pattern and Version from Proxy 1 Implementation: ${versionAwareContractName}`);</span><span id="1d32" class="lb jq ht kx b fv lh ld l le lf">const beaconProxy2 = await upgrades.deployBeaconProxy(beacon.address, BeaconProxyPatternV1, []);</span><span id="c580" class="lb jq ht kx b fv lh ld l le lf">versionAwareContractName = await beaconProxy2.getContractNameWithVersion();</span><span id="dff7" class="lb jq ht kx b fv lh ld l le lf">console.log(`Proxy Pattern and Version from Proxy 2 Implementation: ${versionAwareContractName}`);</span><span id="d9a5" class="lb jq ht kx b fv lh ld l le lf">const BeaconProxyPatternV2 = await ethers.getContractFactory("BeaconProxyPatternV2");</span><span id="38a3" class="lb jq ht kx b fv lh ld l le lf">const upgradedBeacon = await upgrades.upgradeBeacon(beacon.address, BeaconProxyPatternV2, {unsafeAllow: ['constructor']});</span><span id="668d" class="lb jq ht kx b fv lh ld l le lf">console.log(`Beacon upgraded with Beacon Proxy Pattern V2 as implementation at address: ${upgradedBeacon.address}`);</span><span id="384c" class="lb jq ht kx b fv lh ld l le lf">versionAwareContractName = await beaconProxy1.getContractNameWithVersion();</span><span id="0967" class="lb jq ht kx b fv lh ld l le lf">console.log(`Proxy Pattern and Version from Proxy 1 Implementation: ${versionAwareContractName}`);</span><span id="2b5e" class="lb jq ht kx b fv lh ld l le lf">versionAwareContractName = await beaconProxy2.getContractNameWithVersion();</span><span id="a019" class="lb jq ht kx b fv lh ld l le lf">console.log(`Proxy Pattern and Version from Proxy 2 Implementation: ${versionAwareContractName}`);</span><span id="e1c1" class="lb jq ht kx b fv lh ld l le lf">versionAwareContractName = await beaconProxy1.versionAwareContractName();</span><span id="1947" class="lb jq ht kx b fv lh ld l le lf">console.log(`Proxy Pattern and Version from Proxy 1 Storage: ${versionAwareContractName}`);</span><span id="ce43" class="lb jq ht kx b fv lh ld l le lf">versionAwareContractName = await beaconProxy2.versionAwareContractName();</span><span id="28d8" class="lb jq ht kx b fv lh ld l le lf">console.log(`Proxy Pattern and Version from Proxy 2 Storage: ${versionAwareContractName}`);</span><span id="74e1" class="lb jq ht kx b fv lh ld l le lf">const initTx = await beaconProxy1.initialize();<br/>const receipt = await initTx.wait();</span><span id="1b43" class="lb jq ht kx b fv lh ld l le lf">versionAwareContractName = await beaconProxy1.versionAwareContractName();</span><span id="c2a0" class="lb jq ht kx b fv lh ld l le lf">console.log(`Proxy Pattern and Version from Proxy 1 Storage: ${versionAwareContractName}`);</span><span id="bd0c" class="lb jq ht kx b fv lh ld l le lf">versionAwareContractName = await beaconProxy2.versionAwareContractName();</span><span id="04e6" class="lb jq ht kx b fv lh ld l le lf">console.log(`Proxy Pattern and Version from Proxy 2 Storage: ${versionAwareContractName}`);<br/>}</span><span id="d11a" class="lb jq ht kx b fv lh ld l le lf"><em class="lg">// We recommend this pattern to be able to use async/await everywhere and properly handle errors.</em></span><span id="932f" class="lb jq ht kx b fv lh ld l le lf">main().catch((error) =&gt; {<br/>console.error(error);<br/>process.exitCode = 1;<br/>});</span></pre><p id="9daa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们首先使用<em class="lg"> deployBeacon </em>方法部署信标契约。然后，我们使用<em class="lg"> deployBeaconProxy </em>方法部署两个信标代理。两个代理引用同一个信标，该信标又引用实现契约。然后我们用<em class="lg">升级信标</em>方法升级信标契约。一旦版本1部署了代理，我们就在代理上调用<em class="lg">getContractNameWithVersion</em>函数。该方法将根据我们在契约的版本1中使该方法返回的内容返回一个字符串。升级结束后，我们再次调用<em class="lg">getContractNameWithVersion</em>函数来查看返回的字符串的变化。让我们运行脚本，看看结果。使用以下命令运行脚本。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="0aee" class="lb jq ht kx b fv lc ld l le lf"><strong class="kx hu">npx hardhat run scripts/beacon.js</strong></span></pre><p id="1d9a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">您应该会在控制台上看到以下内容。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="47ef" class="lb jq ht kx b fv lc ld l le lf">Warning: Potentially unsafe deployment of BeaconProxyPatternV1</span><span id="edfd" class="lb jq ht kx b fv lh ld l le lf">You are using the `unsafeAllow.constructor` flag.</span><span id="46b7" class="lb jq ht kx b fv lh ld l le lf">Beacon with Beacon Proxy Pattern V1 as implementation is deployed to address: 0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512<br/>Warning: A proxy admin was previously deployed on this network</span><span id="d329" class="lb jq ht kx b fv lh ld l le lf">This is not natively used with the current kind of proxy ('beacon').<br/>    Changes to the admin will have no effect on this new proxy.</span><span id="a23e" class="lb jq ht kx b fv lh ld l le lf">Proxy Pattern and Version from Proxy 1 Implementation: Beacon Proxy Pattern: V1<br/>Warning: A proxy admin was previously deployed on this network</span><span id="dcc3" class="lb jq ht kx b fv lh ld l le lf">This is not natively used with the current kind of proxy ('beacon').<br/>    Changes to the admin will have no effect on this new proxy.</span><span id="4dc4" class="lb jq ht kx b fv lh ld l le lf">Proxy Pattern and Version from Proxy 2 Implementation: Beacon Proxy Pattern: V1<br/>Warning: Potentially unsafe deployment of BeaconProxyPatternV2</span><span id="137a" class="lb jq ht kx b fv lh ld l le lf">You are using the `unsafeAllow.constructor` flag.</span><span id="b9e1" class="lb jq ht kx b fv lh ld l le lf">Beacon upgraded with Beacon Proxy Pattern V2 as implementation at address: 0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512<br/>Proxy Pattern and Version from Proxy 1 Implementation: Beacon Proxy Pattern: V2<br/>Proxy Pattern and Version from Proxy 2 Implementation: Beacon Proxy Pattern: V2<br/>Proxy Pattern and Version from Proxy 1 Storage: Beacon Proxy Pattern: V1<br/>Proxy Pattern and Version from Proxy 2 Storage: Beacon Proxy Pattern: V1<br/>Proxy Pattern and Version from Proxy 1 Storage: Beacon Proxy Pattern: V2<br/>Proxy Pattern and Version from Proxy 2 Storage: Beacon Proxy Pattern: V1</span></pre><p id="a0fb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">耶！我们一升级信标，两个代理中的实现就升级了。我们可以通过查看升级前后由<em class="lg">getContractNameWithVersion</em>函数返回的字符串来验证这一点。</p><p id="675e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我想让你们注意结果中的一些东西。请注意，即使在升级之后，存储中的<em class="lg">versionawarecractname</em>变量的值也没有改变。这是因为当我们升级实现时，我们只更改智能合约的代码，存储保持不变。这是可取的，因为将一个智能合同的存储迁移到另一个智能合同并不简单。代理契约的存储用于存储实现智能契约中声明的变量(如果您不清楚为什么会这样，请阅读本文<a class="ae jo" rel="noopener" href="/@HashHaran/essential-guide-to-smart-contract-upgradeability-a257dac36525">中的</a>部分，我将在那里解释这一点)。因此，即使在升级后,<em class="lg">versionawarecractname</em>存储变量的值仍然与版本1相同。在我们调用代理1上的<em class="lg"> initialize </em>方法后，我们可以在下一行中看到<em class="lg">versionawarecontraname</em>的值已经改变。正是在<em class="lg"> initialize </em>方法中，我们将该值设置为版本2的值。另外，请注意，在最后一行中，代理2中的<em class="lg">versionawarecractname</em>的值仍然与版本1中的值相同。这是因为我们只在代理1上调用了<em class="lg"> initialize </em>方法，而不是在代理2上。</p><p id="6a54" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">理解我们在上一节中演示的内容很重要。即使信标代理模式中的所有代理都引用实现协定地址的信标，并且仅升级信标就足以升级所有代理，也应该在每个代理协定上逐个调用后续版本的初始化器。否则，<em class="lg"> initialize </em>方法的效果在没有调用它的代理中看不到。(这是针对当前实现的Openzeppelin契约及其升级插件，它不是一个理想的开发者体验。我希望将来会出现一个更好的解决方案，所以我们不需要为此担心。)</p><p id="d83d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">感谢阅读。</p><h1 id="41c9" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">我是谁？</h1><p id="b581" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">我是一名全栈区块链开发者，对构建一个去中心化的、潜在的更具包容性的未来充满热情。有区块链发展的需求吗？</p><p id="3998" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">取得联系:📧hariharan @ aluminum . iitm . AC . in</p><p id="f6c3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><a class="ae jo" href="https://github.com/HashHaran" rel="noopener ugc nofollow" target="_blank"> Github </a></p><blockquote class="li"><p id="1218" class="lj lk ht bd ll lm ln lo lp lq lr jn ek translated">加入Coinmonks <a class="ae jo" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae jo" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>了解加密交易和投资</p></blockquote><h1 id="0db7" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka ls kc kd ke lt kg kh ki lu kk kl km dt translated">另外，阅读</h1><ul class=""><li id="ed8d" class="lv lw ht is b it kn ix ko jb lx jf ly jj lz jn ma mb mc md dt translated"><a class="ae jo" href="https://coincodecap.com/fold-app-review" rel="noopener ugc nofollow" target="_blank">折叠App回顾</a> | <a class="ae jo" rel="noopener" href="/coinmonks/kucoin-trading-bot-automate-your-trades-8cf0ca2138e0"> Kucoin交易机器人</a></li><li id="912d" class="lv lw ht is b it me ix mf jb mg jf mh jj mi jn ma mb mc md dt translated"><a class="ae jo" href="https://coincodecap.com/buy-bitcoin-anonymously" rel="noopener ugc nofollow" target="_blank">如何匿名购买比特币</a> | <a class="ae jo" href="https://coincodecap.com/bitcoin-cash-wallets" rel="noopener ugc nofollow" target="_blank">比特币现金钱包</a></li><li id="095e" class="lv lw ht is b it me ix mf jb mg jf mh jj mi jn ma mb mc md dt translated"><a class="ae jo" href="https://coincodecap.com/binance-vs-ftx" rel="noopener ugc nofollow" target="_blank">币安vs FTX </a> | <a class="ae jo" href="https://coincodecap.com/solana-wallets" rel="noopener ugc nofollow" target="_blank">最佳(SOL)索拉纳钱包</a></li><li id="0141" class="lv lw ht is b it me ix mf jb mg jf mh jj mi jn ma mb mc md dt translated"><a class="ae jo" href="https://coincodecap.com/binomo-review" rel="noopener ugc nofollow" target="_blank">比诺莫评论</a> | <a class="ae jo" href="https://coincodecap.com/stoic-vs-3commas-vs-tradesanta" rel="noopener ugc nofollow" target="_blank">斯多葛派vs 3Commas vs TradeSanta </a></li><li id="98f6" class="lv lw ht is b it me ix mf jb mg jf mh jj mi jn ma mb mc md dt translated"><a class="ae jo" href="https://coincodecap.com/capital-com-review" rel="noopener ugc nofollow" target="_blank">Capital.com评论</a> | <a class="ae jo" href="https://coincodecap.com/crypto-lending-hong-kong" rel="noopener ugc nofollow" target="_blank">香港的加密借贷平台</a></li></ul></div></div>    
</body>
</html>