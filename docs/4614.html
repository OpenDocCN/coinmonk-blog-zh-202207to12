<html>
<head>
<title>Proxy — Eternal Storage</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">代理—永久存储</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/proxy-eternal-storage-f67c54972cdb?source=collection_archive---------23-----------------------#2022-10-05">https://medium.com/coinmonks/proxy-eternal-storage-f67c54972cdb?source=collection_archive---------23-----------------------#2022-10-05</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="90b3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这里你可以找到<a class="ae jo" rel="noopener" href="/coinmonks/variable-immutability-proxy-112b861a9cb4">和</a>的介绍。</p><p id="9b39" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><a class="ae jo" rel="noopener" href="/coinmonks/proxy-inherited-storage-7887f63944e6">继承存储代理模式</a>的问题是在下一版本的逻辑中使用它的成本越来越高。其原因是有必要在新的中继承旧的存储，即使我们不会使用那里的一些状态。</p><p id="9619" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">因此，还有另一种储存方式——永久储存。这一次，代理和从契约继承的逻辑如下所示</p><figure class="jp jq jr js fq jt"><div class="bz el l di"><div class="ju jv l"/></div></figure><p id="77d9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当然，你注意到在这个契约中只有映射。密钥总是字节32。为什么会这样？</p><p id="c887" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">永恒存储模式的主要概念是只使用来自永恒存储的映射。没有其他变量。那么，我们应该如何使用这种类型的存储呢？</p><p id="f4a6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">假设我们的逻辑契约想要定义uint256类型变量<code class="eh jw jx jy jz b">costOfToken</code>，然后将其设置为5。因此，如果我们的变量是uint256，那么我们应该使用我们的永久存储契约中的uintStorage映射，其中值为5。但是关键是什么呢？我们需要一个函数，它总是给出32个字节，没有输入的差异。这种类型的函数是keccak256。</p><p id="9e0f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">所以我们的问题的答案，如何定义一个新的变量，并设置其值是命令看起来像什么</p><pre class="jp jq jr js fq ka jz kb kc aw kd dt"><span id="728f" class="ke kf ht jz b fv kg kh l ki kj">uintStorage[keccak256("costOfToken")] = 5;</span></pre><p id="4f31" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这看起来比刚才更困难</p><pre class="jp jq jr js fq ka jz kb kc aw kd dt"><span id="17d5" class="ke kf ht jz b fv kg kh l ki kj">uint256 internal costOfToken = 5;</span></pre><p id="59be" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">但是它给了我们更多的灵活性。</p><p id="5675" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">因为我们使用动态数组来保存我们的变量，所以我们能够定义我们需要的各种不同类型的变量。我们不必担心覆盖存储器中的槽。此外，当我们升级我们的逻辑时，它只需要继承存储契约，因此只有少数映射，而不是像继承存储中的所有变量。</p><p id="586b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这种解决方案有两个大缺点。首先，阅读逻辑契约不会告诉我们所有已定义的变量，所以我们必须记住所有被我们使用的键。第二，除了在创建永久存储时声明的类型之外，我们不能使用任何其他类型。</p><h1 id="54d4" class="kk kf ht bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">摘要</h1><h2 id="4d3a" class="ke kf ht bd kl lh li lj kp lk ll lm kt jb ln lo kx jf lp lq lb jj lr ls lf lt dt translated">优势</h2><ul class=""><li id="7a33" class="lu lv ht is b it lw ix lx jb ly jf lz jj ma jn mb mc md me dt translated">这是比传统存储更便宜的解决方案</li><li id="c214" class="lu lv ht is b it mf ix mg jb mh jf mi jj mj jn mb mc md me dt translated">我们可以使用很多我们需要的变量</li><li id="abd3" class="lu lv ht is b it mf ix mg jb mh jf mi jj mj jn mb mc md me dt translated">逻辑契约没有与特定的代理契约紧密耦合。这是为了给我们更多的灵活性。</li></ul><h2 id="0b30" class="ke kf ht bd kl lh li lj kp lk ll lm kt jb ln lo kx jf lp lq lb jj lr ls lf lt dt translated">不足之处</h2><ul class=""><li id="efeb" class="lu lv ht is b it lw ix lx jb ly jf lz jj ma jn mb mc md me dt translated">不显式写入所有定义的变量</li><li id="9058" class="lu lv ht is b it mf ix mg jb mh jf mi jj mj jn mb mc md me dt translated">写入和读取值更加繁琐</li><li id="b523" class="lu lv ht is b it mf ix mg jb mh jf mi jj mj jn mb mc md me dt translated">我们可以只使用写永久存储时声明的类型</li></ul></div><div class="ab cl mk ml hb mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hm hn ho hp hq"><p id="0a47" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我希望这篇文章对你有用。如果你有任何想法，我如何能使我的帖子更好，请告诉我。我随时准备学习。你可以在<a class="ae jo" href="https://pl.linkedin.com/in/szymon-skrzy%C5%84ski-881462214" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>和<a class="ae jo" href="https://t.me/eszymi" rel="noopener ugc nofollow" target="_blank"> Telegram </a>上和我联系。</p><p id="0b39" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果你想和我谈论这个话题或者我写的其他话题，请随意。我乐于交谈。</p><p id="f9fe" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">快乐学习！</p><blockquote class="mr"><p id="3c19" class="ms mt ht bd mu mv mw mx my mz na jn ek translated">交易新手？试试<a class="ae jo" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或者<a class="ae jo" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>