<html>
<head>
<title>Uploading Compressed files to a Solidity Smart Contract</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将压缩文件上传到Solidity Smart合同</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/uploading-compressed-files-to-a-solidity-smart-contract-f0f7b17ccf79?source=collection_archive---------3-----------------------#2022-12-03">https://medium.com/coinmonks/uploading-compressed-files-to-a-solidity-smart-contract-f0f7b17ccf79?source=collection_archive---------3-----------------------#2022-12-03</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/e485315ba269f6161471a55e5ceb1400.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZEZkTSWcWTWj65YCCU-c-w.jpeg"/></div></div></figure><h1 id="b302" class="jb jc ht bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy dt translated">创新正在召唤</h1><p id="007c" class="pw-post-body-paragraph jz ka ht kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hm dt translated">通过使用来自open AI的令人惊讶的新GPT聊天，一个充满想法和知识的脑袋将它们联系在一起，我能够在创纪录的时间内制作出这个指南。</p><p id="a4ae" class="pw-post-body-paragraph jz ka ht kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hm dt translated">如果你还没看过这个，请点击这里的来玩<a class="ae lc" href="https://chat.openai.com/chat" rel="noopener ugc nofollow" target="_blank">。</a></p><h1 id="4998" class="jb jc ht bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy dt translated">创建React应用程序</h1><p id="7c31" class="pw-post-body-paragraph jz ka ht kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hm dt translated">本指南假设你已经安装了节点，如果你没有，你可以从<a class="ae lc" href="https://nodejs.org/en/download/" rel="noopener ugc nofollow" target="_blank">这里</a>安装。</p><p id="55d0" class="pw-post-body-paragraph jz ka ht kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hm dt translated">在你的桌面上为我们的前端应用程序创建一个新的目录，打开一个新的终端窗口和cd到那个目录。</p><p id="6cf7" class="pw-post-body-paragraph jz ka ht kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hm dt translated">在这个新目录中，在终端中键入以下内容，创建一个新的react应用程序:</p><pre class="ld le lf lg fq lh li lj bn lk ll bi"><span id="f3f8" class="lm jc ht li b be ln lo l lp lq">npx create-react-app FileCompressor</span></pre><p id="6ca7" class="pw-post-body-paragraph jz ka ht kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hm dt translated">安装后，您的新目录结构将被构建。</p><h1 id="72ff" class="jb jc ht bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy dt translated">添加前端上传表单</h1><p id="cbce" class="pw-post-body-paragraph jz ka ht kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hm dt translated">转到src/app.js并导航到app函数，将此逻辑放入其中:</p><pre class="ld le lf lg fq lh li lj bn lk ll bi"><span id="de02" class="lm jc ht li b be ln lo l lp lq"><br/>import React from "react";<br/><br/>function App(props) {<br/>  const handleChange = e =&gt; {<br/>    const fileReader = new FileReader();<br/>    fileReader.readAsText(e.target.files[0], "UTF-8");<br/>    fileReader.onload = e =&gt; {<br/>      if(e.target !== null) {<br/>        console.log("e.target.result", e.target.result);<br/>      }<br/>    };<br/>  };<br/><br/>  return (<br/>    &lt;&gt;<br/>      &lt;h1&gt;Upload file&lt;/h1&gt;<br/><br/>      &lt;input type="file" onChange={handleChange} /&gt;<br/>    &lt;/&gt;<br/>  );<br/>}<br/><br/>export default App;</span></pre><p id="abad" class="pw-post-body-paragraph jz ka ht kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hm dt translated">这将创建一个名为handleChange的新函数，每次有文件上传到前端时都会调用这个函数。</p><h1 id="db9d" class="jb jc ht bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy dt translated">Base64</h1><p id="c86f" class="pw-post-body-paragraph jz ka ht kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hm dt translated">我们的文件目前没有chain可以理解的格式，我们接下来需要将它转换成base64字符串，以便存储在chain上。</p><p id="f26a" class="pw-post-body-paragraph jz ka ht kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hm dt translated">回到您的app.js文件，我们将在其中向handleChange方法添加base64逻辑:</p><pre class="ld le lf lg fq lh li lj bn lk ll bi"><span id="c231" class="lm jc ht li b be ln lo l lp lq">import React from "react";<br/><br/>function App(props) {<br/>  const handleChange = e =&gt; {<br/>    const fileReader = new FileReader();<br/>    fileReader.readAsDataURL(file)<br/>    fileReader.onload = () =&gt; {<br/>      console.log(fileReader.result);<br/>    }<br/>    fileReader.onerror = (error) =&gt; {<br/>      console.log(error);<br/>    }<br/>  };<br/><br/>  return (<br/>    &lt;&gt;<br/>      &lt;h1&gt;Upload file&lt;/h1&gt;<br/><br/>      &lt;input type="file" onChange={handleChange} /&gt;<br/>    &lt;/&gt;<br/>  );<br/>}<br/><br/>export default App;</span></pre><p id="2a2c" class="pw-post-body-paragraph jz ka ht kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hm dt translated">到目前为止，我们有一个文件上传表单，它接受输入，将文件转换为base64字符串，并记录输出。这样很好，但是使用压缩来降低字节数更好。</p><p id="9302" class="pw-post-body-paragraph jz ka ht kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hm dt translated"><strong class="kb hu"> LZ字符串压缩</strong></p><p id="8314" class="pw-post-body-paragraph jz ka ht kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hm dt translated">首先安装lz压缩库:</p><pre class="ld le lf lg fq lh li lj bn lk ll bi"><span id="06f5" class="lm jc ht li b be ln lo l lp lq">npm i lzma-js</span></pre><p id="0cd6" class="pw-post-body-paragraph jz ka ht kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hm dt translated">安装后，将app.js修改为类似于下面的示例，这将把压缩的base64字符串记录到终端:</p><pre class="ld le lf lg fq lh li lj bn lk ll bi"><span id="6fa4" class="lm jc ht li b be ln lo l lp lq">import React from "react";<br/>import LZMA from "lzma-js";<br/><br/>function App(props) {<br/>  const handleChange = e =&gt; {<br/>    const fileReader = new FileReader();<br/>    fileReader.readAsDataURL(file)<br/>    fileReader.onload = () =&gt; {<br/>      // Convert the base64 encoded string to a Uint8Array<br/>      const uint8Array = Uint8Array.from(atob(fileReader.result), c =&gt; c.charCodeAt(0));<br/>      <br/>      // Compress the Uint8Array using LZMA-JS<br/>      LZMA.compress(uint8Array, 9, (result, error) =&gt; {<br/>        if (error) {<br/>          // Handle error<br/>        } else {<br/>          // The compressed data is a Uint8Array, so you need to convert it to a base64 encoded string<br/>          const compressedBase64String = btoa(String.fromCharCode(...result));<br/>          console.log(compressedBase64String); // Outputs the compressed base64 encoded string<br/>        }<br/>      });<br/>    }<br/>    fileReader.onerror = (error) =&gt; {<br/>      console.log(error);<br/>    }<br/>  };<br/><br/>  return (<br/>    &lt;&gt;<br/>      &lt;h1&gt;Upload file&lt;/h1&gt;<br/><br/>      &lt;input type="file" onChange={handleChange} /&gt;<br/>    &lt;/&gt;<br/>  );<br/>}<br/><br/>export default App;</span></pre><p id="bcb5" class="pw-post-body-paragraph jz ka ht kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hm dt translated"><strong class="kb hu">智能合约</strong></p><p id="08a8" class="pw-post-body-paragraph jz ka ht kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hm dt translated">这是一个简单的智能契约，它存储一个字节32字符串的数组，在本例中，我们的字节32字符串是文件。</p><pre class="ld le lf lg fq lh li lj bn lk ll bi"><span id="afc2" class="lm jc ht li b be ln lo l lp lq">// SPDX-License-Identifier: MIT <br/><br/>pragma solidity ^0.8.10;<br/><br/>contract FileStorage { <br/>  mapping (address =&gt; bytes32[]) userFiles;<br/><br/>  function addFile(string calldata _file) public { <br/>    userFiles[msg.sender].push(_file);<br/>  }<br/><br/>  function deleteFile(uint arrayIndex) public {<br/>    delete userFiles[msg.sender][arrayIndex];<br/>  }<br/><br/>  function getFiles() public view returns (bytes32[] memory) {<br/>    return userFiles[msg.sender];<br/>  }<br/>}</span></pre><p id="4a5b" class="pw-post-body-paragraph jz ka ht kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hm dt translated">这是最低限度，所以对于生产情况，你可能需要更多，但上述合同将足以满足本教程的目的。部署完成后，您就可以将react应用程序连接到分散的文件数据库了。</p><h1 id="e285" class="jb jc ht bd jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy dt translated">连接Dapp</h1><p id="08af" class="pw-post-body-paragraph jz ka ht kb b kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw hm dt translated">首先为您部署的合同获取abi，并存储在一个名为abi.json的新文件中。</p><pre class="ld le lf lg fq lh li lj bn lk ll bi"><span id="8af5" class="lm jc ht li b be ln lo l lp lq">[<br/> {<br/>  "inputs": [<br/>   {<br/>    "internalType": "string",<br/>    "name": "_file",<br/>    "type": "string"<br/>   }<br/>  ],<br/>  "name": "addFile",<br/>  "outputs": [],<br/>  "stateMutability": "nonpayable",<br/>  "type": "function"<br/> },<br/> {<br/>  "inputs": [<br/>   {<br/>    "internalType": "uint256",<br/>    "name": "arrayIndex",<br/>    "type": "uint256"<br/>   }<br/>  ],<br/>  "name": "deleteFile",<br/>  "outputs": [],<br/>  "stateMutability": "nonpayable",<br/>  "type": "function"<br/> },<br/> {<br/>  "inputs": [],<br/>  "name": "getFiles",<br/>  "outputs": [<br/>   {<br/>    "internalType": "string[]",<br/>    "name": "",<br/>    "type": "string[]"<br/>   }<br/>  ],<br/>  "stateMutability": "view",<br/>  "type": "function"<br/> }<br/>]</span></pre><p id="e30d" class="pw-post-body-paragraph jz ka ht kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hm dt translated">如果您返回到app.js文件，最后一步将是将文件字符串的控制台日志替换为智能合约调用。首先，我们引入契约abi，填写契约地址，通过前端连接到元掩码，然后在连接建立后允许存储用户文件。</p><pre class="ld le lf lg fq lh li lj bn lk ll bi"><span id="feb7" class="lm jc ht li b be ln lo l lp lq">import React from "react";<br/>import LZMA from "lzma-js";<br/><br/>function App(props) {<br/>  const abi = require('./abi.json');<br/>  const handleChange = e =&gt; {<br/>    const fileReader = new FileReader();<br/>    const CONTRACT_ADDRESS = "0xof";<br/>    fileReader.readAsDataURL(file)<br/>    fileReader.onload = () =&gt; {<br/>      // Convert the base64 encoded string to a Uint8Array<br/>      const uint8Array = Uint8Array.from(atob(fileReader.result), c =&gt; c.charCodeAt(0));<br/>      <br/>      // Compress the Uint8Array using LZMA-JS<br/>      LZMA.compress(uint8Array, 9, (result, error) =&gt; {<br/>        if (error) {<br/>          console.log(error);<br/>        } else {<br/>            // The compressed data is a Uint8Array, so you need to convert it to a base64 encoded string<br/>            const compressedBase64String = btoa(String.fromCharCode(...result));<br/>            const { ethereum } = window;<br/>            const provider = new ethers.providers.Web3Provider(ethereum);<br/>            const signer = provider.getSigner()<br/>            const connectedContract = new ethers.Contract(CONTRACT_ADDRESS, abi, signer);<br/><br/>            let tx = async() =&gt; await connectedContract.addFile(compressedBase64String);<br/><br/>            console.log(tx); // Outputs the result of the smart contract call<br/>        }<br/>      });<br/>    }<br/>    fileReader.onerror = (error) =&gt; {<br/>      console.log(error);<br/>    }<br/>  };<br/><br/>  return (<br/>    &lt;&gt;<br/>      &lt;h1&gt;Upload file&lt;/h1&gt;<br/><br/>      &lt;input type="file" onChange={handleChange} /&gt;<br/>    &lt;/&gt;<br/>  );<br/>}<br/><br/>export default App;</span></pre><p id="fdf6" class="pw-post-body-paragraph jz ka ht kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hm dt translated">这就是压缩word文档并将其存储在chain上所需的全部内容，而不仅仅是word文档，尽管几乎任何文件类型都可以被基于浏览器的上传程序所理解。</p><p id="e313" class="pw-post-body-paragraph jz ka ht kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hm dt translated">要返回您的文件并解压缩，您将需要创建一个新的方法来查询智能契约getFiles函数并循环每个函数，在每个迭代中，您只需调用下面的方法，并以适合您的用例的任何方式存储解压缩的数据:</p><pre class="ld le lf lg fq lh li lj bn lk ll bi"><span id="4201" class="lm jc ht li b be ln lo l lp lq">LZMA.decompress(properties, inStream, outStream, outSize);</span></pre><p id="d69c" class="pw-post-body-paragraph jz ka ht kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hm dt translated">这种方法有很多可能性，但像往常一样，这只是一个指南，引导您建立坚实的基础和理解，但绝不是生产就绪。</p><p id="062d" class="pw-post-body-paragraph jz ka ht kb b kc kx ke kf kg ky ki kj kk kz km kn ko la kq kr ks lb ku kv kw hm dt translated">去创造吧！</p><blockquote class="lr"><p id="dfcc" class="ls lt ht bd lu lv lw lx ly lz ma kw ek translated">交易新手？试试<a class="ae lc" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或者<a class="ae lc" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>