<html>
<head>
<title>CSC101-Upgradable and Proxy Smart Contracts Part1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CSC 101-可升级和代理智能合同第1部分</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/csc101-upgradable-and-proxy-smart-contracts-part1-79415b9447f7?source=collection_archive---------25-----------------------#2022-10-22">https://medium.com/coinmonks/csc101-upgradable-and-proxy-smart-contracts-part1-79415b9447f7?source=collection_archive---------25-----------------------#2022-10-22</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="75d5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">区块链最大的特点之一就是数据是不可变的。这意味着没有人能在不使整个区块链失效的情况下改变任何交易的内容。部署智能合约后，您不能更改代码，因此也不能升级智能合约。</p><p id="f587" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在本教程中，我们将介绍可升级和代理智能合同。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff jo"><img src="../Images/78db353f85d00a7149d8bc2b6bc3c9de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nYib8N6wIy-Papn96wyEKg.png"/></div></div></figure><h2 id="1fa7" class="ka kb ht bd kc kd ke kf kg kh ki kj kk jb kl km kn jf ko kp kq jj kr ks kt ku dt translated">代理合同</h2><p id="2cd5" class="pw-post-body-paragraph iq ir ht is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hm dt translated">通过将代码重新构建到不同的契约中，可以在保持存储相同的同时允许逻辑升级。事实上，可升级的smarts合同越来越受欢迎，杰克·唐纳有一篇很好的文章解释了所有使用的技术。</p><p id="1e05" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">想法是有一个存储契约，一个注册契约和一个逻辑契约。每当需要在逻辑契约中添加新功能或升级现有功能时，只需创建一个新的逻辑契约，继承当前的逻辑契约。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff lb"><img src="../Images/31afe9b21845adb516f5a8b0bdbe0f25.png" data-original-src="https://miro.medium.com/v2/resize:fit:1180/format:webp/1*4eAzd0H43srdNPwhmCohwg.jpeg"/></div></div></figure><p id="9261" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">存储契约只是保存状态，让我们尽可能地简化它:</p><pre class="jp jq jr js fq lc ld le lf aw lg dt"><span id="9663" class="ka kb ht ld b fv lh li l lj lk">pragma solidity ^0.8.13;</span><span id="137c" class="ka kb ht ld b fv ll li l lj lk">contract Storage {<br/>    uint public val;<br/>}</span></pre><p id="bf67" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">注册表协定为逻辑协定提供代理，以修改它所继承的存储协定的状态。</p><pre class="jp jq jr js fq lc ld le lf aw lg dt"><span id="6198" class="ka kb ht ld b fv lh li l lj lk">pragma solidity ^0.4.21;</span><span id="5f34" class="ka kb ht ld b fv ll li l lj lk">import './Ownable.sol';<br/>import './Storage.sol';</span><span id="fba3" class="ka kb ht ld b fv ll li l lj lk">contract Registry is Storage, Ownable {</span><span id="3c66" class="ka kb ht ld b fv ll li l lj lk">    address public logic_contract;</span><span id="093f" class="ka kb ht ld b fv ll li l lj lk">    function setLogicContract(address _c) public onlyOwner returns (bool success){<br/>        logic_contract = _c;<br/>        return true;<br/>    }</span><span id="b8b4" class="ka kb ht ld b fv ll li l lj lk">    function () payable public {<br/>        address target = logic_contract;<br/>        assembly {<br/>            let ptr := mload(0x40)<br/>            calldatacopy(ptr, 0, calldatasize)<br/>            let result := delegatecall(gas, target, ptr, calldatasize, 0, 0)<br/>            let size := returndatasize<br/>            returndatacopy(ptr, 0, size)<br/>            switch result<br/>            case 0 { revert(ptr, size) }<br/>            case 1 { return(ptr, size) }<br/>        }<br/>    }<br/>}</span></pre><p id="a157" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">注册中心契约需要知道与哪个逻辑契约对话。我们可以使用setLogicContract函数进行设置。我们使用了一个简单的Ownable.sol来确保只有admin可以调用setLogicContract函数。对于一些人来说，<a class="ae la" href="http://solidity.readthedocs.io/en/v0.4.24/assembly.html" rel="noopener ugc nofollow" target="_blank">程序集</a>中的回退功能可能看起来很陌生，但是这个特殊的代码实际上对于代理契约来说是相当标准的。基本上，它允许外部契约改变其内部存储。请注意，在拥有合同之前初始化存储也非常重要。</p><p id="a061" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">delegatecall汇编代码很方便，但也很危险。因此，在开始使用它之前，请确保您知道正在发生什么。</p><p id="5a47" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">接下来，我们来谈谈逻辑部分。</p><pre class="jp jq jr js fq lc ld le lf aw lg dt"><span id="f8ac" class="ka kb ht ld b fv lh li l lj lk">pragma solidity ^0.8.13;</span><span id="4ecf" class="ka kb ht ld b fv ll li l lj lk">import './Storage.sol';</span><span id="c585" class="ka kb ht ld b fv ll li l lj lk">contract LogicOne is Storage {<br/>    function setVal(uint _val) public returns (bool success) {<br/>        val = 2 * _val;<br/>        return true;<br/>    }<br/>}</span></pre><p id="95c0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">注</strong>:LogicOne合同意在修改“val”存储。</p><p id="c11e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">实现</strong></p><ol class=""><li id="38ad" class="lm ln ht is b it iu ix iy jb lo jf lp jj lq jn lr ls lt lu dt translated">我们部署Registry.sol和LogicOne.sol</li><li id="8815" class="lm ln ht is b it lv ix lw jb lx jf ly jj lz jn lr ls lt lu dt translated">我们在Registry.sol中注册LogicOne部署的地址，即</li></ol><pre class="jp jq jr js fq lc ld le lf aw lg dt"><span id="1a85" class="ka kb ht ld b fv lh li l lj lk">Registry.at(Registry.address).setLogicContract(LogicOne.address)</span></pre><p id="7721" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">3.我们使用LogicOne <a class="ae la" href="https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI" rel="noopener ugc nofollow" target="_blank"> ABI </a>来修改注册中心契约中的“val”存储。</p><pre class="jp jq jr js fq lc ld le lf aw lg dt"><span id="b0a3" class="ka kb ht ld b fv lh li l lj lk">LogicOne.at(Registry.address).setVal(2)</span></pre><p id="811a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">4.例如，当我们准备将LogicOne升级到LogicTwo时，我们部署LogicTwo契约并更新注册中心契约以指向它。</p><pre class="jp jq jr js fq lc ld le lf aw lg dt"><span id="59ff" class="ka kb ht ld b fv lh li l lj lk">Registry.at(Registry.address).setLogicContract(LogicTwo.address)</span></pre><p id="c859" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">5.我们现在可以用LogicTwo控制注册表的存储。</p><pre class="jp jq jr js fq lc ld le lf aw lg dt"><span id="a594" class="ka kb ht ld b fv lh li l lj lk">LogicTwo.at(Registry.address).setVal(2)</span></pre><p id="b3c2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">重要的是花一点时间来消化我们在这里做的事情，而不是马上投入代码。LogicOne和LogicTwo的存储与注册表协定中的存储不同。它们只通过存储设计相关(这一点非常重要)。</p><p id="bff8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">鸣谢:</strong>特别感谢<strong class="is hu">伯纳德·佩</strong>精彩的代码和文章</p><blockquote class="ma"><p id="f668" class="mb mc ht bd md me mf mg mh mi mj jn ek translated">交易新手？试试<a class="ae la" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a>或<a class="ae la" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>