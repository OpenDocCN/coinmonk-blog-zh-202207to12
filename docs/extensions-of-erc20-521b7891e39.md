# ERC20 的扩展

> 原文：<https://medium.com/coinmonks/extensions-of-erc20-521b7891e39?source=collection_archive---------14----------------------->

ERC20 标准是以太坊生态系统中最著名的标准之一。它提供了创建和转移可替换令牌的基本功能。但是在这里我不想把重点放在 ERC20 标准的细节和如何实现它的方法上，因为在互联网上有大量的这类信息。我想把重点放在我们可以添加到普通 ERC20 标准的扩展上，使它更适合各种不同的用例。

![](img/e95b6b72c835eed11c604984960ca1e8.png)

# 扩展ˌ扩张

我将在这里描述的所有扩展都来自 OpenZeppelin 的 github。

## ERC 20 可燃

标准的 ERC20 实现只有内部函数`_burn`，在任何实现的函数中都没有使用。这个扩展给了我们两个新公共函数:`burn`和`burnFrom`。它们都允许代币持有者拥有自己的代币和他们有津贴的代币。如果令牌持有者将通过这些功能中的一个来燃烧令牌，将发出事件`Transfer`，这将被离线识别。

## ERC 20 加盖

这个扩展给了我们一个额外的小功能——它设置了铸造代币数量的上限。很简单，不是吗？Aaa，我有没有说过这个极限是不可改变的？所以，一旦设置了值，就没有机会更改了。

## ERC20FlashMint

这个很有意思。这是对 [ERC3156](https://eips.ethereum.org/EIPS/eip-3156) FlashLoan 扩展的实现。感谢我们创造代币的合同还能给予 flashLoan，加上贷款的非零费用使我们的代币紧缩。但是默认情况下，费用设置为零。

让我们一步一步地检查它是如何工作的。当有人想从我们的合同中借用令牌时，需要使用一个`flashLoan`函数。该函数的参数是:

*   令牌应转移到的合同地址
*   他想借的令牌的地址
*   数量，他想要多少
*   将发送到接收方合同的附加数据

当数量不大于可用于贷款的代币的最大数量时，该合同将铸造任何人想要借的代币。然后契约从接收者的契约中调用函数`onFlashLoan`。是借款人使用借来的钱的空间。最后，`onFlashLoan`函数必须返回等于`keccak256(“ERC3156FlashBorrower.onFlashLoan”)`的 bytes32 值。当一切顺利时，契约最后会烧掉所有先前铸造的代币。

## ERC 20 暂停

该扩展实现了标准 ERC20 契约的紧急停止机制，该机制可以由授权地址触发。它是通过添加两个新的修饰符:`whenNotPaused`、`whenPaused`和修改 ERC20 的`_beforTokenTransfer`函数而制成的。这一修改暂停了`_transfer`、`_mint`和`_burn`的工作。

当我们希望在评估过程中停止所有令牌传输，或者在代码中发现严重错误时，此扩展非常有用。这只是一个出现的红色大按钮，暂停一切工作。

## ERC 20 快照

提供对过去代币余额和总供应量的有效存储。通过使用这个扩展，我们能够创建基于令牌数量的安全机制或创建高效的 ERC20 分叉系统。

它是如何工作的？与 ERC20Pausable 类似，`_beforTokenTransfer`功能被更改。这里总是在交易之前，契约调用函数`_updateAccountSnapshot`来保存我们当前的代币数量，并且这个函数被改变来保存我们发送代币的地址的当前余额。如果我们铸造或焚烧代币，更新总供应量的函数将被触发。所有快照都有自己的 id 号，我们可以用它来找到我们要找的东西。

## ERC 20 许可证

标准 ERC20 的下一个非常有趣的扩展。其存在的主要原因是允许令牌持有者在没有以太网的情况下转让他们自己的 ERC20 令牌。这一改进可以显著改善用户使用令牌的体验。

我们如何避免支付以太网的必要性？答案是外链签名批准交易。我这么说是什么意思？该扩展增加了新功能`permit`。该功能允许用户使用由他们签名的消息来修改津贴映射，而不是像往常一样使用`msg.sender`。因此，我们能够使其链外，并避免强制性支付以太网。听起来很棒，不是吗？

## ERC20Votes 和 ERC20VotesComp

这里我们有两个相似的扩展。他们都允许使用 ERC20 作为投票的令牌。他们跟踪投票并允许投票委托。这些扩展提出的投票机制很简单，每个帐户的投票权与拥有这个令牌有关。此外，为了防止双重投票，它们都使用了与前面描述的快照扩展类似的东西。扩展跟踪每个帐户的历史余额，所以有可能从过去检索投票权。这些扩展的小缺点是需要进行最少一次转账来记录快照中的帐户余额并获得投票权。

那么这些扩展的区别在哪里呢？区别在于令牌供应的限制。ERC20Votes 支持比 2⁹⁶更大的供应量，这是 ERC20VotesComp 的上限，并且感谢它更灵活。ERC20VotesComp 为什么有这么高的上限？这个扩展适合于由 GovernorAlpha 和 GovernorBravo 使用的 COMP 令牌的接口。

## ERC 20 包装器

这是一个简单扩展，允许将一个 ERC20 令牌更改为另一个(包装令牌)。我们可以定义多少第一种类型的记号等于一个第二种类型的记号。通常，这个数字等于 1。在这个扩展中，发送方发送一定数量的令牌，这些令牌存放在智能合约中，并且匹配数量的包装令牌被发送给发送方。当他想要取回他的代币时，他只需将包装好的代币放入该合同中。这在与投票等其他模块结合使用时非常有用。

## ERC4626

这是跳马的符号化标准，但什么是跳马呢？Vault 是智能合约，您可以在其中存放代币，然后 vault 使用此代币做一些事情来提供代币奖励。这是一个可以管理和存储密码的多签署合同。每个保管库总是具有作为返回生成的令牌。这些生成的代币可以与存放的代币交换，也可以与锁在金库中的代币交换。金库比钱包更安全，因此许多 DeFi 项目用它来存放资金。这些标准与 ERC20 兼容，因此我把它写成一个扩展。

ERC4626 非常重要，尤其是对 DeFi 而言，因为在此标准之前，有许多不同的方法用于存储和管理资产。由于这些原因，将不同项目相互连接起来是很成问题的。这非常耗时，而且存在很大的安全漏洞风险。此外，适合一对 DeFi 项目的解决方案不一定适合另一对。感谢 ERC4626，工作更快、更安全。

# ERC20 实用工具

在 OpenZeppelin 的图书馆中，在致力于 ERC20 的目录中还有一个名为 ER20 utils 的目录。当我们打开它时，我们会发现两个合同不是 ERC20 的扩展，但它们提供了一个额外的功能。

## 安全 20

并非所有开发人员都使用标准的 ERC20 令牌，但他们使用定制版本的 ERC20 接口实现，该实现有时不返回布尔返回值。当我们想创建智能合同，将与这种令牌工作，可能会有一些问题，错误等。为了防止它，我们可以使用 SafeERC20(它是一个库)函数来管理所有令牌。此外，SafeERC20 提供助手来增加和减少津贴，以减轻普通`approve`可能的攻击。

## 令牌时间锁

我认为这是这里描述的最简单的契约之一。这是一份代币持有人合同，不允许受益人在设定的发行时间之前从合同中取钱。当设定的时间过去，受益人将能够使用该功能发送给他所有的令牌。这就是全部，这份合同不再有效。

# 总结

正如我们所见，ERC20 有许多不同的扩展，这使得这种令牌标准能够满足我们的需求。投票，闪贷，金库等。

我希望这篇文章对你有用。如果你有任何想法，我如何能使我的帖子更好，请告诉我。我随时准备学习。你可以通过 [LinkedIn](https://pl.linkedin.com/in/szymon-skrzy%C5%84ski-881462214) 和 [Telegram](https://t.me/eszymi) 与我联系。

如果你想和我谈论这个话题或者我写的其他话题，请随意。我乐于交谈。

快乐学习！

> 交易新手？尝试[加密交易机器人](/coinmonks/crypto-trading-bot-c2ffce8acb2a)或[复制交易](/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c)