# 代理—永久存储

> 原文：<https://medium.com/coinmonks/proxy-eternal-storage-f67c54972cdb?source=collection_archive---------23----------------------->

在这里你可以找到[和](/coinmonks/variable-immutability-proxy-112b861a9cb4)的介绍。

[继承存储代理模式](/coinmonks/proxy-inherited-storage-7887f63944e6)的问题是在下一版本的逻辑中使用它的成本越来越高。其原因是有必要在新的中继承旧的存储，即使我们不会使用那里的一些状态。

因此，还有另一种储存方式——永久储存。这一次，代理和从契约继承的逻辑如下所示

当然，你注意到在这个契约中只有映射。密钥总是字节 32。为什么会这样？

永恒存储模式的主要概念是只使用来自永恒存储的映射。没有其他变量。那么，我们应该如何使用这种类型的存储呢？

假设我们的逻辑契约想要定义 uint256 类型变量`costOfToken`，然后将其设置为 5。因此，如果我们的变量是 uint256，那么我们应该使用我们的永久存储契约中的 uintStorage 映射，其中值为 5。但是关键是什么呢？我们需要一个函数，它总是给出 32 个字节，没有输入的差异。这种类型的函数是 keccak256。

所以我们的问题的答案，如何定义一个新的变量，并设置其值是命令看起来像什么

```
uintStorage[keccak256("costOfToken")] = 5;
```

这看起来比刚才更困难

```
uint256 internal costOfToken = 5;
```

但是它给了我们更多的灵活性。

因为我们使用动态数组来保存我们的变量，所以我们能够定义我们需要的各种不同类型的变量。我们不必担心覆盖存储器中的槽。此外，当我们升级我们的逻辑时，它只需要继承存储契约，因此只有少数映射，而不是像继承存储中的所有变量。

这种解决方案有两个大缺点。首先，阅读逻辑契约不会告诉我们所有已定义的变量，所以我们必须记住所有被我们使用的键。第二，除了在创建永久存储时声明的类型之外，我们不能使用任何其他类型。

# 摘要

## 优势

*   这是比传统存储更便宜的解决方案
*   我们可以使用很多我们需要的变量
*   逻辑契约没有与特定的代理契约紧密耦合。这是为了给我们更多的灵活性。

## 不足之处

*   不显式写入所有定义的变量
*   写入和读取值更加繁琐
*   我们可以只使用写永久存储时声明的类型

我希望这篇文章对你有用。如果你有任何想法，我如何能使我的帖子更好，请告诉我。我随时准备学习。你可以在 [LinkedIn](https://pl.linkedin.com/in/szymon-skrzy%C5%84ski-881462214) 和 [Telegram](https://t.me/eszymi) 上和我联系。

如果你想和我谈论这个话题或者我写的其他话题，请随意。我乐于交谈。

快乐学习！

> 交易新手？试试[加密交易机器人](/coinmonks/crypto-trading-bot-c2ffce8acb2a)或者[复制交易](/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c)