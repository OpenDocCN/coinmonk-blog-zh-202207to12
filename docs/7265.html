<html>
<head>
<title>Learn Solidity lesson 37. Creating and destroying contracts.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习第37课固体。创建和销毁合同。</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/learn-solidity-lesson-37-creating-and-destroying-contracts-6921ae32413a?source=collection_archive---------2-----------------------#2022-12-10">https://medium.com/coinmonks/learn-solidity-lesson-37-creating-and-destroying-contracts-6921ae32413a?source=collection_archive---------2-----------------------#2022-12-10</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/2ec15d422fb96886c568887e33779578.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FBeBZ9b1eCQWokIAaVImow.jpeg"/></div></div></figure><p id="ade5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在以太坊上创建合约账户有三种方式。外部拥有的账户可以通过向地址零(空地址)发送交易来创建合同账户。另外两种方法是使用CREATE和CREATE2操作码。智能合约可以调用这样的操作码。</p><h1 id="4d83" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">通过交易创建合同</h1><p id="746d" class="pw-post-body-paragraph jb jc ht jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy hm dt translated">eoa通过将事务发送到地址0来创建合同。以太坊虚拟机将接收这样的事务并执行初始代码。在执行过程中，当找到RETURN操作码时，将返回给发送方的十六进制数将被记录为约定代码。</p><p id="4c71" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">上述解释与EVM的低层运行有关。Solidity编译器的任务是创建必须通过网络发送的字节码。字节码是初始代码(init代码)和实际记录在网络上的代码(运行时字节码)的连接。如果你不了解以太坊虚拟机的工作原理，也不用担心。正如我所说的，为您编写必要的字节码是编译器的工作。</p><p id="21cc" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">然而，出于学习的目的，让我们发送一个任意的字节码到地址零。我们来发送下面的字节码:<code class="eh lc ld le lf b">6010602060306040</code>。这个字节码是非常无用的；它只是将4个1字节的值推到堆栈上。它不会生成任何要保存在区块链上的代码。</p><p id="2bf7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我将这个事务发送到Goerli网络，可以在下面的hash中找到:<code class="eh lc ld le lf b">0x9cf1fe5ce9e685d79d5a8e0fb103a5bfe0315f0302d44c08e8318d9c4ee9d34d.</code>有效负载可以在下图中看到。</p><figure class="lh li lj lk fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff lg"><img src="../Images/252f48054c926b2ed6a5a4c5ddc07456.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*95MfPoaGCHsbeQ9xWvMF4A.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">The payload sent in the transaction.</figcaption></figure><p id="befa" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">尽管交易有要执行的代码，但保存的合同代码为空，如下图所示。</p><figure class="lh li lj lk fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff lp"><img src="../Images/047528d2e261682437bab40337f56451.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2l67YFRsi6jv6Sjt2i6z9w.png"/></div></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">The contract has no code.</figcaption></figure><p id="498d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这个故事的寓意是:向地址零发送一个交易就足以创建一个合同帐户。然而，为了有效地编写区块链的契约代码，有效载荷必须是结构良好的。写给区块链的不是发送的。</p><h1 id="3389" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">使用CREATE创建合同</h1><p id="cf96" class="pw-post-body-paragraph jb jc ht jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy hm dt translated">EVM有两个创建合同的操作码:创建和创建2。让我们看看CREATE操作码。当我们使用<strong class="jd hu"> new </strong>关键字创建合同时，它被执行。</p><p id="57c9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们看看下面的代码:</p><pre class="lh li lj lk fq lq lf lr bn ls lt bi"><span id="dd47" class="lu ka ht lf b be lv lw l lx ly">pragma solidity ^0.8.7;<br/><br/>contract A {<br/>  uint public val1 = 10;<br/>}<br/><br/>contract B {<br/>  function create() public returns (address) {<br/>    A newA = new A();<br/>    return address(newA);<br/>  }<br/>} </span></pre><p id="86aa" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这是在Solidity中创建合同实例最常用的方法。要创建的协定的地址是确定的:它是创建者协定地址的RLP编码的keccak256的最后20个字节，加上协定的nonce。大词，对吧？我会尽快解释清楚。由外部帐户创建的合同的地址以同样的方式确定。</p><p id="9b06" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu"> RLP </strong>是<strong class="jd hu">R</strong>e cursion<strong class="jd hu">L</strong>ength<strong class="jd hu">P</strong>refix的首字母缩写。这是以太坊(执行层)序列化要在节点之间共享或存储在数据库中的数据的方式。RLP的工作方式没有那么简单，超出了本文的范围。</p><p id="c61f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">以下代码可用于计算地址的RLP和帐户随机数:</p><pre class="lh li lj lk fq lq lf lr bn ls lt bi"><span id="38f3" class="lu ka ht lf b be lv lw l lz ly">const RLP = require("rlp")<br/>const web3 = require("web3")<br/><br/>// address -&gt; 0xd9145CCE52D386f254917e481eB44e9943F39138<br/>// nonce -&gt; 2<br/>let buffer = RLP.encode([Buffer.from('d9145CCE52D386f254917e481eB44e9943F39138','hex'),2])<br/><br/>let nonceHash = web3.utils.sha3(Buffer.from(buffer))<br/>console.log(`0x${nonceHash.substring(26,66)}`)</span></pre><p id="000c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">地址和随机数都被硬编码到代码中。要计算帐户创建的任何合同的地址，只需替换上面代码中的地址和nonce。我决定在代码中明确这些值，使其更加清晰。</p><p id="df54" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">尽管具有确定性，但我们不可能准确选择要创建的合同的地址，因为我们无法直接控制账户的<em class="ma"> nonce </em>。因此，在合同中，不可能计算将要创建的合同的地址。</p><p id="89da" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">为了能够可靠地计算将要创建的契约的地址，我们必须使用第二个操作码CREATE2。</p><h1 id="f988" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">使用CREATE2创建合同</h1><p id="7db8" class="pw-post-body-paragraph jb jc ht jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy hm dt translated">像CREATE操作码一样，CREATE2操作码的目的是创建新的合同帐户。唯一的区别是如何计算新的合同地址。不是使用创建帐户的地址和它的nonce，而是使用其他字段:地址、字节码散列和一个任意数字，称为<em class="ma"> salt </em>。</p><p id="4a52" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">示意性地，新合同的地址采用以下形式:</p><pre class="lh li lj lk fq lq lf lr bn ls lt bi"><span id="f1a3" class="lu ka ht lf b be lv lw l lx ly">keccak256("0xff" + creatorAddr + salt + keccak256(bytecode))[24:64]</span></pre><p id="f8a8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">表达式[24:64]表明我们应该只获得生成的散列的最后40个字符(20个字节)。</p><p id="d3de" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">没有办法在Solidity中直接使用CREATE2操作码，所以我们必须使用assembly来实现。我不会在本文中深入讲授汇编，但我们将分析所使用的代码。下面我们来看看函数。</p><pre class="lh li lj lk fq lq lf lr bn ls lt bi"><span id="553d" class="lu ka ht lf b be lv lw l lx ly">function createContract(uint _salt) public {<br/>  bytes memory contractCode = type(TestContract).creationCode;<br/>  address addr;<br/>  assembly {<br/>    addr := create2(0, add(contractCode, 0x20), mload(contractCode), _salt)<br/>  }<br/>}</span></pre><p id="1033" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">要创建的契约在同一个文件中(这里没有显示)，并被命名为<code class="eh lc ld le lf b">TestContract</code>。为了获得它的字节码，我们使用下面的代码。</p><pre class="lh li lj lk fq lq lf lr bn ls lt bi"><span id="3752" class="lu ka ht lf b be lv lw l lx ly">type(TesteContract).creationCode</span></pre><p id="e059" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">为了在Solidity中使用assembly，我们将代码放在assembly块<code class="eh lc ld le lf b">{}</code>中。CREATE2操作码的使用在下面的语句中实现。</p><pre class="lh li lj lk fq lq lf lr bn ls lt bi"><span id="dde7" class="lu ka ht lf b be lv lw l lx ly">create2(0, add(contractCode, 0x20), mload(contractCode), _salt)   </span></pre><p id="c678" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这样一个操作码需要4个参数，形式为<code class="eh lc ld le lf b">create2(v,p,n,s)</code>。让我们看看每个参数代表什么。</p><ul class=""><li id="3f87" class="mb mc ht jd b je jf ji jj jm md jq me ju mf jy mg mh mi mj dt translated">v:要转到新帐户的金额，单位为魏。</li><li id="6c3b" class="mb mc ht jd b je mk ji ml jm mm jq mn ju mo jy mg mh mi mj dt translated">p:内存中可以找到契约开始的位置。</li><li id="2814" class="mb mc ht jd b je mk ji ml jm mm jq mn ju mo jy mg mh mi mj dt translated">n:合约大小。契约的结尾必须位于内存中，在p+n中。</li><li id="a167" class="mb mc ht jd b je mk ji ml jm mm jq mn ju mo jy mg mh mi mj dt translated">s:一个32字节的数字，叫做<em class="ma"> salt。</em></li></ul><p id="afe5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">正如我们在上面的create2语句中看到的，<code class="eh lc ld le lf b">p</code>的值被声明为<code class="eh lc ld le lf b">add(contractCode, 0x20)</code>。这意味着合同位于由<code class="eh lc ld le lf b">contractCode</code>加32字节指示的内存位置。让我告诉你为什么。</p><p id="ea3e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh lc ld le lf b">contractCode</code>变量是引用类型的，所以它的值指示在哪里可以找到合同代码。我们为什么要通过<code class="eh lc ld le lf b">add(contractCode, 0x20)}</code>功能添加<code class="eh lc ld le lf b">0x20</code>？因为代码有效地从32个字节开始(<code class="eh lc ld le lf b">0x20) </code>在<code class="eh lc ld le lf b">contractCode</code>指向的地方之后)。让我给你看看这个。</p><p id="da38" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">变量<code class="eh lc ld le lf b">contractCode</code>的值如下图所示，通过contractCodeValue: <code class="eh lc ld le lf b">0x80</code>。</p><figure class="lh li lj lk fq iu fe ff paragraph-image"><div class="fe ff mp"><img src="../Images/e3566e73faa1321e1f127afbb0e0e3c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:680/format:webp/1*SFJ--2-7tpVpbVjp7TFPdw.png"/></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">The contractCode variable has a value of 0x80.</figcaption></figure><p id="eebf" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这意味着合同代码位于存储器地址<code class="eh lc ld le lf b">0x80</code>。但是，在<code class="eh lc ld le lf b">0x80</code>中，前32个字节存储的是合同的长度，而不是代码本身。如下图所示，代码本身从<code class="eh lc ld le lf b">0xa0</code>开始。所以我们必须给<code class="eh lc ld le lf b">0x80</code>加20个字节，正好是<code class="eh lc ld le lf b">0xa0</code>。</p><figure class="lh li lj lk fq iu fe ff paragraph-image"><div class="fe ff mq"><img src="../Images/3b115a238aff8e365666c92dd61064ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:692/format:webp/1*VaU3S1F44P61AvDolaXibA.png"/></div><figcaption class="ll lm fg fe ff ln lo bd b be z ek">The contract code is in memory, and it starts at 0xa0.</figcaption></figure><p id="3163" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如前所述，契约的长度在<code class="eh lc ld le lf b">0x80</code>中找到，也就是在<code class="eh lc ld le lf b">contractCode</code>的值中找到。这个值可以通过句子<code class="eh lc ld le lf b">mload(contractCode)</code>读出。让我们记住create2的第三个参数正好是契约的大小。</p><p id="3d11" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在我们已经学习了如何在Solidity中创建契约，让我们看看如何计算它的地址。</p><pre class="lh li lj lk fq lq lf lr bn ls lt bi"><span id="871e" class="lu ka ht lf b be lv lw l lx ly">function getAddress(uint _salt) public view returns (address) {<br/>  bytes memory contractCode = type(TestContract).creationCode;<br/>    <br/>  bytes memory toHash = abi.encodePacked(bytes1(0xff), <br/>  address(this), _salt, keccak256(contractCode));<br/>    <br/>  return address(uint160(uint(keccak256(toHash))));<br/>}</span></pre><p id="59f5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">用于计算新契约地址的方案从'<code class="eh lc ld le lf b">0xff</code>'开始，以避免与创建操作码冲突，如在原始提议中所解释的，<a class="ae mr" href="https://eips.ethereum.org/EIPS/eip-1014" rel="noopener ugc nofollow" target="_blank"> EIP-1014 </a>。由于地址取决于合同的字节码，所以除了使用带有salt参数的强力方法之外，<em class="ma">没有办法选择新地址。</em></p><h1 id="5430" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">销毁合同</h1><p id="1e36" class="pw-post-body-paragraph jb jc ht jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy hm dt translated">到目前为止，我们已经学习了如何构建智能合约；现在让我们学习如何摧毁它们。为了使契约能够被销毁，它必须实现一个自毁按钮(或函数)。</p><p id="d51f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们创建一个函数来销毁一个契约。</p><pre class="lh li lj lk fq lq lf lr bn ls lt bi"><span id="6915" class="lu ka ht lf b be lv lw l lx ly">function kill(address _toSend) public {<br/>  selfdestruct(payable(_toSend));<br/>}</span></pre><p id="7db6" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当执行<code class="eh lc ld le lf b">selfdestruct</code>时，合同的代码将被删除，状态变量将被清除，合同拥有的所有以太网将被发送到地址<code class="eh lc ld le lf b">_toSend</code>。这就是为什么<code class="eh lc ld le lf b">selfdestruct</code>方法有一个参数。</p><p id="2c41" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">上面的函数一点也不安全，因为它可以被任何人调用。应该编写自毁功能，以便它们只能由授权帐户调用。</p><p id="374b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果程序员没有实现契约中的<code class="eh lc ld le lf b">selfdestruct</code>函数，就不能销毁。因此，在部署时必须已经存在摧毁它的可能性。</p><p id="2105" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">感谢阅读！</strong></p><p id="56b2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎对本文提出意见和建议。</p><p id="4d3e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎任何投稿。<a class="ae mr" href="http://www.buymeacoffee.com/jpmorais" rel="noopener ugc nofollow" target="_blank">www.buymeacoffee.com/jpmorais</a>。</p><blockquote class="ms"><p id="8c6f" class="mt mu ht bd mv mw mx my mz na nb jy ek translated">交易新手？尝试<a class="ae mr" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae mr" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>