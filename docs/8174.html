<html>
<head>
<title>OpenZeppelin Ethernaut Solutions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OpenZeppelin以太网解决方案</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/openzeppelin-ethernaut-solutions-ebda8b073b6f?source=collection_archive---------39-----------------------#2022-12-28">https://medium.com/coinmonks/openzeppelin-ethernaut-solutions-ebda8b073b6f?source=collection_archive---------39-----------------------#2022-12-28</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/ffde25add963533f96e9a5551e32f02d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_dkRNHqVhvQ4OOXHQkRRUw.jpeg"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">Image by <a class="ae jf" href="http://twitter.com/thenikyv" rel="noopener ugc nofollow" target="_blank">@thenikyv</a> from <a class="ae jf" href="https://unsplash.com/photos/QkSN_8XcXwQ" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5c1f" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">以太之旅是一款在以太坊虚拟机上玩的Web3/Solidity游戏。每一层都是需要‘黑’的智能合约。这是学习智能合约的可靠性和基本安全性的好方法。本文将提供我用来解决这些挑战的解决方案、资源和参考资料。本文中引用的所有解决方案代码都可以在github库上获得。</p><blockquote class="ke"><p id="7804" class="kf kg ht bd kh ki kj kk kl km kn kd ek translated">不知道什么时候买卖，试试<a class="ae jf" href="http://coincodecap.com/go/bityard" rel="noopener ugc nofollow" target="_blank">复制交易</a>。</p></blockquote><h2 id="ee40" class="ko kp ht bd kq kr ks kt ku kv kw kx ky jr kz la lb jv lc ld le jz lf lg lh li dt translated"><strong class="ak"> #1回退方案</strong></h2><p id="4507" class="pw-post-body-paragraph jg jh ht ji b jj lj jl jm jn lk jp jq jr ll jt ju jv lm jx jy jz ln kb kc kd hm dt translated">回退具有在<code class="eh lo lp lq lr b">constructor</code>中初始化<code class="eh lo lp lq lr b">owner</code>状态，以及具有1000 ETH值的当前<code class="eh lo lp lq lr b">owner</code>的<code class="eh lo lp lq lr b">contributions</code>映射。</p><p id="45ea" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">目标是将<code class="eh lo lp lq lr b">owner</code>设置到我们的地址，并使用<code class="eh lo lp lq lr b">withdraw</code>函数耗尽合同余额。</p><p id="7e3c" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">问题:1。要使用可用功能<code class="eh lo lp lq lr b">contribute</code>改变所有者，我们必须发送1000 ETH，太多了。2.<code class="eh lo lp lq lr b">withdraw</code>函数有<code class="eh lo lp lq lr b">onlyOwner</code>修饰符。</p><p id="40de" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">漏洞:定义了<code class="eh lo lp lq lr b">receive</code>函数，包含我们可以在不发送1000 ETH的情况下声明<code class="eh lo lp lq lr b">owner</code>的条件</p><p id="c5ba" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">解决方案:</p><ol class=""><li id="b18a" class="ls lt ht ji b jj jk jn jo jr lu jv lv jz lw kd lx ly lz ma dt translated"><code class="eh lo lp lq lr b">receive</code>函数要求我们有<code class="eh lo lp lq lr b">contribution</code> &gt; 0，所以我们调用<code class="eh lo lp lq lr b">msg.value</code>很低但大于0的<code class="eh lo lp lq lr b">contribute</code>函数。</li></ol><pre class="mb mc md me fq mf lr mg bn mh mi bi"><span id="bb27" class="mj kp ht lr b be mk ml l mm mn">contract.contribute({value: 100000000000000})</span></pre><p id="2238" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">2.<code class="eh lo lp lq lr b">receive</code>通过native call/send向合同发送ETH时触发的函数。我们已经完成了<code class="eh lo lp lq lr b">contribution</code> &gt; 0的检查，只需要直接发送ETH到带有<code class="eh lo lp lq lr b">msg.value</code> &gt; 0的契约。</p><pre class="mb mc md me fq mf lr mg bn mh mi bi"><span id="41e1" class="mj kp ht lr b be mk ml l mm mn">contract.sendTransaction({value: 10000000000000})</span></pre><p id="d83b" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">3.然后你可以查一下，<code class="eh lo lp lq lr b">owner</code>应该已经改成你的地址了</p><pre class="mb mc md me fq mf lr mg bn mh mi bi"><span id="8860" class="mj kp ht lr b be mk ml l mm mn">await contract.owner()</span></pre><p id="a6e5" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">4.最后，通过调用<code class="eh lo lp lq lr b">withdraw</code>函数清空合同:</p><pre class="mb mc md me fq mf lr mg bn mh mi bi"><span id="d330" class="mj kp ht lr b be mk ml l mm mn">contract.withdraw()</span></pre><p id="1d41" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu"> #2落尘溶液</strong></p><ol class=""><li id="a276" class="ls lt ht ji b jj jk jn jo jr lu jv lv jz lw kd lx ly lz ma dt translated">这是一个棘手的问题，你可能会从编译器版本中怀疑，它使用旧的<code class="eh lo lp lq lr b">^0.6.0</code>并且仍然接受契约名作为构造函数。但是，应该是构造函数的函数被拼错为<code class="eh lo lp lq lr b">Fal1out</code>，用1代替l。因此，将该函数作为公共函数，任何人都可以声明该契约的所有权。</li></ol><pre class="mb mc md me fq mf lr mg bn mh mi bi"><span id="37ff" class="mj kp ht lr b be mk ml l mm mn">contract.Fal1out()</span></pre><p id="5438" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu"> #3硬币翻转解决方案</strong></p><ol class=""><li id="892a" class="ls lt ht ji b jj jk jn jo jr lu jv lv jz lw kd lx ly lz ma dt translated">CoinFlip契约要求您通过输入<code class="eh lo lp lq lr b">false</code>或<code class="eh lo lp lq lr b">true</code>来猜测<code class="eh lo lp lq lr b">flip</code>函数的输出。然后<code class="eh lo lp lq lr b">flip</code>函数使用<code class="eh lo lp lq lr b">block.number-1</code>计算<code class="eh lo lp lq lr b">blockhash</code>并将其用作PRNG的源。</li><li id="c705" class="ls lt ht ji b jj mo jn mp jr mq jv mr jz ms kd lx ly lz ma dt translated">目标是我们需要以某种方式连续猜测<code class="eh lo lp lq lr b">flip</code>输出10次来通过这个问题，通过公共状态中的<code class="eh lo lp lq lr b">consecutiveWins</code>值来跟踪。</li><li id="3090" class="ls lt ht ji b jj mo jn mp jr mq jv mr jz ms kd lx ly lz ma dt translated">解决方案:<code class="eh lo lp lq lr b">block.number</code>对所有事务都可用，并且可以通过在另一个<code class="eh lo lp lq lr b">contract</code>函数上调用<code class="eh lo lp lq lr b">flip</code>函数来滥用，在这种情况下<code class="eh lo lp lq lr b">CoinFlipper</code>契约具有使用<code class="eh lo lp lq lr b">block.number</code>重构PRNG并使用值调用<code class="eh lo lp lq lr b">flip</code>的<code class="eh lo lp lq lr b">flipper</code>函数。手动或使用脚本调用10次，但问题是我们每次都必须在有差异的事务上调用它，所以在调用另一个调用之前要等待上一个<code class="eh lo lp lq lr b">flipper</code>完成。</li></ol><p id="737b" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu"> #4电话解决</strong></p><ol class=""><li id="c2d9" class="ls lt ht ji b jj jk jn jo jr lu jv lv jz lw kd lx ly lz ma dt translated"><code class="eh lo lp lq lr b">tx.origin</code>不等于<code class="eh lo lp lq lr b">msg.sender</code>当我们从另一个契约a调用契约B函数时，因为<code class="eh lo lp lq lr b">tx.origin</code>将是EOA调用者而<code class="eh lo lp lq lr b">msg.sender</code>将是契约a的地址</li><li id="7df3" class="ls lt ht ji b jj mo jn mp jr mq jv mr jz ms kd lx ly lz ma dt translated">解决方案可在<code class="eh lo lp lq lr b">Telecall.sol</code>获得</li></ol><p id="5f5b" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu"> #5令牌解决方案</strong></p><ol class=""><li id="7115" class="ls lt ht ji b jj jk jn jo jr lu jv lv jz lw kd lx ly lz ma dt translated">旧的solidity编译器没有内置的SafeMath检查器。因此容易发生下溢和上溢。</li></ol><pre class="mb mc md me fq mf lr mg bn mh mi bi"><span id="d8c6" class="mj kp ht lr b be mk ml l mm mn">require(balances[msg.sender] - _value &gt;= 0)</span></pre><p id="e43f" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">对<code class="eh lo lp lq lr b">balances</code>状态的检查很容易被滥用，因为如果<code class="eh lo lp lq lr b">_value</code>较高，结果会下溢，结果会变成非常高的单位数。</p><p id="70b2" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">2.要滥用这个合同，你可以发任何比你现在的<code class="eh lo lp lq lr b">balances</code>高的<code class="eh lo lp lq lr b">_value</code>，发到其他任何地址。</p><p id="c2d1" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu"> #6委托解决方案</strong></p><ol class=""><li id="4d4e" class="ls lt ht ji b jj jk jn jo jr lu jv lv jz lw kd lx ly lz ma dt translated"><code class="eh lo lp lq lr b">delegatecall</code>是使用当前合同上下文执行目标合同逻辑的低级函数调用。通过向<code class="eh lo lp lq lr b">msg.data</code>提供“pwn()”的keccak散列的前4个字节，函数选择器。我们可以调用该函数，使用<code class="eh lo lp lq lr b">Delegate</code>契约逻辑修改<code class="eh lo lp lq lr b">owner</code>，但是使用<code class="eh lo lp lq lr b">Delegation</code>上下文，从而修改<code class="eh lo lp lq lr b">Delegation</code>的<code class="eh lo lp lq lr b">owner</code>。</li></ol><pre class="mb mc md me fq mf lr mg bn mh mi bi"><span id="abcb" class="mj kp ht lr b be mk ml l mm mn">// "0xdd365b8b" is the first 4 bytes of keccak256 hash of "pwn()"<br/>contract.sendTransaction({data:"0xdd365b8b"})</span></pre><p id="eca5" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu"> #7力解</strong></p><ol class=""><li id="eaea" class="ls lt ht ji b jj jk jn jo jr lu jv lv jz lw kd lx ly lz ma dt translated">没有实现<code class="eh lo lp lq lr b">receive()</code>函数或其中一个函数中没有任何<code class="eh lo lp lq lr b">payable</code>的契约不能接收任何ETH，除非从另一个契约中使用<code class="eh lo lp lq lr b">selfdestruct</code>并将目标契约<code class="eh lo lp lq lr b">payable</code>地址作为参数。</li><li id="30fa" class="ls lt ht ji b jj mo jn mp jr mq jv mr jz ms kd lx ly lz ma dt translated">有几种方法可以做到这一点，<code class="eh lo lp lq lr b">ForceAttack.sol</code>是我对这个问题的解决方案。</li></ol><p id="872b" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu"> #8金库解决方案</strong></p><ol class=""><li id="6598" class="ls lt ht ji b jj jk jn jo jr lu jv lv jz lw kd lx ly lz ma dt translated"><code class="eh lo lp lq lr b">private</code>类型不代表你的状态别人看不出来。任何人都可以通过查看合同中的存储数据位置来读取您的数据。</li><li id="9f00" class="ls lt ht ji b jj mo jn mp jr mq jv mr jz ms kd lx ly lz ma dt translated">使用任何库，例如<code class="eh lo lp lq lr b">web3</code>并调用<code class="eh lo lp lq lr b">web3.eth.getStorageAt(&lt;contract address&gt;, &lt;location index&gt;)</code>，其中位置索引可以通过查看契约中的状态定义顺序来计算，索引指向存储槽，其中每个槽的大小为32字节，其中像<code class="eh lo lp lq lr b">boolean</code>一样共有&lt; 32字节的数据可以放入1个槽中。</li><li id="43c6" class="ls lt ht ji b jj mo jn mp jr mq jv mr jz ms kd lx ly lz ma dt translated">这将返回十六进制格式的数据，因为32个字节占据1个完整的槽，并且在<code class="eh lo lp lq lr b">bool</code>之后定义，它将占据下一个槽，在这种情况下是在索引1处。</li><li id="b2af" class="ls lt ht ji b jj mo jn mp jr mq jv mr jz ms kd lx ly lz ma dt translated">密码是“一个非常强的秘密密码:)”</li></ol><p id="e7ea" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu"> #9王者解决</strong></p><ol class=""><li id="c9b9" class="ls lt ht ji b jj jk jn jo jr lu jv lv jz lw kd lx ly lz ma dt translated"><code class="eh lo lp lq lr b">King.sol</code>容易受到拒绝服务攻击，因为使用<code class="eh lo lp lq lr b">payable(king).transfer(msg.value);</code>行并要求前面的<code class="eh lo lp lq lr b">king</code>接收ETH否则它不会被改变。</li><li id="76ae" class="ls lt ht ji b jj mo jn mp jr mq jv mr jz ms kd lx ly lz ma dt translated">通过使用不具有<code class="eh lo lp lq lr b">receive</code>功能的合同攻击合同，<code class="eh lo lp lq lr b">King.sol</code>将停止运行。为了减轻这种情况，总是优先选择拉式方法，而不是推式方法。</li></ol><p id="e2a8" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu"> #10重入解决方案</strong></p><ol class=""><li id="b387" class="ls lt ht ji b jj jk jn jo jr lu jv lv jz lw kd lx ly lz ma dt translated">由于滥用<code class="eh lo lp lq lr b">receive</code>和<code class="eh lo lp lq lr b">fallback</code>函数发生重入，重新进入函数调用，直到耗尽所有资金。</li><li id="7cec" class="ls lt ht ji b jj mo jn mp jr mq jv mr jz ms kd lx ly lz ma dt translated"><code class="eh lo lp lq lr b">ReentrancyAttack.sol</code>中提供的解决方案</li></ol><p id="5665" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu"> #11电梯解决方案</strong></p><ol class=""><li id="e1e3" class="ls lt ht ji b jj jk jn jo jr lu jv lv jz lw kd lx ly lz ma dt translated">在<code class="eh lo lp lq lr b">Elevator.sol</code>中定义了<code class="eh lo lp lq lr b">Building</code>接口，并使用该接口的外部实现在执行某些逻辑之前进行检查。这使得<code class="eh lo lp lq lr b">Elevator.sol</code>易受攻击，因为任何人都可以为<code class="eh lo lp lq lr b">Building</code>实现提供恶意逻辑。</li><li id="1d52" class="ls lt ht ji b jj mo jn mp jr mq jv mr jz ms kd lx ly lz ma dt translated"><code class="eh lo lp lq lr b">Building.sol</code>实现恶意检查，绕过第一次检查，在第二次检查时改变值。</li></ol><p id="3cd9" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu"> #12隐私解决方案</strong></p><ol class=""><li id="5687" class="ls lt ht ji b jj jk jn jo jr lu jv lv jz lw kd lx ly lz ma dt translated">类型并不意味着你的状态不能被其他人阅读。任何人都可以通过查看合同中的存储数据位置来读取您的数据。</li><li id="2bb5" class="ls lt ht ji b jj mo jn mp jr mq jv mr jz ms kd lx ly lz ma dt translated">使用任何库，例如<code class="eh lo lp lq lr b">web3</code>并调用<code class="eh lo lp lq lr b">web3.eth.getStorageAt(&lt;contract address&gt;, &lt;location index&gt;)</code>，其中位置索引可以通过查看契约中的状态定义顺序来计算，索引指向存储槽，其中每个槽的大小为32字节，其中像<code class="eh lo lp lq lr b">boolean</code>和<code class="eh lo lp lq lr b">uint8</code>这样总共有&lt; 32字节的数据可以放入1个槽中。</li><li id="ea97" class="ls lt ht ji b jj mo jn mp jr mq jv mr jz ms kd lx ly lz ma dt translated">这将返回十六进制格式的数据，因为32个字节占用1个完整的槽，连续地在槽1用<code class="eh lo lp lq lr b">bool public locked</code>填充存储器，在槽2用<code class="eh lo lp lq lr b">uint256 public ID</code>填充存储器，在槽3用<code class="eh lo lp lq lr b">uint8 private denomination</code>和<code class="eh lo lp lq lr b">uint16 private awkwardness</code>填充存储器，在槽4-5-6用<code class="eh lo lp lq lr b">bytes32[3] private data</code>填充存储器。和索引5处的槽6处的<code class="eh lo lp lq lr b">data[2]</code>。</li><li id="fed5" class="ls lt ht ji b jj mo jn mp jr mq jv mr jz ms kd lx ly lz ma dt translated"><code class="eh lo lp lq lr b">await web3.eth.getStorageAt("0xd533a94194d7DcdD6fAa5b426e97d701ec5A7Ea7", 5)</code>将返回<code class="eh lo lp lq lr b">bytes32</code></li><li id="f2be" class="ls lt ht ji b jj mo jn mp jr mq jv mr jz ms kd lx ly lz ma dt translated">当你把它转换成16个字节时，solidity会从右边去掉16个字节(或者32个十六进制数字)。当bytesX转换为bytesY时，其中y &lt; x then x is truncated from the right hand side till the length in bytes is equal to y.</li><li id="e3be" class="ls lt ht ji b jj mo jn mp jr mq jv mr jz ms kd lx ly lz ma dt translated">resulting  【T20】   【T21】  is "0x48f9eabfc45106012bae40ff2c23104f" in this case.</li></ol><p id="a3bb" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu"> #13 GateKeeperOne解</strong></p><ol class=""><li id="cda8" class="ls lt ht ji b jj jk jn jo jr lu jv lv jz lw kd lx ly lz ma dt translated">我们需要传递三个修饰符，让我们逐一检查</li><li id="da78" class="ls lt ht ji b jj mo jn mp jr mq jv mr jz ms kd lx ly lz ma dt translated">第一个修饰符相对简单，因为我们以前遇到过，我们必须通过契约调用这个函数，所以<code class="eh lo lp lq lr b">msg.sender</code>和<code class="eh lo lp lq lr b">tx.origin</code>会有所不同:</li></ol><pre class="mb mc md me fq mf lr mg bn mh mi bi"><span id="1a8d" class="mj kp ht lr b be mk ml l mm mn">modifier gateOne() {<br/>        require(msg.sender != tx.origin);<br/>        _;<br/>    }</span></pre><p id="b472" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">3.第二个修饰符，这个比较棘手，要通过Gate 2的<code class="eh lo lp lq lr b">require(msg.gas % 8191 == 0)</code>，你必须确保你的剩余gas是8191的整数倍，在调用栈中执行<code class="eh lo lp lq lr b">msg.gas % 8191</code>的特定时刻。在这种情况下，您可以手动计算(需要时间)或只是蛮力，直到您通过计算。</p><pre class="mb mc md me fq mf lr mg bn mh mi bi"><span id="806a" class="mj kp ht lr b be mk ml l mm mn">for (uint256 i = 0; i &lt;= 8191; i++) {<br/>            try gate.enter{gas: 800000 + i}(_key) {<br/>                // console.log("passed with gas -&gt;", 800000 + i);<br/>                break;<br/>            } catch {}<br/>        }</span></pre><p id="f994" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">4.第三个修饰语，我们需要理解数据转换和字节屏蔽是如何对可靠性起作用的，我发现这篇文章在这个<a class="ae jf" rel="noopener" href="/coinmonks/ethernaut-lvl-13-gatekeeper-1-walkthrough-how-to-calculate-smart-contract-gas-consumption-and-eb4b042d3009">链接</a>中真的很有帮助。</p><p id="b00f" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这意味着整数键在转换成各种字节大小时，需要满足以下属性:</p><ul class=""><li id="4d5a" class="ls lt ht ji b jj jk jn jo jr lu jv lv jz lw kd mt ly lz ma dt translated">0x11111111 == 0x1111，仅当该值被0x0000FFFF屏蔽时才有可能</li><li id="2bce" class="ls lt ht ji b jj mo jn mp jr mq jv mr jz ms kd mt ly lz ma dt translated">0x1111111100001111！= 0x00001111，这只有在使用掩码0xFFFFFFFF0000FFFF保留前面的值时才有可能</li><li id="eef7" class="ls lt ht ji b jj mo jn mp jr mq jv mr jz ms kd mt ly lz ma dt translated">使用0xFFFFFFFF0000FFFF掩码计算密钥:</li></ul><pre class="mb mc md me fq mf lr mg bn mh mi bi"><span id="a914" class="mj kp ht lr b be mk ml l mm mn">bytes8 _key = bytes8(uint64(uint160(tx.origin))) &amp; 0xFFFFFFFF0000FFFF;</span></pre><p id="9912" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu"># 14 gatekeeperttwo解决方案</strong></p><ol class=""><li id="5701" class="ls lt ht ji b jj jk jn jo jr lu jv lv jz lw kd lx ly lz ma dt translated">我们需要传递三个修饰符，让我们逐一检查</li><li id="ebc4" class="ls lt ht ji b jj mo jn mp jr mq jv mr jz ms kd lx ly lz ma dt translated">第一个修饰符，相对简单，因为我们以前遇到过，我们必须通过契约调用这个函数，所以<code class="eh lo lp lq lr b">msg.sender</code>和<code class="eh lo lp lq lr b">tx.origin</code>会有所不同:</li></ol><pre class="mb mc md me fq mf lr mg bn mh mi bi"><span id="aba1" class="mj kp ht lr b be mk ml l mm mn">modifier gateOne() {<br/>        require(msg.sender != tx.origin);<br/>        _;<br/>    }</span></pre><p id="a4c8" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">3.第二个修饰符，为了通过Gate 2，我们必须以某种方式通过等于0的代码大小检查，但是我们通过一个将导致&gt; 0的契约来调用它。使契约代码大小为0的一种方法是通过<code class="eh lo lp lq lr b">selfdesctruct</code>，但是在函数中调用它之后不会调用任何一行代码。我们必须调用<code class="eh lo lp lq lr b">constructor</code>内部的函数，因为在这个初始化阶段，代码大小当前不存在。</p><pre class="mb mc md me fq mf lr mg bn mh mi bi"><span id="9bdf" class="mj kp ht lr b be mk ml l mm mn">constructor(address _gateAddress) {<br/>        gateKeeper = GatekeeperTwo(_gateAddress);<br/>        bytes8 _key = ~bytes8(keccak256(abi.encodePacked(address(this))));<br/>        gateKeeper.enter(_key);<br/>    }</span></pre><p id="3cd6" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">4.第三个修饰符，我们需要理解数据转换和位运算符，为了使值等于<code class="eh lo lp lq lr b">type(uint64).max</code>，我们需要用<code class="eh lo lp lq lr b">1</code>值填充每一位。如果两个运算符的值是<code class="eh lo lp lq lr b">1</code>和<code class="eh lo lp lq lr b">0</code>或<code class="eh lo lp lq lr b">0</code>和<code class="eh lo lp lq lr b">1</code>，则XOR按位将等于<code class="eh lo lp lq lr b">1</code>。我们可以这样做:</p><pre class="mb mc md me fq mf lr mg bn mh mi bi"><span id="f8e0" class="mj kp ht lr b be mk ml l mm mn">bytes8 _key = ~bytes8(keccak256(abi.encodePacked(address(this))));</span></pre><p id="c7c6" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><code class="eh lo lp lq lr b">bytes8(keccak256(abi.encodePacked(address(this))))</code>与其自身异或的按位非结果将导致所有位等于<code class="eh lo lp lq lr b">1</code>或<code class="eh lo lp lq lr b">type(uint64).max</code>。</p><p id="fc04" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu"> #15奈替考因溶液</strong></p><ol class=""><li id="a92c" class="ls lt ht ji b jj jk jn jo jr lu jv lv jz lw kd lx ly lz ma dt translated">乍一看，这个契约似乎阻止你转移任何值，因为<code class="eh lo lp lq lr b">transfer</code>函数是时间锁定的。但是如果你在https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md看到ERC20规格。有一种方法可以使用<code class="eh lo lp lq lr b">transferFrom</code>和<code class="eh lo lp lq lr b">approve</code>功能代表其他人(消费者)转移您的ERC20令牌。</li><li id="1ca8" class="ls lt ht ji b jj mo jn mp jr mq jv mr jz ms kd lx ly lz ma dt translated">首先，您批准其他地址作为最大值的支出者</li></ol><pre class="mb mc md me fq mf lr mg bn mh mi bi"><span id="d3c4" class="mj kp ht lr b be mk ml l mm mn">contract.approve("0xD1973282641fb3BAFa7eD2a82E82E3772b558a79","1000000000000000000000000")</span></pre><p id="a8c2" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">3.然后，spender将所有值从<code class="eh lo lp lq lr b">player</code>地址转移到其他地址。</p><pre class="mb mc md me fq mf lr mg bn mh mi bi"><span id="4b90" class="mj kp ht lr b be mk ml l mm mn">myContract.methods<br/>  .transferFrom(<br/>    "0xcdfB0772A328da9044D5bfD2D51A47230C9873A4",<br/>    "0xD1973282641fb3BAFa7eD2a82E82E3772b558a79",<br/>    "1000000000000000000000000"<br/>  )<br/>  .send();</span></pre><p id="d405" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu"> #16保存液</strong></p><ol class=""><li id="ef18" class="ls lt ht ji b jj jk jn jo jr lu jv lv jz lw kd lx ly lz ma dt translated"><code class="eh lo lp lq lr b">delegatecall</code>正在使用当前合同地址执行目标地址的逻辑。从而在使用目标地址的引用时修改当前契约中的存储槽和状态。</li><li id="68ae" class="ls lt ht ji b jj mo jn mp jr mq jv mr jz ms kd lx ly lz ma dt translated"><code class="eh lo lp lq lr b">uint storedTime</code>在位于存储槽1的<code class="eh lo lp lq lr b">LibraryContract</code>处，使用<code class="eh lo lp lq lr b">Preservation</code>契约中的<code class="eh lo lp lq lr b">delegatecall</code>不是修改<code class="eh lo lp lq lr b">storedTime</code>，而是改变<code class="eh lo lp lq lr b">address public timeZone1Library</code>，因为它也在存储槽1处(上下文仍使用调用者契约)。攻击者可以使用修改后的<code class="eh lo lp lq lr b">setTime(uint256)</code>函数添加恶意合同地址，该函数可以改变<code class="eh lo lp lq lr b">owner</code>，如<code class="eh lo lp lq lr b">LibraryContractAttack.sol</code>所示。</li></ol><p id="fa2a" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu"> #17恢复解决方案</strong></p><ol class=""><li id="3985" class="ls lt ht ji b jj jk jn jo jr lu jv lv jz lw kd lx ly lz ma dt translated">合同地址是确定的，您可以使用以下公式来重新计算地址:</li></ol><pre class="mb mc md me fq mf lr mg bn mh mi bi"><span id="691a" class="mj kp ht lr b be mk ml l mm mn">address = sha3(rlp_encode(creator_account, creator_account_nonce))[12:]</span></pre><p id="a098" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">或者你可以直接浏览ethscan来搜索目标合同地址。</p><p id="c8eb" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu"> #18魔术数字解决方案</strong></p><ol class=""><li id="ef9e" class="ls lt ht ji b jj jk jn jo jr lu jv lv jz lw kd lx ly lz ma dt translated">要解决这个问题，我们必须了解https://ethereum.org/en/developers/docs/evm/opcodes/中EVM的基本操作码:<a class="ae jf" href="https://ethereum.org/en/developers/docs/evm/opcodes/" rel="noopener ugc nofollow" target="_blank"/></li><li id="488e" class="ls lt ht ji b jj mo jn mp jr mq jv mr jz ms kd lx ly lz ma dt translated">有10个操作码的大小限制，为了解决这个问题，我们创建了两组字节码:</li></ol><ul class=""><li id="ba2c" class="ls lt ht ji b jj jk jn jo jr lu jv lv jz lw kd mt ly lz ma dt translated">初始化字节码:它负责准备契约并返回运行时字节码。</li><li id="8689" class="ls lt ht ji b jj mo jn mp jr mq jv mr jz ms kd mt ly lz ma dt translated">运行时字节码:这是契约创建后实际运行的代码。换句话说，这包含了契约的逻辑。</li></ul><p id="b932" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">3.运行时字节码，从<code class="eh lo lp lq lr b">runtime.txt</code>可用的操作码创建:</p><pre class="mb mc md me fq mf lr mg bn mh mi bi"><span id="e388" class="mj kp ht lr b be mk ml l mm mn">PUSH 0x2A  // push the requested value 42<br/>PUSH 0x80  // location of storage, could be any<br/>MSTORE     // store to memory<br/>PUSH 32   // length of offset<br/>PUSH 0x80   // value stored at slot 0x80 from code above<br/>RETURN</span></pre><p id="c98b" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">然后使用<code class="eh lo lp lq lr b">evm compile runtime.txt</code>进行编译</p><p id="c539" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">4.Init bycode，从<code class="eh lo lp lq lr b">init.txt</code>可用的操作码创建。这些将负责在内存中加载我们的运行时操作码，并将其返回给EVM。</p><p id="2455" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">要复制代码，我们需要使用CODECOPY(t，f，s)操作码，它有3个参数。</p><p id="cd3a" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">t:代码在内存中的目标偏移量。我们将其保存到0x00偏移量。</p><p id="e20b" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">f:这是目前未知的运行时操作码的当前位置。</p><p id="e264" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">s:这是以字节为单位的运行时代码的大小，即602 a60805260206080 F3–10字节长。：</p><pre class="mb mc md me fq mf lr mg bn mh mi bi"><span id="aa85" class="mj kp ht lr b be mk ml l mm mn">PUSH 0x0A // the 10 bytes long<br/>PUSH 0x0c // the current position of runtime opcode<br/>PUSH 0x00 // start<br/>CODECOPY<br/>PUSH 0x0A // the 10 bytes length<br/>PUSH 0x00 // value stored start at slot 0<br/>RETURN</span></pre><p id="7921" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">然后使用<code class="eh lo lp lq lr b">evm compile init.txt</code>进行编译</p><p id="b4a9" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">5.组合字节码<code class="eh lo lp lq lr b">&lt;initcode&gt;+&lt;runtimecode&gt;</code>，例如<code class="eh lo lp lq lr b">600a600c600039600a6000f3 + 602a60505260206050f3</code>到<code class="eh lo lp lq lr b">600a600c600039600a6000f3602a60505260206050f3</code></p><p id="67a4" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">6.使用<code class="eh lo lp lq lr b">create</code>命令创建合同，脚本在<code class="eh lo lp lq lr b">MagicNumSend.sol</code>可用。</p><p id="b297" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu"> #19 AlienCodex解决方案</strong></p><ol class=""><li id="7656" class="ls lt ht ji b jj jk jn jo jr lu jv lv jz lw kd lx ly lz ma dt translated">要通过这个挑战，我们必须理解几个概念:</li></ol><ul class=""><li id="0ac1" class="ls lt ht ji b jj jk jn jo jr lu jv lv jz lw kd mt ly lz ma dt translated">布局存储一般从<a class="ae jf" href="https://docs.soliditylang.org/en/v0.8.17/internals/layout_in_storage.html" rel="noopener ugc nofollow" target="_blank">这个资源</a>开始。</li><li id="8743" class="ls lt ht ji b jj mo jn mp jr mq jv mr jz ms kd mt ly lz ma dt translated">Layout storage for inheritance = &gt;从左到右从所有继承契约开始，最后是实际契约。</li><li id="fadb" class="ls lt ht ji b jj mo jn mp jr mq jv mr jz ms kd mt ly lz ma dt translated">动态数组的布局存储= &gt;假设在应用存储布局规则后，映射或数组的存储位置最终是一个槽p。数组数据从<code class="eh lo lp lq lr b">keccak256(p)</code>开始定位，其布局方式与静态大小的数组数据相同:一个元素接一个元素，如果元素长度不超过16个字节，则可能共享存储槽。</li></ul><p id="f171" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">2.从这些概念中，我们可以知道从<code class="eh lo lp lq lr b">Ownable</code>契约继承的<code class="eh lo lp lq lr b">owner</code>变量位于存储槽1(索引0)，与<code class="eh lo lp lq lr b">contact</code>布尔值共享。</p><p id="2971" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">3.这个契约使用旧的编译器版本，不使用SafeMath检查，我们可以通过调用<code class="eh lo lp lq lr b">retract</code>来减少<code class="eh lo lp lq lr b">codex</code>数组长度，直到它下溢到最大值。</p><p id="09f1" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">4.我们知道<code class="eh lo lp lq lr b">p</code>对于<code class="eh lo lp lq lr b">codex</code>是1，并且<code class="eh lo lp lq lr b">keccak256(p)</code>可以被计算，在这种情况下是<code class="eh lo lp lq lr b">80084422859880547211683076133703299733277748156566366325829078699459944778998</code>，这个存储槽被<code class="eh lo lp lq lr b">codex</code>用来指向它的第一个索引。</p><p id="b654" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">5.每个合同中的存储槽最大为2个⁵⁶，我们可以在索引2^256 - <code class="eh lo lp lq lr b">keccak256(p)</code> = <code class="eh lo lp lq lr b">35707666377435648211887908874984608119992236509074197713628505308453184860938</code>处设置<code class="eh lo lp lq lr b">codex</code>，由于溢出，它将与<code class="eh lo lp lq lr b">owner</code>指向同一个存储槽。</p><p id="a7aa" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu"> #20否认解决方案</strong></p><ol class=""><li id="5648" class="ls lt ht ji b jj jk jn jo jr lu jv lv jz lw kd lx ly lz ma dt translated">要拒绝<code class="eh lo lp lq lr b">Denial</code>契约，我们可以创建一个<code class="eh lo lp lq lr b">DenialAttack</code>契约作为合作伙伴，其中在<code class="eh lo lp lq lr b">receive</code>回退中，我们定义了无限循环，导致呼叫总是没油。</li></ol><pre class="mb mc md me fq mf lr mg bn mh mi bi"><span id="8b83" class="mj kp ht lr b be mk ml l mm mn">receive() external payable {<br/>        uint here = 0;<br/>        while (true) {<br/>            // forever in here<br/>            here++;<br/>        }<br/>    }</span></pre><p id="5ed5" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">网站注释:</p><p id="b554" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如果在外部调用回复时使用低级别调用继续执行，请确保指定固定的gas津贴。比如<code class="eh lo lp lq lr b">call.gas(100000).value()</code>。</p><p id="d26c" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">通常应该遵循checks-effects-interactions模式来避免重入攻击，但是也有其他情况(比如函数末尾的多个外部调用)会出现这样的问题。</p><p id="bedb" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">注意:外部通话最多可以使用通话时当前可用气体的63/64。因此，根据完成一个事务需要多少gas，足够高gas的事务(即，1/64的gas能够完成父调用中剩余的操作码的事务)可以用来减轻这种特定攻击。</p><p id="14ad" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu"> #21车间解决方案</strong></p><ol class=""><li id="e09c" class="ls lt ht ji b jj jk jn jo jr lu jv lv jz lw kd lx ly lz ma dt translated"><code class="eh lo lp lq lr b">view</code>函数被限制为只能读取和返回值，但是我们可以滥用<code class="eh lo lp lq lr b">Shop</code>契约上的<code class="eh lo lp lq lr b">isSold</code>状态改变，在<code class="eh lo lp lq lr b">isSold</code>改变之前，我们返回高值，在它改变之后，我们返回低价。</li></ol><pre class="mb mc md me fq mf lr mg bn mh mi bi"><span id="e8eb" class="mj kp ht lr b be mk ml l mm mn">function price() external view returns (uint) {<br/>        if (shop.isSold()) {<br/>            return 10;<br/>        } else {<br/>            return 10000;<br/>        }<br/>    }</span></pre><p id="4f42" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这可能是因为在我们分配新的<code class="eh lo lp lq lr b">price</code>值之前<code class="eh lo lp lq lr b">isSold</code>发生了变化。</p><pre class="mb mc md me fq mf lr mg bn mh mi bi"><span id="f5e3" class="mj kp ht lr b be mk ml l mm mn">if (_buyer.price() &gt;= price &amp;&amp; !isSold) {<br/>      isSold = true;<br/>      price = _buyer.price();<br/>    }</span></pre><p id="8019" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu"> #22地塞米松溶液</strong></p><ol class=""><li id="4714" class="ls lt ht ji b jj jk jn jo jr lu jv lv jz lw kd lx ly lz ma dt translated">为了滥用这个指标，我们可以注意到，通过在令牌1和令牌2之间摇摆交易，可以滥用和操纵<code class="eh lo lp lq lr b">getSwapPrice</code>,直到其中一个令牌完全耗尽。</li></ol><pre class="mb mc md me fq mf lr mg bn mh mi bi"><span id="7ad9" class="mj kp ht lr b be mk ml l mm mn">function getSwapPrice(address from, address to, uint amount) public view returns(uint){<br/>    return((amount * IERC20(to).balanceOf(address(this)))/IERC20(from).balanceOf(address(this)));<br/>  }</span></pre><p id="5094" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu"> #23地塞米松溶液</strong></p><ol class=""><li id="ff44" class="ls lt ht ji b jj jk jn jo jr lu jv lv jz lw kd lx ly lz ma dt translated"><code class="eh lo lp lq lr b">DexTwo</code>合同不限制可以<code class="eh lo lp lq lr b">swap</code>的ERC20对。所以我们可以创建恶意的ERC20，发送流动性到<code class="eh lo lp lq lr b">DexTwo</code>地址，给<code class="eh lo lp lq lr b">allowance</code>给它。</li><li id="1894" class="ls lt ht ji b jj mo jn mp jr mq jv mr jz ms kd lx ly lz ma dt translated">我们可以用这个恶意的ERC 20<code class="eh lo lp lq lr b">swap</code><code class="eh lo lp lq lr b">token1</code>和<code class="eh lo lp lq lr b">token2</code>。</li></ol><p id="ef04" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu"> #24难题钱包解决方案</strong></p><ol class=""><li id="8779" class="ls lt ht ji b jj jk jn jo jr lu jv lv jz lw kd lx ly lz ma dt translated">为了解决这个挑战，你必须从<a class="ae jf" href="https://docs.openzeppelin.com/contracts/3.x/api/proxy#UpgradeableProxy" rel="noopener ugc nofollow" target="_blank">这个资源</a>中理解代理契约的概念。</li><li id="af9b" class="ls lt ht ji b jj mo jn mp jr mq jv mr jz ms kd lx ly lz ma dt translated">代理契约负责存储和委托调用逻辑或实现契约，代理和实现契约的存储指针必须指向相同的信息。但是您可以看到在<code class="eh lo lp lq lr b">PuzzleProxy</code>和<code class="eh lo lp lq lr b">PuzzleWallet</code>中，存储布局引用了不同的内容。</li></ol><p id="1e52" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">储存在<code class="eh lo lp lq lr b">PuzzleProxy</code>:</p><pre class="mb mc md me fq mf lr mg bn mh mi bi"><span id="d3a5" class="mj kp ht lr b be mk ml l mm mn">contract PuzzleProxy is UpgradeableProxy {<br/>    address public pendingAdmin;<br/>    address public admin;<br/>..<br/>    }</span></pre><p id="232b" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在<code class="eh lo lp lq lr b">PuzzleWallet</code>的存储:</p><pre class="mb mc md me fq mf lr mg bn mh mi bi"><span id="ee9d" class="mj kp ht lr b be mk ml l mm mn">contract PuzzleWallet {<br/>    address public owner;<br/>    uint256 public maxBalance;<br/>    mapping(address =&gt; bool) public whitelisted;<br/>    mapping(address =&gt; uint256) public balances;<br/>    ..<br/>    }</span></pre><p id="f664" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">3.首先你调用<code class="eh lo lp lq lr b">proposeNewAdmin</code>，这将改变<code class="eh lo lp lq lr b">PuzzleProxy</code>的<code class="eh lo lp lq lr b">pendingAdmin</code>和<code class="eh lo lp lq lr b">PuzzleWallet</code>的<code class="eh lo lp lq lr b">owner</code></p><p id="ecc2" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">4.现在你是<code class="eh lo lp lq lr b">PuzzleWallet</code>的所有者，可以打电话给<code class="eh lo lp lq lr b">addToWhitelist</code>，在这里添加你的合同地址或你的EOA。</p><p id="eb58" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">5.要更改<code class="eh lo lp lq lr b">PuzzleProxy</code>的<code class="eh lo lp lq lr b">admin</code>的所有者，我们必须在<code class="eh lo lp lq lr b">PuzzleWallet</code>上更改<code class="eh lo lp lq lr b">maxBalance</code>，但是要调用<code class="eh lo lp lq lr b">setMaxBalance</code>我们必须以某种方式耗尽合同余额。我们可以通过提供嵌套的<code class="eh lo lp lq lr b">multicall</code>数组来调用<code class="eh lo lp lq lr b">PuzzleWallet</code>中的<code class="eh lo lp lq lr b">multicall</code>来绕过<code class="eh lo lp lq lr b">deposit</code>检查。这样我们可以只提供<code class="eh lo lp lq lr b">0.001 eth</code>而记录为<code class="eh lo lp lq lr b">0.002 eth</code>。</p><p id="cf0d" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">6.通过调用<code class="eh lo lp lq lr b">execute</code>和<code class="eh lo lp lq lr b">setMaxBalance</code>清空余额。</p><pre class="mb mc md me fq mf lr mg bn mh mi bi"><span id="d756" class="mj kp ht lr b be mk ml l mm mn">function attack() external payable {<br/>        //creating encoded function data<br/>        bytes[] memory depositSelector = new bytes[](1);<br/>        depositSelector[0] = abi.encodeWithSelector(wallet.deposit.selector);<br/>        bytes[] memory nestedMulticall = new bytes[](2);<br/>        nestedMulticall[0] = abi.encodeWithSelector(wallet.deposit.selector);<br/>        nestedMulticall[1] = abi.encodeWithSelector(<br/>            wallet.multicall.selector,<br/>            depositSelector<br/>        );<br/>//calling multicall with nested data stored above, value set to 0.001 eth<br/>        wallet.multicall{value: msg.value}(nestedMulticall);<br/>        //calling execute to drain the contract<br/>        wallet.execute(msg.sender, 0.002 ether, "");<br/>        //calling setMaxBalance with our address to become the admin of proxy<br/>        wallet.setMaxBalance(uint256(uint160(msg.sender)));<br/>        //making sure our exploit worked<br/>    }</span></pre><p id="fc53" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu"> #25摩托车解决方案</strong></p><ol class=""><li id="4018" class="ls lt ht ji b jj jk jn jo jr lu jv lv jz lw kd lx ly lz ma dt translated">要解决这个问题，您必须了解UUPS代理升级模式、eip1967和可初始化的契约</li><li id="d664" class="ls lt ht ji b jj mo jn mp jr mq jv mr jz ms kd lx ly lz ma dt translated">我们可以看到<code class="eh lo lp lq lr b">Engine</code>有可初始化的函数，其行为类似于可升级模式的构造函数，但它是从<code class="eh lo lp lq lr b">Motorbike</code>上下文中调用的(delegatecall行为)。所以如果能找到<code class="eh lo lp lq lr b">Engine</code>合同地址，直接调用<code class="eh lo lp lq lr b">initialize</code>就可以了。</li><li id="d2c2" class="ls lt ht ji b jj mo jn mp jr mq jv mr jz ms kd lx ly lz ma dt translated">然后我们可以使用实现地址直接调用<code class="eh lo lp lq lr b">upgradeToAndCall</code>并指向有<code class="eh lo lp lq lr b">selfdestruct</code>的恶意契约，它将使用<code class="eh lo lp lq lr b">delegatecall</code>调用并销毁<code class="eh lo lp lq lr b">Engine</code>契约。</li></ol><p id="65ae" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu"> #26 GoodSamaritan解决方案</strong></p><ol class=""><li id="6b71" class="ls lt ht ji b jj jk jn jo jr lu jv lv jz lw kd lx ly lz ma dt translated">看看这个关于自定义错误的解释:<a class="ae jf" href="https://blog.soliditylang.org/2021/04/21/custom-errors/" rel="noopener ugc nofollow" target="_blank">https://blog.soliditylang.org/2021/04/21/custom-errors/</a></li></ol><pre class="mb mc md me fq mf lr mg bn mh mi bi"><span id="896b" class="mj kp ht lr b be mk ml l mu mn"><em class="mv">Please be careful when using error data since its origin is not tracked. <br/>The error data by default bubbles up through the chain of external calls, <br/>which means that a contract may forward an error not defined in any of <br/>the contracts it calls directly. Furthermore, any contract can fake any<br/> error by returning data that matches an error signature, even if the error<br/> is not defined anywhere.</em></span></pre><p id="1042" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">2.当调用来自<code class="eh lo lp lq lr b">Coin</code>的<code class="eh lo lp lq lr b">transfer</code>函数时，我们可以滥用在<code class="eh lo lp lq lr b">requestDonation</code>函数中的这种自定义错误检查，因为如果<code class="eh lo lp lq lr b">_dest</code>参数是契约，它会通知回调。</p><pre class="mb mc md me fq mf lr mg bn mh mi bi"><span id="d264" class="mj kp ht lr b be mk ml l mm mn">function attack() external {<br/>        gs.requestDonation();<br/>    }<br/><br/>function notify(uint256 amount) external {<br/>        if (amount &lt;= 10) {<br/>            revert NotEnoughBalance();<br/>        }<br/>    }</span></pre><p id="200f" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">仅此而已。谢谢！</p><p id="1e54" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">完整代码解决方案回购:</p><div class="mw mx fm fo my mz"><a href="https://github.com/said017/ethereum-learning-notes/tree/main/ethernauts-solutions" rel="noopener  ugc nofollow" target="_blank"><div class="na ab ej"><div class="nb ab nc cl cj nd"><h2 class="bd hu fv z el ne eo ep nf er et hs dt translated">以太坊-学习-笔记/以太坊-主要解决方案said 017/以太坊-学习-笔记</h2><div class="ng l"><h3 class="bd b fv z el ne eo ep nf er et ek translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="nh l"><p class="bd b gc z el ne eo ep nf er et ek translated">github.com</p></div></div><div class="ni l"><div class="nj l nk nl nm ni nn iz mz"/></div></div></a></div><blockquote class="ke"><p id="995e" class="kf kg ht bd kh ki no np nq nr ns kd ek translated">加入Coinmonks <a class="ae jf" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae jf" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>了解加密交易和投资</p></blockquote><h1 id="efa4" class="nt kp ht bd kq nu nv nw ku nx ny nz ky oa ob oc lb od oe of le og oh oi lh oj dt translated">另外，阅读</h1><ul class=""><li id="676d" class="ls lt ht ji b jj lj jn lk jr ok jv ol jz om kd mt ly lz ma dt translated"><a class="ae jf" href="https://coincodecap.com/wazirx-nft-review" rel="noopener ugc nofollow" target="_blank">瓦济里克斯NFT评论</a> | <a class="ae jf" href="https://coincodecap.com/bitsgap-vs-pionex" rel="noopener ugc nofollow" target="_blank">比茨盖普vs皮奥克斯</a> | <a class="ae jf" href="https://coincodecap.com/tangem-wallet-review" rel="noopener ugc nofollow" target="_blank">坦吉姆评论</a></li><li id="b498" class="ls lt ht ji b jj mo jn mp jr mq jv mr jz ms kd mt ly lz ma dt translated"><a class="ae jf" href="https://coincodecap.com/create-a-dapp-on-ethereum-using-solidity" rel="noopener ugc nofollow" target="_blank">如何使用Solidity在以太坊上创建DApp？</a></li><li id="555a" class="ls lt ht ji b jj mo jn mp jr mq jv mr jz ms kd mt ly lz ma dt translated"><a class="ae jf" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a> | <a class="ae jf" href="https://coincodecap.com/okex-vs-binance" rel="noopener ugc nofollow" target="_blank"> OKEx vs币安</a></li><li id="2d8b" class="ls lt ht ji b jj mo jn mp jr mq jv mr jz ms kd mt ly lz ma dt translated"><a class="ae jf" href="https://coincodecap.com/binance-vs-ftx" rel="noopener ugc nofollow" target="_blank">币安vs FTX </a> | <a class="ae jf" href="https://coincodecap.com/solana-wallets" rel="noopener ugc nofollow" target="_blank">最佳(SOL)索拉纳钱包</a></li><li id="a926" class="ls lt ht ji b jj mo jn mp jr mq jv mr jz ms kd mt ly lz ma dt translated"><a class="ae jf" href="https://coincodecap.com/swap-crypto-on-uniswap" rel="noopener ugc nofollow" target="_blank">如何在Uniswap上交换加密？</a> | <a class="ae jf" href="https://coincodecap.com/a-ads-review" rel="noopener ugc nofollow" target="_blank"> A-Ads评论</a></li></ul></div></div>    
</body>
</html>