# 代理—透明代理模式& UUPS

> 原文：<https://medium.com/coinmonks/transparent-proxy-pattern-uups-d7416916789f?source=collection_archive---------5----------------------->

为了更好地理解代理模式，您应该知道代理是如何工作的。如果你不知道，这里的是我之前解释的帖子。好了，现在让我们把注意力放在这篇文章的主题上。

# 代理选择器冲突

由 4 字节标识符标识的智能合同公共接口的所有功能。如何获得这个标识符，我在[我之前的帖子](/coinmonks/ethernaut-delegation-dangerous-delegatecall-e6d7a759d4f9)中写了关于*委派*的内容。

只有 4 个字节，所以是(2 个)⁴ = 4096 个组合(因为 1 个字节= 8 个比特，一个比特可以设置为“1”或“0”，所以只有两个选项)。正如我们所看到的，我们的选择器的可能性很小，当我们将定义 4097 时，我们有 100%的最小值，两个函数有相同的选择器。但是没有必要定义这么多函数来让一个选择器同时适应两个函数。这个问题被称为代理选择器冲突。

为什么在这个问题的名称中我们会看到“代理”这个词，如果它甚至可以发生在一个不使用代理的普通智能合同中？答案很简单，在这种常见的智能合同中，我们不会遇到这种问题。这是因为，新版本的 Solidity 编译器检查每个函数是否有不同的标识符，如果没有，那么在编译过程中我们会看到一个错误。

那么，如果编译器保护我们免受这个问题的困扰，我们为什么还要为此烦恼呢？关键是代理的结构。当我们创建代理或代理的逻辑时，我们只编译其中之一。所以编译器不知道还有另一个契约，它也不能保护我们。因此，我们必须自己保护自己。

# 代理模式

所以代理选择器冲突是一个需要两个独立的智能契约的问题，因为在其中一个契约中，由于编译器的原因，我们不会拥有它。让我们想象这样一种情况，代理和逻辑的契约定义了同名的函数，并采用相同的参数。所以如果我们想调用这个函数，会有一个问题，它应该使用这个函数的哪一个。通常，它将使用代理契约中定义的函数，因为与逻辑的连接是通过*回退*实现的，当没有其他函数调用`sendvalue`时，就会调用该回退。所以，我们永远无法从逻辑契约中调用这个函数。当然，我们可以通过某种方式编写我们的代理契约，在逻辑内部使用这个函数，但是这样我们就不能在代理中使用这个函数了。此外，这种解决方案复杂且不灵活。因此，还有其他解决方案。

## 透明代理模式

这个模式使用`msg.sender`作为将使用哪个函数的键:这个来自代理或者这个来自逻辑。如果`msg.sender` 是代理管理员的地址，那么*delegate call 将不会调用任何函数。*如果`msg.sender`不等于 admin 的地址，那么代理只使用*delegate call*而不使用代理中定义的其他函数。这个简单的解决方案将逻辑从代理中分离出来，感谢我们没有代理选择器冲突。

## 通用可升级代理标准

UUPS 的工作方式类似于透明代理模式。我们使用`msg.sender`作为一个键，就像前面解释的模式一样。唯一的区别是我们将升级逻辑契约的函数放在哪里:在代理中还是在逻辑中。在透明代理模式中，升级的功能在代理的契约中，如何改变逻辑的方式对于所有逻辑的契约来说看起来是相同的。

它在 UUPS 中被改变。升级到新版本的功能是在逻辑的契约中实现的，因此升级的机制可能会随时间而改变。此外，如果新版本的逻辑没有升级机制，那么整个项目将是不可变的，并且无法更改。因此，如果你想使用这种模式，你应该非常小心，不要意外地剥夺了你升级的机会。

我希望这篇文章对你有用。如果你有任何想法，我如何能使我的帖子更好，请告诉我。我随时准备学习。你可以在 [LinkedIn](https://pl.linkedin.com/in/szymon-skrzy%C5%84ski-881462214) 和 [Telegram](https://t.me/eszymi) 上和我连线。

如果你想和我谈论这个话题或者我写的其他话题，请随意。我乐于交谈。

快乐学习！

> 交易新手？尝试[加密交易机器人](/coinmonks/crypto-trading-bot-c2ffce8acb2a)或[复制交易](/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c)