<html>
<head>
<title>Learn Solidity lesson 13. Storage, memory, calldata and the stack.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习第13课坚固性。存储、内存、调用数据和堆栈。</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/learn-solidity-lesson-13-storage-memory-calldata-and-the-stack-56342b6e5ed0?source=collection_archive---------0-----------------------#2022-08-02">https://medium.com/coinmonks/learn-solidity-lesson-13-storage-memory-calldata-and-the-stack-56342b6e5ed0?source=collection_archive---------0-----------------------#2022-08-02</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/0913722d3179fd93856c3308568249d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*j7YdZtJYSZvtjJcIekbCoQ.jpeg"/></div></div></figure><p id="bb90" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在本章中，我们将了解区块链上存储数据的位置。共有四个存储空间:<strong class="jd hu">存储</strong>、<strong class="jd hu">内存</strong>、<strong class="jd hu">堆栈</strong>和<strong class="jd hu"> calldata </strong>。</p><p id="328d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">存储器是存储状态变量的地方。记住我们在契约中声明状态变量，它们是永久的。我们在事务期间对状态变量所做的任何更改都会在事务结束后存储起来。</p><p id="416e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们可以把存储想象成一个数据库(事实上它是由数据库实现的)。存储就像一个键/值字典，键和值都是32字节长。</p><p id="13fc" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我将更详细地解释存储是如何工作的，但是如果你对存储是如何工作的细节不感兴趣，关于存储要记住的最重要的事情是它是一个永久的存储位置。</p><p id="c5e9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">记忆不是永久的。变量放在内存中，只在函数执行期间使用。在功能执行结束时，存储在存储器中的所有内容都将被删除。</p><p id="5af1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">Solidity可以访问内存，程序员既可以在内存中创建新变量，也可以读取和更改已经在内存中创建的变量。</p><p id="a705" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">Calldata是传递给函数的参数临时存储的地方。这不是一个我们可以创建变量的地方，因为它是函数参数所独有的。也不能更改calldata的值:它是只读的。</p><p id="ca04" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">最后，我们有了堆栈。正是在堆栈上进行EVM处理。EVM将信息放入堆栈或从堆栈中取出，通过操作堆栈中的信息来执行程序。Solidity没有对栈的访问权，除非我们想在底层编程，否则这个时候不需要太担心栈。</p><p id="8684" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当我们谈到在Solidity中使用汇编语言时，我们会对堆栈进行更多的研究，但这是一个更高级的主题。</p><h1 id="2eb9" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">仓库</h1><p id="3507" class="pw-post-body-paragraph jb jc ht jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy hm dt translated">存储器是存储状态变量的地方。在部署时，EVM在存储中为状态变量保留专用空间。该空间只能在部署时预留。</p><p id="7a4d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">因为契约的存储区域是在部署时定义的，所以状态变量只能在函数外部声明。执行功能时无法创建新的存储空间。</p><p id="d5f7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们看看下面的代码。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="3481" class="ll ka ht lh b fv lm ln l lo lp">contract Storage {<br/>   uint256 public value1;<br/>   uint128 public value2;<br/>   uint128 public value3;<br/>   string public value4;<br/>        <br/>   function newValue() public {<br/>      uint256 value5;<br/>   }<br/>}</span></pre><p id="6d66" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在函数外部，定义了四个状态变量:<code class="eh lq lr ls lh b">value1</code>、<code class="eh lq lr ls lh b">value2</code>、<code class="eh lq lr ls lh b">value3</code>和<code class="eh lq lr ls lh b">value4</code>。这些变量的值存储在存储器中，它们的值在部署时初始化。</p><p id="ec2e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">变量<code class="eh lq lr ls lh b">value5</code>是在函数内部定义的，所以它存储在内存中。一旦函数<code class="eh lq lr ls lh b">newValue</code>被调用，内存中的一个空间将被分配来存储变量<code class="eh lq lr ls lh b">value5</code>的值。当函数执行结束时，该值以及对它的任何引用都将从内存中删除。</p><p id="7380" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">存储是一个键/值数据库，其中键和值都是32字节长。存储器中的存储是顺序的，密钥从<code class="eh lq lr ls lh b">0</code>开始。让我们明白这一点。</p><p id="eb16" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们可以把存储器想象成一个充满编号容器的地方，大小固定为32字节。契约中定义的第一个状态变量是<code class="eh lq lr ls lh b">value1</code>，类型为uint256。它将被存储在第一个容器中，密钥为<code class="eh lq lr ls lh b">0</code>，并将占用其所有空间，因为uint256类型的长度为32个字节。</p><p id="1375" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">第二个变量<code class="eh lq lr ls lh b">value2</code>将存储在第二个容器中，键为<code class="eh lq lr ls lh b">1</code>。但是，由于它只占用16个字节(128位)，因此不会占用所有空间。下一个变量<code class="eh lq lr ls lh b">value3</code>也是uint128类型，也就是说，它也只占用16个字节。因为它“适合”第二个容器中剩余的空间，所以它也将被存储在第二个容器中。</p><p id="3843" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">而下一个变量，<code class="eh lq lr ls lh b">value4</code>？它属于字符串类型。这意味着它可以是从一个小单词到一个长文本的任何东西。也就是说，不可能事先知道它的大小。不可能知道它将占用多少集装箱。</p><p id="63ec" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这就是为什么字符串类型是引用类型，而不是值类型。第三个容器不会存储字符串值，但是会引用我们可以在哪里找到该字符串，以及它的长度。</p><h1 id="46fc" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">内存与存储</h1><p id="6185" class="pw-post-body-paragraph jb jc ht jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy hm dt translated">下面我们稍微修改一下上一个例子的功能。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="d6c8" class="ll ka ht lh b fv lm ln l lo lp">function newValue() public view returns(uint256) {<br/>   uint256 valueReturn = value1;<br/>   valueReturn = 10;<br/>   return valueReturn;<br/>}</span></pre><p id="4430" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当在函数中定义时，每个value类型的变量都被自动放入内存中。因此，变量<code class="eh lq lr ls lh b">returnValue</code>是内存中的变量，它采用状态变量<code class="eh lq lr ls lh b">value1</code>的值。</p><p id="4c28" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在下一行，变量<code class="eh lq lr ls lh b">returnValue</code>的值被设置为<code class="eh lq lr ls lh b">10</code>。由于变量在内存中，这个值在函数执行结束时被删除。变量<code class="eh lq lr ls lh b">value1</code>没有被修改，所以将这个函数声明为<em class="lt">视图</em>是完全合法的:它不改变任何状态变量。</p><p id="8b6c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在让我们修改函数，使用字符串类型的变量，而不是无符号整数类型的变量。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="7322" class="ll ka ht lh b fv lm ln l lo lp">function newValue() public view returns(string memory) {<br/>   string valueReturn = value4;<br/>   valueReturn = 'Hello World';<br/>   return valueReturn;<br/>}</span></pre><p id="6d31" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">尝试编译时，编译器会提示错误，如下图所示。</p><figure class="lc ld le lf fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff lu"><img src="../Images/fc43fe86a44d618dab341c09d5a6b644.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3LlXz_ETI-rQlQ_8snLaEQ.png"/></div></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">We must indicate the place where the variables of reference type are located.</figcaption></figure><p id="9d6d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">与总是放在内存中的值类型变量不同，引用类型的变量可以在内存、存储或calldata中。</p><p id="44dd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">指示变量<code class="eh lq lr ls lh b">returnValue </code>在内存中会在内存中创建一个新变量。让我们看看下面的代码。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="1a26" class="ll ka ht lh b fv lm ln l lo lp">function newValue() public view returns(string memory) {<br/>   string memory valueReturn = value4;<br/>   valueReturn = 'Hello World';<br/>   return valueReturn;<br/>}</span></pre><p id="2d36" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">以上函数完全合法，会编译。函数的返回将总是字符串<code class="eh lq lr ls lh b">‘Hello World’</code>。然而，如果我们指出变量<code class="eh lq lr ls lh b">returnValue</code>是存储类型的，我们将得到一个错误。将函数声明更改如下。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="b598" class="ll ka ht lh b fv lm ln l lo lp">string storage valueReturn = value4;</span></pre><p id="45c2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">上面的行是完全合法的，但是下一行将显示一个错误，如下图所示。</p><figure class="lc ld le lf fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff lz"><img src="../Images/6288abc999a68d31a4d12c55fb818c9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zwzWJ2VY5xjPdVMlqA4_NA.png"/></div></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">The variable returnValue is a pointer to the storage.</figcaption></figure><p id="a294" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">变量<code class="eh lq lr ls lh b">returnValue </code>是一个指针(引用)。它指示变量<code class="eh lq lr ls lh b">value4</code>的值在存储器中的位置。我们不能改变指针，只是使用它。下面的代码完全有效。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="773c" class="ll ka ht lh b fv lm ln l lo lp">function newValue() public view returns(string memory) {<br/>   string storage valueReturn = value4;<br/>   return valueReturn;<br/>}</span></pre><p id="5b90" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">返回的将是变量<code class="eh lq lr ls lh b">value4</code>的值。当然，在上面的情况下，直接返回变量<code class="eh lq lr ls lh b">value4</code>会更实际。</p><p id="a28f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在字符串的情况下，使用指向存储的指针不是很有用，但在处理更复杂的类型(如映射和数组)时会很有用。我们将在另一节课回到这个话题。</p><h1 id="fe8d" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">内存与呼叫数据</h1><p id="95b4" class="pw-post-body-paragraph jb jc ht jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy hm dt translated">内存是我们可以临时创建和存储变量的地方。Calldata是函数实时接收参数的地方。让我们看看下面的代码。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="f8d3" class="ll ka ht lh b fv lm ln l lo lp">function concatenate(string memory s1, string memory s2) public pure returns (string memory) {<br/>   return string.concat(s1, s2);<br/>}</span></pre><p id="e4c5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">函数<code class="eh lq lr ls lh b">concatenate </code>将两个字符串连接成一个。注意函数参数，<code class="eh lq lr ls lh b">s1</code>和<code class="eh lq lr ls lh b">s2</code>，我们表示在内存中。这样做时，我们在内存中创建变量<code class="eh lq lr ls lh b">s1</code>和<code class="eh lq lr ls lh b">s2</code>，并在函数中操作它们。让我们通过显式地改变变量<code class="eh lq lr ls lh b">s2.</code>来给上面的函数添加一个新行</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="d982" class="ll ka ht lh b fv lm ln l lo lp">function concatenate(string memory s1, string memory s2) public pure returns (string memory) {<br/>   s1 = "Hello";<br/>   return string.concat(s1, s2);<br/>}</span></pre><p id="0efd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">由于变量<code class="eh lq lr ls lh b">s1 </code>在内存中，我们可以随意改变它。现在让我们修改上面的函数，表明变量<code class="eh lq lr ls lh b">s1 </code>和<code class="eh lq lr ls lh b">s2 </code>指向calldata而不是内存。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="2d86" class="ll ka ht lh b fv lm ln l lo lp">function concatenate(string calldata s1, string calldata s2) public pure returns (string memory) {<br/>   s1 = "Hello";<br/>   return string.concat(s1, s2);<br/>}</span></pre><p id="f232" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">编译器现在将抛出一个错误，如下图所示。</p><figure class="lc ld le lf fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff ma"><img src="../Images/88a950a30195d8c7e12e38ac3044e6b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tTE0v7W5h0KQuR5JrqEf-A.png"/></div></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">Calldata is a read-only space.</figcaption></figure><p id="7e64" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">Calldata是一个只能读取，不能更改的存储空间，在上面的代码中我们试图显式修改它的值。这产生了一个错误。</p><p id="4b0c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">使用calldata的好处是，在很多情况下，我们不需要在内存中不必要地创建一个新变量。这可以节省汽油费，而这通常是智能合同开发中的一个关键要求。</p><p id="11a6" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">感谢阅读！</strong></p><p id="d88d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎对本文提出意见和建议。</p><p id="d129" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎任何投稿。<a class="ae mb" href="http://www.buymeacoffee.com/jpmorais" rel="noopener ugc nofollow" target="_blank">www.buymeacoffee.com/jpmorais</a></p><blockquote class="mc"><p id="b6d3" class="md me ht bd mf mg mh mi mj mk ml jy ek translated">交易新手？试试<a class="ae mb" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a>或者<a class="ae mb" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>