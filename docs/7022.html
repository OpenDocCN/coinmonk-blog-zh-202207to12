<html>
<head>
<title>Tx.origin Attack in Smart contract</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">智能合约中的Tx.origin攻击</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/tx-origin-attack-in-smart-contract-28a3f13d3445?source=collection_archive---------4-----------------------#2022-12-03">https://medium.com/coinmonks/tx-origin-attack-in-smart-contract-28a3f13d3445?source=collection_archive---------4-----------------------#2022-12-03</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="adc0" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">了解常见的智能合约漏洞。</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/a56d978228b3a9a03ea8ec608378b638.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HM5tX3coAAgaAYrv"/></div></div><figcaption class="ju jv fg fe ff jw jx bd b be z ek">Photo by <a class="ae jy" href="https://unsplash.com/@mbaumi?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mika Baumeister</a> on <a class="ae jy" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="dd9f" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">智能合约安全性:</h2><p id="c08d" class="pw-post-body-paragraph kx ky ht kz b la lb iu lc ld le ix lf kk lg lh li ko lj lk ll ks lm ln lo lp hm dt translated">智能合同是一种软件，在满足特定标准时自动运行。因为智能合约是在分散的区块链网络上执行的，所以从设计上来说，它们被认为是安全的。但是，智能合约仍然容易受到某些安全风险的影响，如编码错误、恶意攻击和测试不足。为了降低安全问题的风险，遵循编写和部署智能协定的最佳实践非常重要，例如彻底测试代码、使用安全编码技术以及保持协定代码简单和模块化。定期审核智能合同以识别和解决任何潜在的漏洞也很重要。</p><h2 id="f6e6" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">刀客</h2><p id="c091" class="pw-post-body-paragraph kx ky ht kz b la lb iu lc ld le ix lf kk lg lh li ko lj lk ll ks lm ln lo lp hm dt translated">涉及智能合约的最大黑客攻击之一发生在2016年，当时分散自治组织(DAO)的智能合约代码中的一个漏洞被利用，导致价值约5000万美元的加密货币以太被盗。这次黑客攻击是由于DAO的智能合同中的一个编码错误造成的，该错误允许攻击者在未经许可的情况下多次从合同中提取资金。这一事件凸显了对智能合约代码进行彻底测试和审计的必要性，以确保其安全且没有漏洞。</p><h1 id="5341" class="lq ka ht bd kb lr ls lt kf lu lv lw kj iz lx ja kn jc ly jd kr jf lz jg kv ma dt translated">智能合约中的常见漏洞:</h1><h2 id="ea7f" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">重入攻击</h2><p id="3c8c" class="pw-post-body-paragraph kx ky ht kz b la lb iu lc ld le ix lf kk lg lh li ko lj lk ll ks lm ln lo lp hm dt translated">当一个协定调用另一个协定，而第二个协定在第一个协定完成执行之前回调到第一个协定时，就会发生可重入攻击。这可能导致意外行为和潜在的资金损失。</p><p id="2a82" class="pw-post-body-paragraph kx ky ht kz b la mb iu lc ld mc ix lf kk md lh li ko me lk ll ks mf ln lo lp hm dt translated">为了防止这种情况，Solidity提供了<code class="eh mg mh mi mj b">revert()</code>和<code class="eh mg mh mi mj b">require()</code>功能，如果没有满足指定的条件，这些功能会暂停合同的执行，并恢复所做的任何更改。</p><p id="3e4a" class="pw-post-body-paragraph kx ky ht kz b la mb iu lc ld mc ix lf kk md lh li ko me lk ll ks mf ln lo lp hm dt translated">下面是一个容易受到可重入攻击的契约示例:</p><pre class="jj jk jl jm fq mk mj ml mm aw mn dt"><span id="cfe4" class="jz ka ht mj b fv mo mp l mq mr">contract ReentrancyAttack {<br/>    address public owner;<br/>    uint public balance;</span><span id="59ae" class="jz ka ht mj b fv ms mp l mq mr">    constructor() public {<br/>        owner = msg.sender;<br/>        balance = 100;<br/>    }</span><span id="80dc" class="jz ka ht mj b fv ms mp l mq mr">    function withdraw() public {<br/>        // vulnerable to reentrancy attack<br/>        if (balance &gt;= 10) {<br/>            balance -= 10;<br/>            msg.sender.transfer(10);<br/>        }<br/>    }<br/>}</span></pre><p id="746c" class="pw-post-body-paragraph kx ky ht kz b la mb iu lc ld mc ix lf kk md lh li ko me lk ll ks mf ln lo lp hm dt translated">为了防止这个漏洞，我们可以使用<code class="eh mg mh mi mj b">require()</code>函数在转账之前检查余额是否足够:</p><pre class="jj jk jl jm fq mk mj ml mm aw mn dt"><span id="bd1a" class="jz ka ht mj b fv mo mp l mq mr">contract ReentrancyAttack {<br/>    address public owner;<br/>    uint public balance;</span><span id="b6d3" class="jz ka ht mj b fv ms mp l mq mr">    constructor() public {<br/>        owner = msg.sender;<br/>        balance = 100;<br/>    }</span><span id="e362" class="jz ka ht mj b fv ms mp l mq mr">    function withdraw() public {<br/>        // prevent reentrancy attack<br/>        require(balance &gt;= 10, "Insufficient balance");<br/>        balance -= 10;<br/>        msg.sender.transfer(10);<br/>    }<br/>}</span></pre><p id="6cdc" class="pw-post-body-paragraph kx ky ht kz b la mb iu lc ld mc ix lf kk md lh li ko me lk ll ks mf ln lo lp hm dt translated">在这个更新的合同中，如果余额不足以转账，<code class="eh mg mh mi mj b">require()</code>功能将停止合同执行并恢复所做的任何更改。这确保了契约不会被可重入攻击所利用。</p><h2 id="3585" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">Tx .原点</h2><p id="2e73" class="pw-post-body-paragraph kx ky ht kz b la lb iu lc ld le ix lf kk lg lh li ko lj lk ll ks lm ln lo lp hm dt translated">Solidity中的tx.origin攻击利用了这样一个事实，即Solidity契约中的tx.origin全局变量是契约外部调用方的地址，而不是实际的契约所有者。这使得攻击者能够通过从另一个地址调用协定来冒充协定所有者，绕过基于协定所有者地址的任何访问控制或权限检查。</p><p id="bed9" class="pw-post-body-paragraph kx ky ht kz b la mb iu lc ld mc ix lf kk md lh li ko me lk ll ks mf ln lo lp hm dt translated">下面是一个易受tx.origin攻击的代码示例:</p><pre class="jj jk jl jm fq mk mj mt bn mu mv bi"><span id="2dc2" class="mw ka ht mj b be mx my l mz mr">pragma solidity ^0.8.01;<br/>contract MyContract { address public owner;<br/>constructor() {<br/>    owner = msg.sender;<br/>}<br/><br/>function myFunction() public {<br/>    require(msg.sender == owner, "Unauthorized access");<br/>    // ..........<br/>}<br/>}</span></pre><p id="ca37" class="pw-post-body-paragraph kx ky ht kz b la mb iu lc ld mc ix lf kk md lh li ko me lk ll ks mf ln lo lp hm dt translated">在本例中，协定检查myFunction()函数的调用方是否是协定所有者。但是，因为使用tx.origin而不是msg.sender，所以攻击者可以从任何地址调用myFunction()并冒充契约所有者。这可能会允许攻击者未经授权访问协定的功能和数据。</p><h2 id="30b6" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">三明治</h2><p id="fb17" class="pw-post-body-paragraph kx ky ht kz b la lb iu lc ld le ix lf kk lg lh li ko lj lk ll ks lm ln lo lp hm dt translated">三明治攻击是Solidity smart contracts在使用多个函数修改相同的状态变量时可能出现的漏洞。这可能会导致合同中出现意外和潜在的恶意行为。</p><p id="1add" class="pw-post-body-paragraph kx ky ht kz b la mb iu lc ld mc ix lf kk md lh li ko me lk ll ks mf ln lo lp hm dt translated">下面是一个容易受到三明治攻击的可靠性合同的例子:</p><pre class="jj jk jl jm fq mk mj mt bn mu mv bi"><span id="4391" class="mw ka ht mj b be mx my l mz mr">pragma solidity ^0.8.01;<br/><br/>contract SandwichAttack {<br/>uint public balance;<br/><br/>function deposit(uint amount) public {<br/>    balance += amount;<br/>}<br/><br/>function withdraw(uint amount) public {<br/>    balance -= amount;<br/>}<br/><br/>function transfer(address to, uint amount) public {<br/>    withdraw(amount);<br/>    to.transfer(amount);<br/>    deposit(amount);<br/>}<br/>}</span></pre><p id="7cd7" class="pw-post-body-paragraph kx ky ht kz b la mb iu lc ld mc ix lf kk md lh li ko me lk ll ks mf ln lo lp hm dt translated">在这个契约中，<code class="eh mg mh mi mj b">transfer</code>函数使用<code class="eh mg mh mi mj b">withdraw</code>和<code class="eh mg mh mi mj b">deposit</code>函数将契约余额中的资金转移到另一个地址。然而，如果一个恶意用户在调用<code class="eh mg mh mi mj b">withdraw</code>和<code class="eh mg mh mi mj b">transfer</code>之间调用<code class="eh mg mh mi mj b">deposit</code>函数，他们就可以有效地取消取款，并按照他们存入的金额增加合同余额。这将导致合同余额不正确，并可能导致资金丢失或被盗。</p><p id="a3cb" class="pw-post-body-paragraph kx ky ht kz b la mb iu lc ld mc ix lf kk md lh li ko me lk ll ks mf ln lo lp hm dt translated">为了防止这个漏洞，Solidity契约应该使用<code class="eh mg mh mi mj b">require</code>关键字来确保状态变量不会被多个函数同时修改。例如，上述合同可以修改如下:</p><pre class="jj jk jl jm fq mk mj mt bn mu mv bi"><span id="0247" class="mw ka ht mj b be mx my l mz mr">pragma solidity ^0.8.01;<br/><br/>contract SandwichAttack {<br/>uint public balance;<br/><br/>function deposit(uint amount) public {<br/>    require(balance + amount &gt;= balance, "Overflow detected");<br/>    balance += amount;<br/>}<br/><br/>function withdraw(uint amount) public {<br/>    require(balance &gt;= amount, "Insufficient balance");<br/>    balance -= amount;<br/>}<br/><br/>function transfer(address to, uint amount) public {<br/>    withdraw(amount);<br/>    to.transfer(amount);<br/>    deposit(amount);<br/>}<br/>}<br/><br/></span></pre><p id="b191" class="pw-post-body-paragraph kx ky ht kz b la mb iu lc ld mc ix lf kk md lh li ko me lk ll ks mf ln lo lp hm dt translated">在这个修改的契约中，<code class="eh mg mh mi mj b">deposit</code>和<code class="eh mg mh mi mj b">withdraw</code>函数都使用了<code class="eh mg mh mi mj b">require</code>关键字来确保契约的余额不会被多个函数同时修改。这防止了三明治攻击的发生，并确保了契约状态的完整性。</p><p id="05ee" class="pw-post-body-paragraph kx ky ht kz b la mb iu lc ld mc ix lf kk md lh li ko me lk ll ks mf ln lo lp hm dt translated">谢谢你们</p><p id="ae4e" class="pw-post-body-paragraph kx ky ht kz b la mb iu lc ld mc ix lf kk md lh li ko me lk ll ks mf ln lo lp hm dt translated">在Twitter上关注我:<a class="ae jy" href="https://twitter.com/Param_eth" rel="noopener ugc nofollow" target="_blank"> @Param_eth </a></p><blockquote class="na"><p id="930f" class="nb nc ht bd nd ne nf ng nh ni nj lp ek translated">交易新手？尝试<a class="ae jy" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae jy" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p><p id="debb" class="nb nc ht bd nd ne nf ng nh ni nj lp ek translated">加入Coinmonks <a class="ae jy" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae jy" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>获取每日<a class="ae jy" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank">加密新闻</a></p></blockquote><h2 id="15d6" class="jz ka ht bd kb kc nk ke kf kg nl ki kj kk nm km kn ko nn kq kr ks no ku kv kw dt translated">另外，阅读</h2><ul class=""><li id="20fb" class="np nq ht kz b la lb ld le kk nr ko ns ks nt lp nu nv nw nx dt translated"><a class="ae jy" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a> | <a class="ae jy" rel="noopener" href="/coinmonks/crypto-tax-software-ed4b4810e338">加密税务软件</a></li><li id="723e" class="np nq ht kz b la ny ld nz kk oa ko ob ks oc lp nu nv nw nx dt translated"><a class="ae jy" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">网格交易</a> | <a class="ae jy" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">加密硬件钱包</a></li><li id="874f" class="np nq ht kz b la ny ld nz kk oa ko ob ks oc lp nu nv nw nx dt translated"><a class="ae jy" rel="noopener" href="/coinmonks/top-3-telegram-channels-for-crypto-traders-in-2021-8385f4411ff4">密码电报信号</a> | <a class="ae jy" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="f33b" class="np nq ht kz b la ny ld nz kk oa ko ob ks oc lp nu nv nw nx dt translated"><a class="ae jy" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a> | <a class="ae jy" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度最佳加密交易所</a></li><li id="47a8" class="np nq ht kz b la ny ld nz kk oa ko ob ks oc lp nu nv nw nx dt translated"><a class="ae jy" rel="noopener" href="/coinmonks/best-crypto-apis-for-developers-5efe3a597a9f">开发人员的最佳加密API</a></li><li id="b359" class="np nq ht kz b la ny ld nz kk oa ko ob ks oc lp nu nv nw nx dt translated">最佳<a class="ae jy" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">密码借贷平台</a></li><li id="3c98" class="np nq ht kz b la ny ld nz kk oa ko ob ks oc lp nu nv nw nx dt translated"><a class="ae jy" rel="noopener" href="/coinmonks/free-crypto-signals-48b25e61a8da">免费加密信号</a> | <a class="ae jy" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a></li><li id="9487" class="np nq ht kz b la ny ld nz kk oa ko ob ks oc lp nu nv nw nx dt translated">杠杆代币的终极指南</li></ul></div></div>    
</body>
</html>