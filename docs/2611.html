<html>
<head>
<title>Upgradable Smart Contracts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可升级智能合同</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/upgradable-smart-contracts-bb9d0218115f?source=collection_archive---------6-----------------------#2022-08-23">https://medium.com/coinmonks/upgradable-smart-contracts-bb9d0218115f?source=collection_archive---------6-----------------------#2022-08-23</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/2fc2611d1253aa8d68724bcadbc78e20.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1Nv5IAfKH3nA8yMm.jpg"/></div></div></figure><p id="6965" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt jz translated">最近，我完成了以太挑战<code class="eh ki kj kk kl b">Puzzle Wallet</code>和<code class="eh ki kj kk kl b">MotorBike</code>，它们为可升级的合同实现了两种不同的代理模式。我想深入了解一下，更多地了解它们各自的优缺点。因此这篇文章记录了我的学习。</p><h2 id="0845" class="km kn ht bd ko kp kq kr ks kt ku kv kw jm kx ky kz jq la lb lc ju ld le lf lg dt translated">智能合约不是不可变的吗？</h2><p id="90a5" class="pw-post-body-paragraph jb jc ht jd b je lh jg jh ji li jk jl jm lj jo jp jq lk js jt ju ll jw jx jy hm dt translated">我认为，智能合约一旦部署就不能修改，因为它违背了区块链的不变性和去中心化的目的，但是它们可以升级以添加新的功能或修复现有的漏洞，同时保留合约的地址、状态和平衡。</p><h2 id="f89e" class="km kn ht bd ko kp kq kr ks kt ku kv kw jm kx ky kz jq la lb lc ju ld le lf lg dt translated">如何执行升级？</h2><p id="8275" class="pw-post-body-paragraph jb jc ht jd b je lh jg jh ji li jk jl jm lj jo jp jq lk js jt ju ll jw jx jy hm dt translated">有三个简单的步骤</p><ol class=""><li id="328f" class="lm ln ht jd b je jf ji jj jm lo jq lp ju lq jy lr ls lt lu dt translated">部署实现契约——包含逻辑的契约</li><li id="3096" class="lm ln ht jd b je lv ji lw jm lx jq ly ju lz jy lr ls lt lu dt translated">部署<code class="eh ki kj kk kl b">ProxyAdmin</code>合同(我们代理的管理员)。</li><li id="d01e" class="lm ln ht jd b je lv ji lw jm lx jq ly ju lz jy lr ls lt lu dt translated">部署代理契约并运行任何初始化函数。</li></ol><figure class="mb mc md me fq iu fe ff paragraph-image"><div class="fe ff ma"><img src="../Images/4e79f85574b48ade0dfd623089c625b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1110/format:webp/1*RpCh3XHSMDKQA0DO3x_4Fg.png"/></div><figcaption class="mf mg fg fe ff mh mi bd b be z ek">Proxy and Implementation Contract</figcaption></figure><h2 id="2c1d" class="km kn ht bd ko kp kq kr ks kt ku kv kw jm kx ky kz jq la lb lc ju ld le lf lg dt translated">技术细节</h2><p id="50e2" class="pw-post-body-paragraph jb jc ht jd b je lh jg jh ji li jk jl jm lj jo jp jq lk js jt ju ll jw jx jy hm dt translated"><strong class="jd hu"> <em class="mj">实现</em> </strong>契约包含了这个逻辑。一个<strong class="jd hu"> <em class="mj">代理</em> </strong>是一个简单的契约，它只是<em class="mj">将所有调用委托给</em>一个实现契约。代理保存状态，而实现契约提供代码。</p><p id="fcea" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">升级包括以下步骤:</p><ol class=""><li id="16a6" class="lm ln ht jd b je jf ji jj jm lo jq lp ju lq jy lr ls lt lu dt translated">部署新的实施合同。</li><li id="d2ee" class="lm ln ht jd b je lv ji lw jm lx jq ly ju lz jy lr ls lt lu dt translated">向代理发送一个事务，代理将其实现地址更新为新地址。</li></ol><h2 id="676b" class="km kn ht bd ko kp kq kr ks kt ku kv kw jm kx ky kz jq la lb lc ju ld le lf lg dt translated">要记住的要点</h2><ol class=""><li id="0907" class="lm ln ht jd b je lh ji li jm mk jq ml ju mm jy lr ls lt lu dt translated">可升级合同不能有<code class="eh ki kj kk kl b">constructor</code>。为了帮助你运行初始化代码，<a class="ae mn" href="https://docs.openzeppelin.com/contracts/4.x/" rel="noopener ugc nofollow" target="_blank"><strong class="jd hu">OpenZeppelin Contracts</strong></a>提供了<code class="eh ki kj kk kl b"><a class="ae mn" href="https://docs.openzeppelin.com/learn/upgrading-smart-contracts#contracts::api/proxy.adoc#Initializable" rel="noopener ugc nofollow" target="_blank">Initializable</a></code>基础契约，允许你标记一个方法，确保它只能运行一次。</li></ol><p id="5310" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">2.我们不能改变那份合同的储存布局。这意味着，如果你已经在契约中声明了一个状态变量，你不能删除它，改变它的类型，或者在它之前声明另一个变量，但是你可以在最后引入一个新的状态变量。</p><p id="62d2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">3.将它的构造函数改为一个常规函数，通常命名为<code class="eh ki kj kk kl b">initialize</code>，在这里运行所有的设置逻辑。</p><p id="6f5f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">4.攻击者可以接管未初始化的实现协定，这可能会影响代理。</p><h2 id="3f1d" class="km kn ht bd ko kp kq kr ks kt ku kv kw jm kx ky kz jq la lb lc ju ld le lf lg dt translated">存储冲突</h2><p id="adb6" class="pw-post-body-paragraph jb jc ht jd b je lh jg jh ji li jk jl jm lj jo jp jq lk js jt ju ll jw jx jy hm dt translated">应该严格遵循变量的顺序。假设我们已经声明了三个变量<code class="eh ki kj kk kl b">uint256</code>、<code class="eh ki kj kk kl b">address</code>和<code class="eh ki kj kk kl b">bool</code>。那么实施合同应该遵循同样的顺序<code class="eh ki kj kk kl b">uint256</code>、<code class="eh ki kj kk kl b">address</code>、<code class="eh ki kj kk kl b">bool</code>。否则，这可能会导致未知的问题，在某些情况下，黑客接管代理合同。</p><h2 id="7fe5" class="km kn ht bd ko kp kq kr ks kt ku kv kw jm kx ky kz jq la lb lc ju ld le lf lg dt translated">功能冲突</h2><p id="bf5f" class="pw-post-body-paragraph jb jc ht jd b je lh jg jh ji li jk jl jm lj jo jp jq lk js jt ju ll jw jx jy hm dt translated">可能有这样的情况，其中来自代理和实现契约的函数的<code class="eh ki kj kk kl b">abi.encodePacked</code>结果是相同的。为了解决这个问题，<em class="mj">透明代理模式(TPP) </em>确保用户不能调用代理函数，代理管理员也不能调用用户的函数。因此，防止了任何碰撞。</p><h2 id="6884" class="km kn ht bd ko kp kq kr ks kt ku kv kw jm kx ky kz jq la lb lc ju ld le lf lg dt translated">透明代理模式(TPP)和通用可升级代理标准(UUPS)</h2><p id="1156" class="pw-post-body-paragraph jb jc ht jd b je lh jg jh ji li jk jl jm lj jo jp jq lk js jt ju ll jw jx jy hm dt translated">透明代理在代理契约中需要额外的逻辑来管理所有的升级功能，以及识别调用者是否是管理地址的能力。TPP不如UUPS省油。</p><p id="eadb" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在代理上调用<code class="eh ki kj kk kl b">upgradeToAndCall()</code>委托给实现上的同一个函数。当<code class="eh ki kj kk kl b">upgradeToAndCall()</code>在实现上执行时(在代理的上下文中)，它改变代理中存储的实现地址<em class="mj">。这是可行的，因为UUPS实现可以访问代理的所有存储；它们可以覆盖代理契约的存储槽，其中代理存储实现的地址。</em></p><p id="aeb4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">此外，在UUPS的情况下，用户可以在任何时间点定制或更新所有者，而在TPP中，代理管理员是唯一有权更新的人。</p><p id="ede7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">感谢阅读！</p><blockquote class="mo"><p id="51b6" class="mp mq ht bd mr ms mt mu mv mw mx jy ek translated">交易新手？尝试<a class="ae mn" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae mn" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>