<html>
<head>
<title>Verifying blockchain transactions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">验证区块链交易</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/verifying-blockchain-transactions-6f7ca6110c41?source=collection_archive---------32-----------------------#2022-11-20">https://medium.com/coinmonks/verifying-blockchain-transactions-6f7ca6110c41?source=collection_archive---------32-----------------------#2022-11-20</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><h2 id="45b8" class="hr hs ht bd b gc hu hv hw hx hy hz ek ia translated" aria-label="kicker paragraph">区块链</h2><div class=""/><figure class="fi fk ja jb jc jd fe ff paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="fe ff iz"><img src="../Images/f2e5145eb1111d9341dc37c51f3eebe2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*U9Yx3fJiIIjaaq23.jpeg"/></div></div></figure><p id="d90e" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">我们在上一篇文章的<a class="ae ki" href="https://www.thearmchaircritic.org/mansplainings/proving-ownership-of-coins-in-blockchain" rel="noopener ugc nofollow" target="_blank">中讨论了证明比特币的所有权。让我们在本文中详细讨论验证事务是如何工作的。</a></p><p id="8e48" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">还记得之前我们了解到，除了区块链用来验证交易的公钥散列之外，公钥脚本还有几个脚本吗？我们将使用这些脚本来验证交易。让我们看看怎么做。</p><p id="d229" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">但是在此之前，请注意，我们使用pubkey脚本来验证使用它作为输入的事务。换句话说，为了验证一个事务，我们使用其输入的pubkey脚本。在我们在<a class="ae ki" href="https://www.thearmchaircritic.org/mansplainings/understanding-blockchain-transactions" rel="noopener ugc nofollow" target="_blank">早期文章</a>中看到的例子中，我们的交易将由pubkey脚本验证，这些脚本是给我们0.75比特币和0.4比特币的交易输出的，因为我们使用它们作为输入。</p><h1 id="7156" class="kj kk ht bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">公钥脚本</h1><p id="4e07" class="pw-post-body-paragraph jk jl ht jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh hm dt translated">公钥脚本由以下脚本组成:</p><p id="196b" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">这些脚本中的每一个都在验证过程中执行特定的功能。让我们看看这个验证过程是如何工作的。</p><p id="bd23" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">正如我们已经看到的，pubkey脚本也包含pubkey散列。因此，我们可以在pubkey脚本中按以下顺序找到pubkey哈希和脚本:</p><blockquote class="lm"><p id="9e14" class="ln lo ht bd lp lq lr ls lt lu lv kh ek translated">交易新手？在<a class="ae ki" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易</a>上尝试<a class="ae ki" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae ki" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote><h1 id="5477" class="kj kk ht bd kl km kn ko kp kq kr ks kt ku lw kw kx ky lx la lb lc ly le lf lg dt translated">核查进程</h1><p id="b998" class="pw-post-body-paragraph jk jl ht jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh hm dt translated">在验证过程的第一步中，我们将当前交易的签名脚本(包含交易的数字签名和交易者的公钥)添加到pubkey脚本中。因此，我们将有以下内容:</p><p id="a0d4" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">然后，我们从数字签名开始执行这个脚本，直到OP_CHECKSIG脚本。因为这个脚本中的第一个数字签名只是数据，所以我们将它放入堆栈中。<a class="ae ki" href="https://en.wikipedia.org/wiki/Stack_(abstract_data_type)" rel="noopener ugc nofollow" target="_blank">堆栈</a>是一种数据结构，其中最先添加的项目只能最后移除。为了获得更好的直觉，可以把一个栈想象成一个CD栈。您首先放入的CD只能最后取出。</p><p id="a4c6" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">公钥也只是数据，我们将其放入堆栈，放在数字签名之上。堆栈现在看起来像这样:</p><p id="527f" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">现在，脚本中的第三个是OP_DUP，这是一个脚本。该脚本复制堆栈顶部的数据。因为公钥位于堆栈的顶部，所以脚本复制了它。现在，我们的堆栈如下所示:</p><h1 id="061a" class="kj kk ht bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">获取公钥哈希</h1><p id="c85c" class="pw-post-body-paragraph jk jl ht jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh hm dt translated">脚本中的下一个是OP_HASH160，它也是一个脚本。这个脚本对栈顶的数据进行两次散列，并在删除原始数据后将散列值推入栈中。因为公共密钥在顶部，所以脚本会推送它的散列。现在，堆栈看起来像这样:</p><p id="4f86" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">脚本中的下一个是Pubkey散列。由于这是数据，我们将它推入堆栈，使堆栈看起来如下:</p><ol class=""><li id="4a34" class="lz ma ht jm b jn jo jr js jv mb jz mc kd md kh me mf mg mh dt translated">公钥哈希(来自公钥脚本)</li><li id="6305" class="lz ma ht jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh dt translated">公钥散列</li><li id="02f2" class="lz ma ht jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh dt translated">公开密钥</li><li id="82dc" class="lz ma ht jm b jn mi jr mj jv mk jz ml kd mm kh me mf mg mh dt translated">数字签名</li></ol><h1 id="8b4d" class="kj kk ht bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">验证所有权</h1><p id="44a6" class="pw-post-body-paragraph jk jl ht jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh hm dt translated">脚本中的下一个是OP_EQUALVERFY，这是一个脚本。这个脚本由两个脚本组成——OP _ EQUAL和OP_VERFY。OP_EQUAL首先检查堆栈顶部的两个值是否相等。顶部的两个值是公钥散列。</p><p id="31c9" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">但是请记住，最顶层的公钥散列来自公钥脚本，我们使用交易者的签名脚本获得了第二个散列。因此，前者是交易发送到的帐户的公钥的散列，后者是当前交易者的公钥。</p><p id="44db" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">因此，这个OP_EQUAL脚本所做的是验证交易的发起者是否是从上一笔交易中收到钱的人。换句话说，它已经验证了所有权。如果两个哈希值相等，那么这个脚本弹出(删除)这两个哈希值，并将值1压入。如果验证失败，那么脚本弹出这两个哈希值，并将值设为0。假设验证成功。这是堆栈现在的样子:</p><p id="fa19" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">然后，OP_VERIFY脚本检查堆栈顶部的值。如果为0，则意味着比特币不属于发送方，因此脚本终止验证过程，交易验证失败。如果值为1，那么它弹出这个值并继续剩余的过程。现在，堆栈如下所示:</p><h1 id="f2c5" class="kj kk ht bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">验证签名</h1><p id="a91a" class="pw-post-body-paragraph jk jl ht jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh hm dt translated">脚本中的下一个是OP_CHECKSIG脚本。这将检查数字签名的有效性。堆栈中的公钥是来自交易者签名脚本的密钥。但是pubkey脚本已经验证了这个公钥与使用OP_EQUALVERIFY脚本将前一个事务发送到的公钥相同。</p><p id="70e5" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">因此，OP_CHECKSIG脚本使用这个公钥来解密数字签名。如果数字签名可以被解密，那么这意味着它已经使用交易者的私钥进行了加密，这有效地验证了交易者。解密的数据是事务的散列。然后，该事务被散列两次，以查看它是否与通过解密数字签名获得的散列相匹配。如果它们相同，则证明交易数据是准确的。</p><p id="f780" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">现在，事务已经被验证，OP_CHECKSIG脚本将值‘true’压入堆栈。如果签名不能被解密或者散列不匹配，那么值‘false’被推入堆栈。如果堆栈顶部的值不为“false”，则事务被视为有效。</p><p id="8075" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">在本文中，我们看到了交易验证是如何发生的。在下一篇文章中，我们将看到谁执行这些验证，以及如何存储经过验证的事务。</p></div><div class="ab cl mn mo hb mp" role="separator"><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms mt"/><span class="mq bw bk mr ms"/></div><div class="hm hn ho hp hq"><p id="2869" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated"><em class="mu">原载于2022年11月20日</em><a class="ae ki" href="https://www.thearmchaircritic.org/mansplainings/verifying-blockchain-transactions" rel="noopener ugc nofollow" target="_blank"><em class="mu">【https://www.thearmchaircritic.org】</em></a><em class="mu">。</em></p></div></div>    
</body>
</html>