<html>
<head>
<title>How to create a Transparent Proxy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何创建透明代理</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/how-to-create-a-transparent-proxy-1683d21468bf?source=collection_archive---------5-----------------------#2022-09-11">https://medium.com/coinmonks/how-to-create-a-transparent-proxy-1683d21468bf?source=collection_archive---------5-----------------------#2022-09-11</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="313c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">代理模式是一种智能合约设计模式，用于使智能合约可升级。请注意，智能合约本身是不可变的，为了使它们可升级，一些高级的可靠性基础工作是必要的。有关智能合同升级能力的详细概述和透明代理模式的解释，请阅读<a class="ae jo" rel="noopener" href="/@HashHaran/essential-guide-to-smart-contract-upgradeability-a257dac36525">这篇</a>更早的文章。在本文中，我们将重点关注使用透明代理模式实际部署您的契约。</p><p id="ac18" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这个<a class="ae jo" href="https://github.com/HashHaran/hardhat-upgrades" rel="noopener ugc nofollow" target="_blank"> Github仓库</a>有这篇文章的代码，可以随意保存以备将来使用。如果您不想从头开始进行设置，可以克隆它。</p><h1 id="e7b7" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">项目设置</h1><p id="3eaa" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">我们将使用<a class="ae jo" href="https://hardhat.org/" rel="noopener ugc nofollow" target="_blank">安全帽</a>用于我们的以太坊开发工作流程。在本演练中，我在windows机器上使用WSL2。如果使用不同的设置，您可以稍微调整这些步骤。我们开始吧！</p><p id="f4a0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">运行以下命令创建一个目录，并将其初始化为节点项目。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="612f" class="lb jq ht kx b fv lc ld l le lf"><strong class="kx hu">mkdir hardhat-upgrades &amp;&amp; cd hardhat-upgrades</strong></span><span id="181a" class="lb jq ht kx b fv lg ld l le lf"><strong class="kx hu">npm init -y</strong></span></pre><p id="9011" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这个目录中安装hardhat。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="8c22" class="lb jq ht kx b fv lc ld l le lf"><strong class="kx hu">npm i --save-dev hardhat</strong></span></pre><p id="c95c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在目录中初始化一个hardhat类型的脚本项目。运行下面的命令并选择“<em class="lh">创建一个TypeScript项目”</em>选项。对于其余的提示，请使用默认参数。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="9d07" class="lb jq ht kx b fv lc ld l le lf"><strong class="kx hu">npx hardhat</strong></span></pre><p id="aca2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">安装开放的zeppelin hardhat升级插件，我们将使用它来轻松部署我们的代理。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="a97b" class="lb jq ht kx b fv lc ld l le lf"><strong class="kx hu">npm i --save-dev @openzeppelin/hardhat-upgrades</strong></span></pre><p id="0765" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">还要安装来自Open zeppelin的可升级合同，它是Open zeppelin合同的可升级对应物。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="9355" class="lb jq ht kx b fv lc ld l le lf"><strong class="kx hu">npm i --save-dev @openzeppelin/contracts-upgradeable</strong></span></pre><p id="aa06" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">将以下内容复制并粘贴到hardhat.config.ts文件中。这将做这个项目所需的基本安全帽设置。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="6f6f" class="lb jq ht kx b fv lc ld l le lf">import { HardhatUserConfig } from "hardhat/config";</span><span id="9c46" class="lb jq ht kx b fv lg ld l le lf">import "@nomicfoundation/hardhat-toolbox";</span><span id="660b" class="lb jq ht kx b fv lg ld l le lf">import "@openzeppelin/hardhat-upgrades";</span><span id="edaf" class="lb jq ht kx b fv lg ld l le lf">import "@typechain/hardhat";</span><span id="6ca5" class="lb jq ht kx b fv lg ld l le lf">const config: HardhatUserConfig = {</span><span id="fbed" class="lb jq ht kx b fv lg ld l le lf">solidity: {</span><span id="b76d" class="lb jq ht kx b fv lg ld l le lf">version: "0.8.9",</span><span id="d245" class="lb jq ht kx b fv lg ld l le lf">settings: {</span><span id="fe45" class="lb jq ht kx b fv lg ld l le lf">optimizer: {</span><span id="4c2e" class="lb jq ht kx b fv lg ld l le lf">enabled: true,</span><span id="a4fb" class="lb jq ht kx b fv lg ld l le lf">runs: 200,</span><span id="9cf2" class="lb jq ht kx b fv lg ld l le lf">},</span><span id="40ef" class="lb jq ht kx b fv lg ld l le lf">},</span><span id="d7d1" class="lb jq ht kx b fv lg ld l le lf">},</span><span id="8380" class="lb jq ht kx b fv lg ld l le lf">defaultNetwork: "localhost",</span><span id="c3d6" class="lb jq ht kx b fv lg ld l le lf">};</span><span id="539a" class="lb jq ht kx b fv lg ld l le lf">export default config;</span></pre><h1 id="581f" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">使用透明代理部署的实施合同</h1><p id="eabb" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">在contracts文件夹中为我们将要部署透明代理的实现契约创建一个文件夹。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="f217" class="lb jq ht kx b fv lc ld l le lf"><strong class="kx hu">mkdir contracts/transparent</strong></span></pre><p id="2d6a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在<em class="lh"> contracts </em>目录下创建一个名为<em class="lh"> VersionAware.sol </em>的文件，并将以下代码复制粘贴到其中。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="9111" class="lb jq ht kx b fv lc ld l le lf"><em class="lh">// SPDX-License-Identifier: Unlicense</em></span><span id="3c1d" class="lb jq ht kx b fv lg ld l le lf">pragma solidity ^0.8.0;</span><span id="6744" class="lb jq ht kx b fv lg ld l le lf">abstract contract VersionAware {</span><span id="eb75" class="lb jq ht kx b fv lg ld l le lf">string public versionAwareContractName;</span><span id="49ea" class="lb jq ht kx b fv lg ld l le lf">function getContractNameWithVersion()</span><span id="3853" class="lb jq ht kx b fv lg ld l le lf">external</span><span id="48f2" class="lb jq ht kx b fv lg ld l le lf">pure</span><span id="8e68" class="lb jq ht kx b fv lg ld l le lf">virtual</span><span id="5f70" class="lb jq ht kx b fv lg ld l le lf">returns (string memory);</span><span id="6845" class="lb jq ht kx b fv lg ld l le lf">}</span></pre><p id="10c9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这里，我们创建了实现契约的基本框架，以便在部署和升级之后，我们可以轻松地看到版本升级。</p><p id="b12e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在<em class="lh"> contracts/transparent </em>目录下创建两个名为<em class="lh">transparentproxypatternv 1 . sol</em>和<em class="lh">transparentproxypatternv 2 . sol</em>的文件，并将下面的代码复制粘贴到其中。</p><p id="2090" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="lh">transparentproxypatternv 1 . sol</em></p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="4f42" class="lb jq ht kx b fv lc ld l le lf"><em class="lh">// SPDX-License-Identifier: Unlicense</em></span><span id="f011" class="lb jq ht kx b fv lg ld l le lf">pragma solidity ^0.8.0;</span><span id="47eb" class="lb jq ht kx b fv lg ld l le lf">import {ERC1967UpgradeUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol";</span><span id="33cc" class="lb jq ht kx b fv lg ld l le lf">import {VersionAware} from "../VersionAware.sol";</span><span id="205f" class="lb jq ht kx b fv lg ld l le lf">contract TransparentProxyPatternV1 is ERC1967UpgradeUpgradeable, VersionAware {</span><span id="a7e5" class="lb jq ht kx b fv lg ld l le lf">constructor() {</span><span id="1a89" class="lb jq ht kx b fv lg ld l le lf">_disableInitializers();</span><span id="8c52" class="lb jq ht kx b fv lg ld l le lf">}</span><span id="ccf8" class="lb jq ht kx b fv lg ld l le lf">function initialize() external initializer {</span><span id="da8f" class="lb jq ht kx b fv lg ld l le lf">versionAwareContractName = "Transparent Proxy Pattern: V1";</span><span id="291e" class="lb jq ht kx b fv lg ld l le lf">}</span><span id="77fe" class="lb jq ht kx b fv lg ld l le lf">function getContractNameWithVersion()</span><span id="e24e" class="lb jq ht kx b fv lg ld l le lf">public</span><span id="949a" class="lb jq ht kx b fv lg ld l le lf">pure</span><span id="ddd6" class="lb jq ht kx b fv lg ld l le lf">override</span><span id="90ac" class="lb jq ht kx b fv lg ld l le lf">returns (string memory)</span><span id="40c1" class="lb jq ht kx b fv lg ld l le lf">{</span><span id="3053" class="lb jq ht kx b fv lg ld l le lf">return "Transparent Proxy Pattern: V1";</span><span id="9147" class="lb jq ht kx b fv lg ld l le lf">}</span><span id="1949" class="lb jq ht kx b fv lg ld l le lf">}</span></pre><p id="3f4b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="lh">transparentproxypatternv 2 . sol</em></p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="d42f" class="lb jq ht kx b fv lc ld l le lf"><em class="lh">// SPDX-License-Identifier: Unlicense</em></span><span id="eb56" class="lb jq ht kx b fv lg ld l le lf">pragma solidity ^0.8.0;</span><span id="8c40" class="lb jq ht kx b fv lg ld l le lf">import {ERC1967UpgradeUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol";</span><span id="a7c3" class="lb jq ht kx b fv lg ld l le lf">import {VersionAware} from "../VersionAware.sol";</span><span id="d1f9" class="lb jq ht kx b fv lg ld l le lf">contract TransparentProxyPatternV2 is ERC1967UpgradeUpgradeable, VersionAware {</span><span id="1a1b" class="lb jq ht kx b fv lg ld l le lf">constructor() {</span><span id="bbda" class="lb jq ht kx b fv lg ld l le lf">_disableInitializers();</span><span id="3d81" class="lb jq ht kx b fv lg ld l le lf">}</span><span id="4b15" class="lb jq ht kx b fv lg ld l le lf">function initialize() external reinitializer(2) {</span><span id="879a" class="lb jq ht kx b fv lg ld l le lf">versionAwareContractName = "Transparent Proxy Pattern: V2";</span><span id="e759" class="lb jq ht kx b fv lg ld l le lf">}</span><span id="03e0" class="lb jq ht kx b fv lg ld l le lf">function getContractNameWithVersion()</span><span id="1bb5" class="lb jq ht kx b fv lg ld l le lf">public</span><span id="1162" class="lb jq ht kx b fv lg ld l le lf">pure</span><span id="c0db" class="lb jq ht kx b fv lg ld l le lf">override</span><span id="e7ba" class="lb jq ht kx b fv lg ld l le lf">returns (string memory)</span><span id="1422" class="lb jq ht kx b fv lg ld l le lf">{</span><span id="29bf" class="lb jq ht kx b fv lg ld l le lf">return "Transparent Proxy Pattern: V2";</span><span id="82d0" class="lb jq ht kx b fv lg ld l le lf">}</span><span id="758e" class="lb jq ht kx b fv lg ld l le lf">}</span></pre><p id="a68c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们有两个实现合同版本1和2。请注意，版本1和版本2的结构不必相同，升级也能工作。请注意，这两个合同都是从开放的zeppelin可升级包的<em class="lh">ERC 1967可升级</em>合同继承的。阅读本文顶部链接的早期文章，了解更多关于ERC1967标准的信息。</p><p id="5e56" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们有两个实现合同版本1和2。请注意，版本1和版本2的结构不必相同，升级也能工作。注意，这两个合同都继承了来自开放的zeppelin可升级包的<em class="lh">ERC 1967可升级</em>合同。阅读本文顶部链接的早期文章，了解更多关于ERC1967标准的信息。</p><p id="ad54" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这里，我试图解释上述合同的一些高级细节。如果你在第一次阅读时理解有困难，考虑现在跳过它，以后再回来。典型的可升级协定不应该有构造函数，因为实现协定的构造函数永远不能在代理协定的上下文中运行。我们在这里添加了一个安全的构造函数，因为它没有设置任何存储变量。不初始化就退出协定会造成安全威胁。在构造函数中调用<em class="lh">_ disable initializer</em>方法使得实现契约不可初始化，这比让实现没有构造函数也不初始化要安全得多。注意，我在V1的<em class="lh">初始化</em>方法中使用了<em class="lh">初始化器</em>修饰符。这个修饰符确保这个initialize方法只被调用一次，就像solidity确保构造函数一样。还要注意，在V2中，<em class="lh">初始化</em>方法的修饰符是<em class="lh">重新初始化器(2)。</em>此处2代表实施合同的版本。必须使用<em class="lh">重新初始化器</em>修改器，而不是<em class="lh">初始化器</em>，因为代理契约已经在V1初始化过一次。关于所有可升级智能契约都应该继承的Initializer.sol契约，还有更多事情和细节需要了解。以后我会写更多关于它的详细文章。</p><p id="f3bb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，运行以下命令来编译智能合约。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="1f88" class="lb jq ht kx b fv lc ld l le lf"><strong class="kx hu">npx hardhat compile</strong></span></pre><h1 id="ca33" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">透明代理部署和升级</h1><p id="6750" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">首先，我们将使用透明代理部署版本1，然后将其升级到版本2。我们将使用一个安全帽脚本来做到这一点。在脚本文件夹中创建一个名为<em class="lh"> transparent.js </em>的脚本，并将下面的代码复制粘贴到其中。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="aa40" class="lb jq ht kx b fv lc ld l le lf">const { ethers, upgrades } = require("hardhat");</span><span id="fb9a" class="lb jq ht kx b fv lg ld l le lf">async function main() {</span><span id="83c4" class="lb jq ht kx b fv lg ld l le lf">const TransparentProxyPatternV1 = await ethers.getContractFactory("TransparentProxyPatternV1");</span><span id="3526" class="lb jq ht kx b fv lg ld l le lf">const transparentProxyPatternV1 = await upgrades.deployProxy(TransparentProxyPatternV1, [], {kind: 'transparent', unsafeAllow: ['constructor']});</span><span id="fa9f" class="lb jq ht kx b fv lg ld l le lf">await transparentProxyPatternV1.deployed();</span><span id="68f1" class="lb jq ht kx b fv lg ld l le lf">console.log(`Transparent Proxy Pattern V1 is deployed to proxy address: ${transparentProxyPatternV1.address}`);</span><span id="1555" class="lb jq ht kx b fv lg ld l le lf">let versionAwareContractName = await transparentProxyPatternV1.getContractNameWithVersion();</span><span id="bbcf" class="lb jq ht kx b fv lg ld l le lf">console.log(`Proxy Pattern and Version: ${versionAwareContractName}`);</span><span id="f834" class="lb jq ht kx b fv lg ld l le lf">const TransparentProxyPatternV2 = await ethers.getContractFactory("TransparentProxyPatternV2");</span><span id="2b85" class="lb jq ht kx b fv lg ld l le lf">const upgraded = await upgrades.upgradeProxy(transparentProxyPatternV1.address, TransparentProxyPatternV2, {kind: 'transparent', unsafeAllow: ['constructor'], call: 'initialize'});</span><span id="70c6" class="lb jq ht kx b fv lg ld l le lf">console.log(`Transparent Proxy Pattern V2 is upgraded in proxy address: ${upgraded.address}`);</span><span id="5003" class="lb jq ht kx b fv lg ld l le lf">versionAwareContractName = await upgraded.getContractNameWithVersion();</span><span id="f912" class="lb jq ht kx b fv lg ld l le lf">console.log(`Proxy Pattern and Version: ${versionAwareContractName}`);</span><span id="f514" class="lb jq ht kx b fv lg ld l le lf">}</span><span id="f903" class="lb jq ht kx b fv lg ld l le lf">main().catch((error) =&gt; {</span><span id="e3c1" class="lb jq ht kx b fv lg ld l le lf">console.error(error);</span><span id="8181" class="lb jq ht kx b fv lg ld l le lf">process.exitCode = 1;</span><span id="f5fd" class="lb jq ht kx b fv lg ld l le lf">});</span></pre><p id="f0fa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们首先部署带有代理和代理管理的智能合约版本1。Open zeppelin升级<em class="lh"> deployProxy </em>方法为我们解决了所有这些问题。一旦用代理部署了版本1，我们就在代理上调用<em class="lh">getContractNameWithVersion</em>函数。该方法将根据我们在契约的版本1中使该方法返回的内容返回一个字符串。然后我们继续用<em class="lh">升级代理</em>方法升级这个合同。升级结束后，我们再次调用<em class="lh">getContractNameWithVersion</em>函数来查看返回的字符串的变化。让我们运行脚本，看看结果。使用以下命令运行脚本。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="a43d" class="lb jq ht kx b fv lc ld l le lf"><strong class="kx hu">npx hardhat run scripts/transparent.js</strong></span></pre><p id="4035" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">您应该会在控制台上看到以下内容。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="b4d1" class="lb jq ht kx b fv lc ld l le lf">Warning: Potentially unsafe deployment of TransparentProxyPatternV1</span><span id="6033" class="lb jq ht kx b fv lg ld l le lf">You are using the `unsafeAllow.constructor` flag.</span><span id="6ac3" class="lb jq ht kx b fv lg ld l le lf">Transparent Proxy Pattern V1 is deployed to proxy address: 0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0<br/>Proxy Pattern and Version: Transparent Proxy Pattern: V1<br/>Warning: Potentially unsafe deployment of TransparentProxyPatternV2</span><span id="2166" class="lb jq ht kx b fv lg ld l le lf">You are using the `unsafeAllow.constructor` flag.</span><span id="3064" class="lb jq ht kx b fv lg ld l le lf">Transparent Proxy Pattern V2 is upgraded in proxy address: 0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0<br/>Proxy Pattern and Version: Transparent Proxy Pattern: V2</span></pre><p id="3cb4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">耶！结果在意料之中。实施合同已成功升级到版本2。这就是您如何使用透明代理模式部署和升级未来版本的契约，无论您的智能契约变得多么复杂。</p><p id="167b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">感谢阅读。</p><h1 id="3541" class="jp jq ht bd jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km dt translated">我是谁？</h1><p id="2381" class="pw-post-body-paragraph iq ir ht is b it kn iv iw ix ko iz ja jb kp jd je jf kq jh ji jj kr jl jm jn hm dt translated">我是一名全栈区块链开发者，对构建一个去中心化的、潜在的更具包容性的未来充满热情。有区块链发展的需求吗？</p><p id="8d80" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">取得联系:📧hariharan @ aluminum . iitm . AC . in</p><p id="a3c7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><a class="ae jo" href="https://github.com/HashHaran" rel="noopener ugc nofollow" target="_blank"> Github </a></p><blockquote class="li"><p id="df0c" class="lj lk ht bd ll lm ln lo lp lq lr jn ek translated">交易新手？尝试<a class="ae jo" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae jo" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>