<html>
<head>
<title>Learn Solidity lesson 30. Contracts as classes.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习坚实度第30课。合同为类。</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/learn-solidity-lesson-30-contracts-as-classes-ceff5e088dd6?source=collection_archive---------3-----------------------#2022-08-25">https://medium.com/coinmonks/learn-solidity-lesson-30-contracts-as-classes-ceff5e088dd6?source=collection_archive---------3-----------------------#2022-08-25</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/88b7da6844bc400a24daa8932d5010e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TBe_9vIgyhsoZYooJ4LxTQ.jpeg"/></div></div></figure><p id="a863" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">正式的Solidity文档规定合同类似于面向对象语言中的类。我们将在本课和下一课中更详细地了解这一点。</p><p id="df46" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">类就像允许我们创建对象的模型。它们是柏拉图世界的理念，是真实物体的模型。这样想，契约代码就是类，当契约被部署到某个地址时，对象被创建(实例化)。</p><p id="6298" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们已经看到了如何通过交易部署合同，其中合同创建者是一个外部帐户。也可以通过另一个合同创建某个合同的新实例。让我们看看怎么做。</p><p id="52bc" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我先复制所有代码，然后解释。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="5ab2" class="ki kj ht ke b fv kk kl l km kn">//SPDX-License-Identifier: MIT<br/>pragma solidity ^0.8.7;</span><span id="f23e" class="ki kj ht ke b fv ko kl l km kn">contract Sum {<br/>   function sum(uint x, uint y) public pure returns (uint) {<br/>      return x + y;<br/>   }<br/>}</span><span id="ba53" class="ki kj ht ke b fv ko kl l km kn">contract Fabric {<br/>   address[] public sums;<br/>   function newSum() public {<br/>      Sum sum = new Sum();<br/>      sums.push(address(sum));<br/>   }<br/>}</span></pre><p id="6203" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我试图使代码尽可能简单。在同一份文件中，我写了两份合同。其中一个名为<code class="eh kp kq kr ke b">Sum</code>，只有一个函数可以加2个数字。合同<code class="eh kp kq kr ke b">Sum</code>将被另一个名为<code class="eh kp kq kr ke b">Fabric</code>的合同实例化。</p><p id="147a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在<code class="eh kp kq kr ke b">Fabric</code>契约中，有一个地址数组，我们将在其中存储创建的实例的地址。<code class="eh kp kq kr ke b">newSum</code>还有一个功能，他的身体很简单。在第一行，我们使用关键字<strong class="jd hu"> new </strong>创建合同的新实例<code class="eh kp kq kr ke b">Sum</code>。在另一行，我们写下在名为<code class="eh kp kq kr ke b">sums</code>的数组中创建的实例的地址。</p><p id="2bb3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh kp kq kr ke b">sum</code>实例是类型为<code class="eh kp kq kr ke b">Sum</code>的对象，可以用来调用创建的合同中的函数。我们很快就会这样做。现在，让我们尝试使用Remix创建新的实例。</p><h1 id="4f36" class="ks kj ht bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo dt translated">创建新实例</h1><p id="3d70" class="pw-post-body-paragraph jb jc ht jd b je lp jg jh ji lq jk jl jm lr jo jp jq ls js jt ju lt jw jx jy hm dt translated">由于同一文件现在包含2份合同，有必要向Remix指出将部署哪份合同。在<em class="lu">部署&amp;运行事务</em>页签中，选择合同<em class="lu">架构</em>，如下图所示。我经常忘记选择合同，结果部署了错误的合同，我所有的学生也是如此。</p><figure class="jz ka kb kc fq iu fe ff paragraph-image"><div class="fe ff lv"><img src="../Images/14d2288b06f1d381e6c9f2c540814449.png" data-original-src="https://miro.medium.com/v2/resize:fit:776/format:webp/1*rGwPHSEa_x92h1WvFEritw.png"/></div><figcaption class="lw lx fg fe ff ly lz bd b be z ek">It is necessary to select which contract will be deployed.</figcaption></figure><p id="6f9d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">一旦这样做了，每次调用<code class="eh kp kq kr ke b">newSum</code>函数时，都会在给定的地址创建一个新的合同实例。我们可以将这些地址作为<code class="eh kp kq kr ke b">sums</code>数组的元素进行检查。</p><p id="6155" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">作为测试，我调用了<code class="eh kp kq kr ke b">newSum</code>函数3次，以便创建3个合同实例。为了检查最后一个实例的地址，我调用了函数<code class="eh kp kq kr ke b">sums</code>，传递<code class="eh kp kq kr ke b">2</code>的值作为参数(记住数组从0开始计数)。这可以在下图中看到。</p><figure class="jz ka kb kc fq iu fe ff paragraph-image"><div class="fe ff ma"><img src="../Images/a8878eb7167979b3a9ed46c42939a737.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*BUcJFwhpnzZ2ZN1IYt0qhg.png"/></div><figcaption class="lw lx fg fe ff ly lz bd b be z ek">Retrieving the address of the third instance created.</figcaption></figure><p id="03a8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在实例化新契约时，也可以传递参数。此类参数将是所创建的协定的构造函数的参数。例如，让我们在同一个文件中定义下面的简单契约。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="cba9" class="ki kj ht ke b fv kk kl l km kn">contract Token {<br/>   string public name;<br/>   constructor(string memory _name) {<br/>      name = _name;<br/>   }<br/>}</span></pre><p id="27a2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">上面的契约只有一个公共状态变量<code class="eh kp kq kr ke b">name</code>，它是通过构造函数赋值的。</p><p id="f645" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在让我们在<code class="eh kp kq kr ke b">Fabric</code>契约中编写一个函数，创建这个契约的新实例。在契约中包括下面的状态变量和函数。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="fa72" class="ki kj ht ke b fv kk kl l km kn">address[] public tokens;</span><span id="5bf7" class="ki kj ht ke b fv ko kl l km kn">function newToken(string memory _name) public {<br/>   Token token = new Token(_name);<br/>   tokens.push(address(token));<br/>}</span></pre><p id="5073" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">参数通过<strong class="jd hu">新的</strong>方法在构造函数中传递。一般来说，这就是我们在面向对象语言中创建类的方式。</p><h1 id="b251" class="ks kj ht bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo dt translated">调用合同中的函数</h1><p id="49b2" class="pw-post-body-paragraph jb jc ht jd b je lp jg jh ji lq jk jl jm lr jo jp jq ls js jt ju lt jw jx jy hm dt translated">当我们通过<em class="lu"> new </em>方法创建一个新契约时，返回的是它的一个实例。我们可以使用这个实例来调用创建的契约的公共或外部函数。</p><p id="a0d2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">例如，<code class="eh kp kq kr ke b">Token</code>契约有一个公共状态变量<code class="eh kp kq kr ke b">name</code>。公共状态变量生成允许您检索它们的值的方法。为了调用这个函数，给定一个名为<code class="eh kp kq kr ke b">token</code>的实例，我们可以编写下面的语句。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="83e6" class="ki kj ht ke b fv kk kl l km kn">token.name();</span></pre><p id="2e1a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们已经看到，可以将契约实例转换为address类型的变量，如<code class="eh kp kq kr ke b">address(token)</code>。我们这样做是为了将令牌地址存储在<code class="eh kp kq kr ke b">tokens</code>地址数组中。也可以反过来，将地址转换成实例。下面我们来看看函数。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="aed0" class="ki kj ht ke b fv kk kl l km kn">function getTokenName(uint8 _tokenId) public view returns (string memory) {<br/>   string memory name = Token(tokens[_tokenId]).name();<br/>   return name;<br/>}</span></pre><p id="35a5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">表达式<code class="eh kp kq kr ke b">tokens[_tokenId]</code>返回一个地址，存储在<code class="eh kp kq kr ke b">tokens</code>数组的<code class="eh kp kq kr ke b">_tokenId</code>索引中。然后我们使用语法<code class="eh kp kq kr ke b">Token([address])</code>转换成类型<code class="eh kp kq kr ke b">Token</code>的实例。最后，我们使用语法<code class="eh kp kq kr ke b">instance.method()</code>调用函数<code class="eh kp kq kr ke b">name</code>。</p><p id="8fed" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在上面的例子中，我们调用了自己创建的契约中的一个函数，它的代码在同一个文件中。我们在任何契约中调用一个函数所需要的只是它的代码(或者它的接口)和地址。</p><p id="7a1f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在让我们来看看一份不是我们在真实的区块链上签订的合同。在我生命中的某个时刻，我在币安智能链测试网络上创建了一个ERC-20令牌，其符号为BTJ，地址如下:</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="1d0c" class="ki kj ht ke b fv kk kl l km kn">0x6aefd30f8d96D56bD0021853140BE84BdE134Af7</span></pre><p id="140d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我将编写一个简单的契约来检索该令牌的总供应量。以下代码可用于调用ERC-20标准令牌上的任何强制函数。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="7551" class="ki kj ht ke b fv kk kl l km kn">pragma solidity ^0.8.4;</span><span id="2b85" class="ki kj ht ke b fv ko kl l km kn">import "<a class="ae mb" href="http://twitter.com/openzeppelin/contracts" rel="noopener ugc nofollow" target="_blank">@openzeppelin/contracts</a>/token/ERC20/IERC20.sol";</span><span id="b218" class="ki kj ht ke b fv ko kl l km kn">contract InvokeToken {<br/>   function invokeTotalSupply(address _address) public view returns (uint256) {<br/>      IERC20 token = IERC20(_address);<br/>      return token.totalSupply();<br/>    } <br/>}</span></pre><p id="9869" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在<code class="eh kp kq kr ke b">invokeTotalSupply</code>函数中，我们检索位于地址<code class="eh kp kq kr ke b">_address</code>的ERC-20令牌的一个实例。注意，我们没有创建一个新的实例(我们没有使用<em class="lu"> new </em>关键字)，我们只是检索一个现有的实例。</p><p id="afdc" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们可以这样做，因为我们有合同接口，它是用<code class="eh kp kq kr ke b">import</code>关键字导入的。我们会看到接口是什么，但基本上它是契约所有功能的定义，没有它的主体。在这种情况下，拥有接口几乎等同于拥有ABI。</p><p id="2ea5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">将上述代码部署到币安智能链测试网后，我们可以调用<code class="eh kp kq kr ke b">invokeTotalSupply</code>函数。结果可以在下图中看到。</p><figure class="jz ka kb kc fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mc"><img src="../Images/e65e7f9efa4f068a4aeb140ec2aa376f.png" data-original-src="https://miro.medium.com/v2/resize:fit:804/format:webp/1*gDIH82TWo-KloeaUpovKNw.png"/></div></div><figcaption class="lw lx fg fe ff ly lz bd b be z ek">Creating a function to retrieve the total supply of another contract through its address.</figcaption></figure><p id="2262" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">上述合同能够恢复币安测试网上任何标准ERC20合同的总供应量。为此，只需将其地址作为参数传递给函数。</p><p id="aebb" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">感谢阅读！</strong></p><p id="3bcd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎对本文提出意见和建议。</p><p id="c5b3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎任何投稿。<a class="ae mb" href="http://www.buymeacoffee.com/jpmorais" rel="noopener ugc nofollow" target="_blank">www.buymeacoffee.com/jpmorais</a>。</p><blockquote class="md"><p id="a431" class="me mf ht bd mg mh mi mj mk ml mm jy ek translated">交易新手？尝试<a class="ae mb" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae mb" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>