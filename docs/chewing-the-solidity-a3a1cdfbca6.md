# 咀嚼坚实

> 原文：<https://medium.com/coinmonks/chewing-the-solidity-a3a1cdfbca6?source=collection_archive---------27----------------------->

继续我们的区块链系列，这是坚实基础的第一部分。
***合同支付{
函数支付者()公共应付{
}}***

上面的代码片段是发送一些加密支付到一个特定的地址，但它似乎是一种外来的语言。没有吗？为了更好地理解这一点，让我们深入了解关于坚固的一切。Solidity 是一种高级静态类型的区分大小写的编程语言。

## 混合 IDE

像其他编程语言一样，我们需要一个 IDE 来编写和编译 Solidity。通常，我们使用 Remix。
remix 是用于开发、部署和管理的开源 IDE。它支持 Solidity 和 Vyper。混音是基于 javascript 编码和构建的。

## 智能合同编制

每个智能合约都有一个带**的源文件。sol** 作为扩展。它在 Solidity 编译器上编译。有两个组成部分与之相关- ABI 和字节码。
计算机科学上下文中的 ABI(应用程序二进制接口)是两个程序模块之间的接口，通常是操作系统和用户程序之间的接口。
而字节码是被解析、编译、包含的实际代码。它包含与 blocks 模块相关的程序、合同和文件的基本信息。
关于 ABI 和字节码的具体信息-

*   契约字节码是可读形式的公共代码，
*   契约不必是公开的，
*   字节码是不可变的，
*   ABI 充当应用程序和智能合约之间的桥梁，
*   没有源代码就无法生成 ABI 和字节码。

现在，让我们开始关于可靠性的实际编码工作。是时候弄脏我们的手了…

在开始编程代码之前，我们必须初始化许可证细节，这些细节将在编译时进行验证。
***SPDX-License-Identifier:GPL-3.0*** 现在第二行要讲的是 solidity 版本。 ***pragma 实度≥0 . 7 . 0<0 . 9 . 0；*** 以上语法表示我们使用的是任何大于等于 0.7.0 且低于 0.9.0 的 Solidity 版本。一旦我们在 solidity 程序文件的顶部指明了这两条信息，我们就可以开始我们面向目标的编程语法了。

## 构造器

Constructor 是 Solidity 中使用的保留关键字，用于创建更像“object”的新实例。构造函数是任何给定的 Solidity 编程语言中最重要的部分。一个构造者的一些重要特征是-

*   它只执行一次，
*   在一个 solidity 程序中，我们只能创建一个构造函数，
*   如果没有显式定义的构造函数，编译器会创建一个默认的构造函数。

> 交易新手？试试[加密交易机器人](/coinmonks/crypto-trading-bot-c2ffce8acb2a)或者[复制交易](/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c)

## **Solidity 中的数据类型**

像其他编程语言一样，Solidity 也有一些默认的数据类型- *Boolean、unit、int、address、bytes 和 string。*

## *整数*

我们用两个关键字来表示整数——int，unit。int 用于有符号整数，unit 用于无符号整数。
int 的范围是从 int8 到 int256，其中每增加一步，对应的大小为 8。对于 uint 也是如此，即范围从 uint8 到 uint256。
默认情况下，int 和 unit 都是 256。两者的默认值都是 0。

## 排列

数组用于存储数据、值等，数组有两种类型:静态和动态。
动态数组的大小在初始化时是不固定的，静态数组也是如此。
***uint[]public arr；*** —这表示一个动态数组，因为我们声明了一个数组，但没有绑定它的大小。
While***uint[4]public arr =[1，2，3，4]；*** *—它*是静态数组，因为我们在声明它的时候附加了关于数组大小的信息。

## 布尔代数学体系的

布尔仅用于存储**真**或**假**。

## 结构

该结构是一种复杂的数据类型，它是在基本数据类型的帮助下形成的。
结构可以在构造内部或外部声明。在外部声明它意味着它可以被多个契约访问。
**例-**
结构学校{
uint 卷；
字符串名称；
}

## 列举型别

当我们给某个常数/数指定一个特定的名字时，它就被称为枚举。
**示例-** 构造状态{
枚举学生{已注册，未 _ 注册，已列入等待列表}
学生公共学生 _ 1 =学生.未 _ 注册；
}student _ 1 的打印值会给出 1 作为结果，因为枚举是从 0 开始的。

这些是与 Solidity 编程语言相关的基础知识。为了能够在 solidity 中编码和编写我们的第一个智能合同，我将再分享一篇文章，这基本上是 Solidity 基础的第二部分，题为“消化 Solidity”。感谢你的时间，直到下一个博客，让我们继续链接块！