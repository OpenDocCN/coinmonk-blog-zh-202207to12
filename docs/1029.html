<html>
<head>
<title>Rentable NFTs ( ERC-4907) : Part II</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可出租的国家森林公园(ERC-4907):第二部分</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/rentable-nfts-erc-4907-part-ii-954cc27d22e9?source=collection_archive---------0-----------------------#2022-07-21">https://medium.com/coinmonks/rentable-nfts-erc-4907-part-ii-954cc27d22e9?source=collection_archive---------0-----------------------#2022-07-21</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><blockquote class="iq ir is"><p id="e369" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hm dt translated"><strong class="iw hu">可靠性</strong>智能合同实施和使用<strong class="iw hu"> Brownie </strong>进行测试</p></blockquote><figure class="js jt ju jv fq jw"><div class="bz el l di"><div class="jx jy l"/></div><figcaption class="jz ka fg fe ff kb kc bd b be z ek">Rentable NFTs</figcaption></figure><h1 id="aad8" class="kd ke ht bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">介绍</h1><p id="1a43" class="pw-post-body-paragraph it iu ht iw b ix lb iz ja jb lc jd je ld le jh ji lf lg jl jm lh li jp jq jr hm dt translated">欢迎回到<strong class="iw hu"> <em class="iv">系列第二部</em></strong><em class="iv"/>！！！<br/>在<a class="ae lj" rel="noopener" href="/coinmonks/rentable-nfts-erc-4907-949225d476a9"><strong class="iw hu"><em class="iv"/></strong></a>的第一部分中，我们已经讨论过:</p><ul class=""><li id="217b" class="lk ll ht iw b ix iy jb jc ld lm lf ln lh lo jr lp lq lr ls dt translated">NFT租赁和传统租赁系统</li><li id="9bf5" class="lk ll ht iw b ix lt jb lu ld lv lf lw lh lx jr lp lq lr ls dt translated">双重角色NFT租赁标准</li><li id="50cf" class="lk ll ht iw b ix lt jb lu ld lv lf lw lh lx jr lp lq lr ls dt translated">IERC 4907</li></ul><p id="979b" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je ld jg jh ji lf jk jl jm lh jo jp jq jr hm dt translated">现在，我们已经了解了NFT租赁的核心概念，让我们开始使用IERC 4907实现可租赁的NFT智能合同。这可能会成为一篇冗长的阅读文章，因为我们将会对合同和测试用例进行彻底的解释。</p><pre class="js jt ju jv fq ly lz ma mb aw mc dt"><span id="2851" class="md ke ht lz b fv me mf l mg mh"><strong class="lz hu">Note</strong>: <br/>The logic for renting used here are only for mock implementation purposes.<br/>For better understanding of this blog, Please have a quick look into the <a class="ae lj" rel="noopener" href="/coinmonks/rentable-nfts-erc-4907-949225d476a9"><em class="iv">Part1</em></a> of the series.</span></pre><h1 id="276d" class="kd ke ht bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">智能合同</h1><figure class="js jt ju jv fq jw fe ff paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="fe ff mi"><img src="../Images/069d981368ae5053fb828372e41d5fa2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OT1ruWe8j1UNr3v4hHiY6Q.png"/></div></div><figcaption class="jz ka fg fe ff kb kc bd b be z ek">ERC4907.sol : <a class="ae lj" href="https://github.com/sidarth16/Rentable-NFTs/blob/main/contracts/RentableNft.sol" rel="noopener ugc nofollow" target="_blank">raw_source_code</a></figcaption></figure><blockquote class="iq ir is"><p id="87d4" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hm dt translated">关注我的Github repo获取完整代码:<a class="ae lj" href="https://github.com/sidarth16/Rentable-NFTs" rel="noopener ugc nofollow" target="_blank"><strong class="iw hu">Rentable-Nfts</strong></a></p></blockquote><h1 id="60f3" class="kd ke ht bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">合同解释:</h1><blockquote class="iq ir is"><p id="cc41" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hm dt translated">智能协定的代码演练和解释实现</p></blockquote><h1 id="03a0" class="kd ke ht bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated"><strong class="ak">继承</strong>:</h1><ul class=""><li id="0c27" class="lk ll ht iw b ix lb jb lc ld mp lf mq lh mr jr lp lq lr ls dt translated"><strong class="iw hu">ERC721 . sol<br/>T40】继承了ERC 721令牌标准的所有功能。</strong></li><li id="fcca" class="lk ll ht iw b ix lt jb lu ld lv lf lw lh lx jr lp lq lr ls dt translated">IERC4907.sol <br/> 继承了接口<a class="ae lj" href="https://github.com/sidarth16/Rentable-NFTs/blob/main/interfaces/IERC4907.sol" rel="noopener ugc nofollow" target="_blank"><em class="iv">ierc 4907</em></a><em class="iv">r</em>enting功能，需要在我们的合同中实现。</li></ul><h1 id="697d" class="kd ke ht bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">设置全局变量:</h1><pre class="js jt ju jv fq ly lz ma mb aw mc dt"><span id="fe4c" class="md ke ht lz b fv me mf l mg mh"><strong class="lz hu">struct UserInfo{<br/>   </strong>address<strong class="lz hu"> user;   // </strong><em class="iv">address of user role</em><strong class="lz hu"><br/>   </strong>uint64<strong class="lz hu"> expires; // </strong><em class="iv">unix timestamp, user expires</em><strong class="lz hu"><br/>}</strong></span><span id="2046" class="md ke ht lz b fv ms mf l mg mh"><strong class="lz hu">mapping (uint256  =&gt; UserInfo) </strong>private<strong class="lz hu"> _users;</strong></span></pre><ul class=""><li id="f168" class="lk ll ht iw b ix iy jb jc ld lm lf ln lh lo jr lp lq lr ls dt translated"><strong class="iw hu"> struct UserInfo </strong> : <br/>存储用户<code class="eh mt mu mv lz b">address</code>和各自的用户<code class="eh mt mu mv lz b">expires</code> UNIX时间戳</li><li id="9205" class="lk ll ht iw b ix lt jb lu ld lv lf lw lh lx jr lp lq lr ls dt translated"><strong class="iw hu">_ users</strong>:<br/>token id到其各自<code class="eh mt mu mv lz b">userInfo</code>结构的映射。</li></ul><h1 id="ac3b" class="kd ke ht bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">功能:</h1><h2 id="96e8" class="md ke ht bd kf mw mx my kj mz na nb kn ld nc nd kr lf ne nf kv lh ng nh kz ni dt translated"><strong class="ak">setUser(</strong>uint 256<strong class="ak">token id，</strong> address <strong class="ak"> user，</strong> uint64 <strong class="ak"> expires) </strong></h2><pre class="js jt ju jv fq ly lz ma mb aw mc dt"><span id="2704" class="md ke ht lz b fv me mf l mg mh"><strong class="lz hu">function setUser</strong>(uint256 <strong class="lz hu">tokenId</strong>, address <strong class="lz hu">user</strong>, uint64 <strong class="lz hu">expires</strong>)<br/>   public override virtual<br/><strong class="lz hu">{</strong><br/>  <strong class="lz hu">require</strong>(<strong class="lz hu">_isApprovedOrOwner(msg.sender, tokenId)</strong>,<br/>          "ERC721: caller is not owner nor approved");<br/>  <strong class="lz hu">require</strong>(<strong class="lz hu">userOf(tokenId)==address(0)</strong>,"User already assigned");<br/>  <strong class="lz hu">require</strong>(<strong class="lz hu">expires &gt; block.timestamp</strong>, "expires should be in future");<br/>  <strong class="lz hu">UserInfo </strong>storage <strong class="lz hu">info</strong> =  _users[tokenId];<br/>  <strong class="lz hu">info.user </strong>= user;<br/>  <strong class="lz hu">info.expires</strong> = expires;<br/>  <strong class="lz hu">emit UpdateUser(tokenId,user,expires);</strong><br/><strong class="lz hu">}</strong></span></pre><p id="824d" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je ld jg jh ji lf jk jl jm lh jo jp jq jr hm dt translated">该函数用于给给定的<code class="eh mt mu mv lz b">tokenId</code>设置一个<code class="eh mt mu mv lz b">user</code>，直到给定的UNIX <code class="eh mt mu mv lz b">expires</code>时间戳。</p><p id="5ecf" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je ld jg jh ji lf jk jl jm lh jo jp jq jr hm dt translated">在这里，我们首先检查:</p><ul class=""><li id="ca30" class="lk ll ht iw b ix iy jb jc ld lm lf ln lh lo jr lp lq lr ls dt translated"><code class="eh mt mu mv lz b">msg.sender</code>被授权设置用户。</li><li id="252e" class="lk ll ht iw b ix lt jb lu ld lv lf lw lh lx jr lp lq lr ls dt translated">用户已经被设置到此<code class="eh mt mu mv lz b">tokenId</code>。</li><li id="fbaf" class="lk ll ht iw b ix lt jb lu ld lv lf lw lh lx jr lp lq lr ls dt translated"><code class="eh mt mu mv lz b">expires</code> UNIX时间戳有效</li><li id="228c" class="lk ll ht iw b ix lt jb lu ld lv lf lw lh lx jr lp lq lr ls dt translated">一旦验证完成，细节在<code class="eh mt mu mv lz b">userInfo</code>中更新并映射到给定的<code class="eh mt mu mv lz b">tokenId</code>。</li><li id="553a" class="lk ll ht iw b ix lt jb lu ld lv lf lw lh lx jr lp lq lr ls dt translated">最后，一旦用户被设置，事件<code class="eh mt mu mv lz b">UpdateUser</code>被发出。</li></ul><h2 id="f409" class="md ke ht bd kf mw mx my kj mz na nb kn ld nc nd kr lf ne nf kv lh ng nh kz ni dt translated"><strong class="ak">user of(</strong>uint 256<strong class="ak">token id)</strong></h2><pre class="js jt ju jv fq ly lz ma mb aw mc dt"><span id="e19d" class="md ke ht lz b fv me mf l mg mh"><strong class="lz hu">function userOf</strong>(uint256 <strong class="lz hu">tokenId</strong>)<br/>   public view override virtual <strong class="lz hu">returns</strong>(<strong class="lz hu">address</strong>)<br/><strong class="lz hu">{</strong><br/>   if( uint256(<strong class="lz hu">_users[tokenId].expires</strong>) &gt;=  <strong class="lz hu">block.timestamp</strong>){<br/>      return <strong class="lz hu">_users[tokenId].user</strong>;<br/>   }<br/>   return <strong class="lz hu">address(0)</strong>;<br/><strong class="lz hu">}</strong></span></pre><ul class=""><li id="3307" class="lk ll ht iw b ix iy jb jc ld lm lf ln lh lo jr lp lq lr ls dt translated">该视图函数返回<code class="eh mt mu mv lz b">tokenId</code>的当前活动用户。</li><li id="43b4" class="lk ll ht iw b ix lt jb lu ld lv lf lw lh lx jr lp lq lr ls dt translated">这里我们从<code class="eh mt mu mv lz b">userInfo</code>映射中检索tokenId的<code class="eh mt mu mv lz b">expires</code>。如果当前时间戳仍然小于过期时间戳，我们返回用户，如在<code class="eh mt mu mv lz b">userInfo</code>中，因为他仍然是NFT的活动用户。</li><li id="8176" class="lk ll ht iw b ix lt jb lu ld lv lf lw lh lx jr lp lq lr ls dt translated">每当给定的<code class="eh mt mu mv lz b">tokenId</code>没有当前活动用户时，返回零地址</li></ul><h2 id="64d0" class="md ke ht bd kf mw mx my kj mz na nb kn ld nc nd kr lf ne nf kv lh ng nh kz ni dt translated">用户过期(uint256令牌Id)</h2><pre class="js jt ju jv fq ly lz ma mb aw mc dt"><span id="e363" class="md ke ht lz b fv me mf l mg mh"><strong class="lz hu">function userExpires(</strong>uint256<strong class="lz hu"> tokenId) </strong><br/>   public view override virtual <strong class="lz hu">returns</strong>(<strong class="lz hu">uint256</strong>)<br/><strong class="lz hu">{ <br/>   </strong>return <strong class="lz hu">_users[tokenId].expires</strong>;<br/><strong class="lz hu">}</strong></span></pre><ul class=""><li id="e5c9" class="lk ll ht iw b ix iy jb jc ld lm lf ln lh lo jr lp lq lr ls dt translated">该视图函数返回<code class="eh mt mu mv lz b">tokenId</code>的用户到期时间戳。</li><li id="0dbf" class="lk ll ht iw b ix lt jb lu ld lv lf lw lh lx jr lp lq lr ls dt translated">这里我们访问<code class="eh mt mu mv lz b">_users</code>映射来检索<code class="eh mt mu mv lz b">tokenId</code>的<code class="eh mt mu mv lz b">userInfo</code>结构并返回<code class="eh mt mu mv lz b">expiry</code>时间戳。</li></ul><h2 id="1e63" class="md ke ht bd kf mw mx my kj mz na nb kn ld nc nd kr lf ne nf kv lh ng nh kz ni dt translated">nftMint()</h2><pre class="js jt ju jv fq ly lz ma mb aw mc dt"><span id="0658" class="md ke ht lz b fv me mf l mg mh"><strong class="lz hu">function nftMint()</strong> public returns (<strong class="lz hu">uint256</strong>)<br/><strong class="lz hu">{</strong><br/>   _tokenIdCounter.increment();<br/>   uint256 <strong class="lz hu">tokenId</strong> = _tokenIdCounter.current();<br/>   <strong class="lz hu">_safeMint(msg.sender, tokenId)</strong>;<br/>   return <strong class="lz hu">tokenId</strong>;<br/><strong class="lz hu">}</strong></span></pre><ul class=""><li id="6691" class="lk ll ht iw b ix iy jb jc ld lm lf ln lh lo jr lp lq lr ls dt translated">简单如说，这个函数是用来将<code class="eh mt mu mv lz b">mint</code>721-NFTs到<code class="eh mt mu mv lz b">msg.sender</code></li></ul><h2 id="ad52" class="md ke ht bd kf mw mx my kj mz na nb kn ld nc nd kr lf ne nf kv lh ng nh kz ni dt translated">_ before token transfer(address from，address to，uint256 tokenId)</h2><pre class="js jt ju jv fq ly lz ma mb aw mc dt"><span id="f7dc" class="md ke ht lz b fv me mf l mg mh"><strong class="lz hu">function _beforeTokenTransfer</strong>(<br/>   address <strong class="lz hu">from</strong>, address <strong class="lz hu">to,</strong> uint256 <strong class="lz hu">tokenId</strong>)<br/>   internal virtual override<br/><strong class="lz hu">{<br/>   super._beforeTokenTransfer(from, to, tokenId);</strong><br/>   if (<br/>       <strong class="lz hu">from</strong> != <strong class="lz hu">to</strong> &amp;&amp;<br/>       <strong class="lz hu">_users[tokenId].user</strong> != <strong class="lz hu">address(0)</strong> &amp;&amp;    <em class="iv">//user still present</em><br/>       <strong class="lz hu">block.timestamp</strong> &gt;= <strong class="lz hu">_users[tokenId].expires    </strong><em class="iv">// user expired<br/>   </em>){<br/>        <strong class="lz hu">delete</strong> _users[tokenId];<br/>        <strong class="lz hu">emit UpdateUser(tokenId, address(0), 0);</strong><br/>   }<strong class="lz hu"><br/>}</strong></span></pre><ul class=""><li id="2119" class="lk ll ht iw b ix iy jb jc ld lm lf ln lh lo jr lp lq lr ls dt translated">这个函数只是进行一些基本的内务处理，并删除不需要的数据，如果存在的话。</li><li id="c495" class="lk ll ht iw b ix lt jb lu ld lv lf lw lh lx jr lp lq lr ls dt translated">如果过期的用户仍然保留在用户映射的内部记账中(<code class="eh mt mu mv lz b">_users</code>)，则是多余的不需要的数据。</li><li id="8657" class="lk ll ht iw b ix lt jb lu ld lv lf lw lh lx jr lp lq lr ls dt translated">在传送NFT和相应更新事件被发出之前，这些过时的映射被移除和删除。</li></ul></div><div class="ab cl nj nk hb nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="hm hn ho hp hq"><p id="efbb" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je ld jg jh ji lf jk jl jm lh jo jp jq jr hm dt nq translated">现在我们已经准备好了合同，让我们使用Brownie框架进行一些基本的功能测试。</p></div><div class="ab cl nj nk hb nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="hm hn ho hp hq"><blockquote class="nz"><p id="0494" class="oa ob ht bd oc od oe of og oh oi jr ek translated"><em class="oj">“使用荷兰拍卖机制进行IPO / ICO的基本演练，以及为什么它在区块链市场被广泛采用。！! "<br/>查看:</em> <a class="ae lj" rel="noopener" href="/coinmonks/dutch-auction-ipo-ico-e02d4441a286"> <em class="oj">荷兰拍卖— IPO/ICO </em> </a></p></blockquote></div><div class="ab cl nj nk hb nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="hm hn ho hp hq"><h1 id="555f" class="kd ke ht bd kf kg ok ki kj kk ol km kn ko om kq kr ks on ku kv kw oo ky kz la dt translated">布朗尼测试:</h1><blockquote class="iq ir is"><p id="0cf3" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hm dt translated">使用Brownie进行智能合约测试</p></blockquote><pre class="js jt ju jv fq ly lz ma mb aw mc dt"><span id="0250" class="md ke ht lz b fv me mf l mg mh"><strong class="lz hu">NOTE:</strong> <em class="iv">Refer </em><a class="ae lj" href="https://eth-brownie.readthedocs.io/en/stable/index.html" rel="noopener ugc nofollow" target="_blank"><em class="iv">Brownie docs</em></a><em class="iv"> for setting up brownie environment</em></span></pre><figure class="js jt ju jv fq jw"><div class="bz el l di"><div class="jx jy l"/></div><figcaption class="jz ka fg fe ff kb kc bd b be z ek">Brownie Test</figcaption></figure><blockquote class="iq ir is"><p id="5db8" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hm dt translated">Brownie设置和测试用例的完整代码请参考这里:<a class="ae lj" href="https://github.com/sidarth16/Rentable-NFTs/blob/main/tests/test_rentable.py" rel="noopener ugc nofollow" target="_blank"><strong class="iw hu">Test _ rentable . py</strong></a></p></blockquote><h2 id="94d8" class="md ke ht bd kf mw mx my kj mz na nb kn ld nc nd kr lf ne nf kv lh ng nh kz ni dt translated">初始设置</h2><pre class="js jt ju jv fq ly lz ma mb aw mc dt"><span id="e055" class="md ke ht lz b fv me mf l mg mh">from <strong class="lz hu">brownie</strong> import <strong class="lz hu">ERC4907</strong>, <strong class="lz hu">accounts</strong>, <strong class="lz hu">chain</strong><br/>import <strong class="lz hu">brownie</strong><br/>import <strong class="lz hu">pytest</strong><br/>from <strong class="lz hu">web3.constants</strong> import <strong class="lz hu">ADDRESS_ZERO</strong></span><span id="6ee7" class="md ke ht lz b fv ms mf l mg mh"><strong class="lz hu">deployer</strong> =<strong class="lz hu"> owner1</strong> = <strong class="lz hu">owner2</strong> = <strong class="lz hu">user1</strong> = <strong class="lz hu">user2</strong>  = None<br/><strong class="lz hu">DAY</strong> = 1 * 24 * 60 * 60</span><span id="ad19" class="md ke ht lz b fv ms mf l mg mh"><strong class="lz hu">@pytest.fixture(scope="module")<br/>def testNft():</strong><br/>   <strong class="lz hu">global</strong> deployer, owner1, owner2, user1, user2<br/>   deployer, owner1, owner2, user1, user2 = <strong class="lz hu">accounts[0:5]</strong><br/>   <strong class="lz hu">testNft</strong> = <strong class="lz hu">ERC4907.deploy(</strong>{"from":deployer}<strong class="lz hu">)</strong><br/>   <strong class="lz hu">return testNft</strong></span></pre><p id="2661" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je ld jg jh ji lf jk jl jm lh jo jp jq jr hm dt translated">导入所需的库后，我们用默认值初始化常量和全局变量。</p><p id="de2a" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je ld jg jh ji lf jk jl jm lh jo jp jq jr hm dt translated">函数<code class="eh mt mu mv lz b">testNft()</code>被赋予<code class="eh mt mu mv lz b">module</code>的范围，因此在测试模块开始时将仅被调用一次(与hardhat 中的 <code class="eh mt mu mv lz b"><em class="iv">before()</em></code> <em class="iv">相同)。相同的契约将被用于所有保持其状态的测试。然后，我们从部署者的帐户部署<code class="eh mt mu mv lz b">ERC907</code>合同。</em></p><h2 id="6f5b" class="md ke ht bd kf mw mx my kj mz na nb kn ld nc nd kr lf ne nf kv lh ng nh kz ni dt translated">测试案例1</h2><blockquote class="iq ir is"><p id="1dcd" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hm dt translated">铸造NFT并检查它们的用户和所有者</p></blockquote><pre class="js jt ju jv fq ly lz ma mb aw mc dt"><span id="f496" class="md ke ht lz b fv me mf l mg mh"><strong class="lz hu">def test_mint(testNft)</strong>:<br/>   <br/>   <strong class="lz hu"><em class="iv"># Mint Nfts</em></strong><br/>   <br/>   tx = <strong class="lz hu">testNft.nftMint</strong>({"<strong class="lz hu">from</strong>":<strong class="lz hu">owner1</strong>})<br/>   id1 = tx.return_value<br/>   print(f'Minted NFT ( TokenId : {id1} )')</span><span id="d3b0" class="md ke ht lz b fv ms mf l mg mh">   tx = <strong class="lz hu">testNft.nftMint</strong>({"<strong class="lz hu">from</strong>":<strong class="lz hu">owner2</strong>})<br/>   id2 = tx.return_value<br/>   print(f'Minted NFT ( TokenId : {id2} )')</span><span id="465a" class="md ke ht lz b fv ms mf l mg mh">   <strong class="lz hu"><em class="iv"># check Nft Balance</em></strong><br/>   assert testNft.<strong class="lz hu">balanceOf</strong>(owner1.address) == 1<br/>   assert testNft.<strong class="lz hu">balanceOf</strong>(owner2.address) == 1</span><span id="b769" class="md ke ht lz b fv ms mf l mg mh">   <strong class="lz hu"><em class="iv"># check Owners</em></strong><br/>   assert testNft.<strong class="lz hu">ownerOf</strong>(1) == owner1.address<br/>   assert testNft.<strong class="lz hu">ownerOf</strong>(2) == owner2.address</span><span id="b88e" class="md ke ht lz b fv ms mf l mg mh">   <strong class="lz hu"><em class="iv"># check Users</em></strong><br/>   assert testNft.<strong class="lz hu">userOf</strong>(1) == ADDRESS_ZERO<br/>   assert testNft.<strong class="lz hu">userOf</strong>(2) == ADDRESS_ZERO</span></pre><p id="2762" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je ld jg jh ji lf jk jl jm lh jo jp jq jr hm dt translated">使用我们已经部署的testNft合同。<strong class="iw hu"> <em class="iv">拥有者1 </em> </strong>和<strong class="iw hu"> <em class="iv">拥有者2 </em> </strong>铸造他们的NFTS。我们断言这些生成的令牌id的所有者和用户详细信息的正确性</p><h2 id="b70a" class="md ke ht bd kf mw mx my kj mz na nb kn ld nc nd kr lf ne nf kv lh ng nh kz ni dt translated">测试案例2</h2><blockquote class="iq ir is"><p id="9521" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hm dt translated">分配用户角色并租用NFT</p></blockquote><pre class="js jt ju jv fq ly lz ma mb aw mc dt"><span id="e76a" class="md ke ht lz b fv me mf l mg mh"><strong class="lz hu">def test_renting(testNft):</strong></span><span id="d639" class="md ke ht lz b fv ms mf l mg mh">   rent_expire_time = chain.time() + <strong class="lz hu">2*DAY</strong></span><span id="211a" class="md ke ht lz b fv ms mf l mg mh">   <strong class="lz hu"><em class="iv"># set user to the NFTs</em></strong></span><span id="3c59" class="md ke ht lz b fv ms mf l mg mh">   testNft.<strong class="lz hu">setUser</strong>(<strong class="lz hu">1</strong>, <strong class="lz hu">user1</strong>.address, rent_expire_time,<br/>                   {"from" : owner1.address})</span><span id="ae34" class="md ke ht lz b fv ms mf l mg mh">   testNft.<strong class="lz hu">setUser</strong>(<strong class="lz hu">2</strong>, <strong class="lz hu">user2</strong>.address, rent_expire_time,<br/>                   {"from" : owner2.address})</span><span id="1c78" class="md ke ht lz b fv ms mf l mg mh">   <strong class="lz hu"><em class="iv"># check Owners</em></strong><br/>   assert testNft.<strong class="lz hu">ownerOf</strong>(1) == owner1.address<br/>   assert testNft.<strong class="lz hu">ownerOf</strong>(2) == owner2.address</span><span id="d81e" class="md ke ht lz b fv ms mf l mg mh">   <strong class="lz hu"><em class="iv"># check Users</em></strong><br/>   assert testNft.<strong class="lz hu">userOf</strong>(1) == user1.address<br/>   assert testNft.<strong class="lz hu">userOf</strong>(2) == user2.address</span><span id="cdd5" class="md ke ht lz b fv ms mf l mg mh">   <strong class="lz hu"><em class="iv"># Check expires</em></strong><br/>   assert testNft.<strong class="lz hu">userExpires</strong>(1)==rent_expire_time<br/>   assert testNft.<strong class="lz hu">userExpires</strong>(2)==rent_expire_time</span></pre><p id="2e50" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je ld jg jh ji lf jk jl jm lh jo jp jq jr hm dt translated">由于我们的NFT已经生成，我们现在将用户设置为令牌。<code class="eh mt mu mv lz b">user1</code>被赋予了<code class="eh mt mu mv lz b">tokenId: 1</code>的用户角色，而<code class="eh mt mu mv lz b">tokenId: 1</code>是<code class="eh mt mu mv lz b">owner1</code>的用户，<code class="eh mt mu mv lz b">tokenId:2</code>也是如此。<code class="eh mt mu mv lz b">expires</code>时间戳被设置为从当前时间戳起2天</p><p id="ed6f" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je ld jg jh ji lf jk jl jm lh jo jp jq jr hm dt translated">我们检查用户的详细信息是否正确更新，并且<br/>确保这不会影响这些令牌id的所有者。<code class="eh mt mu mv lz b">expires</code>时间戳应该等于<code class="eh mt mu mv lz b">rent_expire_time</code>(从当前时间算起2天)。</p><figure class="js jt ju jv fq jw fe ff paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="fe ff op"><img src="../Images/da55726dc1f6201c77c90b92b2058ca4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YFeoijZ4ubCnY9mFA9Yuyg.jpeg"/></div></div><figcaption class="jz ka fg fe ff kb kc bd b be z ek">Brownie Break</figcaption></figure><blockquote class="nz"><p id="4c50" class="oa ob ht bd oc od oq or os ot ou jr ek translated">“有没有想过Opensea <em class="oj">令牌ID </em>中的巨大数字到底是什么意思！! "<br/>结帐:<a class="ae lj" rel="noopener" href="/coinmonks/opensea-tokenid-explained-f420401f5109"><strong class="ak"><em class="oj">Opensea TokenId:Explained</em></strong></a></p></blockquote><h2 id="d96f" class="md ke ht bd kf mw ov my kj mz ow nb kn ld ox nd kr lf oy nf kv lh oz nh kz ni dt translated">测试案例3</h2><blockquote class="iq ir is"><p id="1163" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hm dt translated">不能将多个用户角色分配给单个NFT。</p></blockquote><pre class="js jt ju jv fq ly lz ma mb aw mc dt"><span id="6c1b" class="md ke ht lz b fv me mf l mg mh"><strong class="lz hu">def test_double_renting(testNft):</strong></span><span id="b36b" class="md ke ht lz b fv ms mf l mg mh">   <strong class="lz hu"><em class="iv"># Owner cannot rent a NFT to not more than 1 users</em></strong><br/>   <br/>   with brownie.<strong class="lz hu">reverts</strong>("<strong class="lz hu">User already assigned</strong>"):</span><span id="201e" class="md ke ht lz b fv ms mf l mg mh">      testNft.<strong class="lz hu">setUser(</strong><br/>                      <strong class="lz hu">1</strong>, user2.address, chain.time() + 1*DAY,<br/>                      {"from":owner1.address}<br/>      <strong class="lz hu">)</strong></span><span id="4f80" class="md ke ht lz b fv ms mf l mg mh">     testNft.<strong class="lz hu">setUser(</strong><br/>                      <strong class="lz hu">2</strong>, user1.address, chain.time() + 1*DAY,<br/>                      {"from":owner2.address}<br/>      <strong class="lz hu">)</strong></span></pre><p id="bd8c" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je ld jg jh ji lf jk jl jm lh jo jp jq jr hm dt translated">由于我们的NFT已经创建和租用，我们现在再次尝试将用户设置为令牌(tokenId 1和2)。因此，双重租用相同的代币。在这里，<code class="eh mt mu mv lz b">tokenId: 1</code>和<code class="eh mt mu mv lz b">tokenId: 2</code>的所有者分别试图再次将他们的NFT出租给<code class="eh mt mu mv lz b">user2 , user1</code>。在这样做的时候，我们期待一个回复消息，声明<code class="eh mt mu mv lz b"><em class="iv">"User Already Assigned"</em></code> <em class="iv">。</em>因此，明确<em class="iv"> </em>多个用户角色不能分配给单个NFT。</p><h2 id="1e5d" class="md ke ht bd kf mw mx my kj mz na nb kn ld nc nd kr lf ne nf kv lh ng nh kz ni dt translated">测试案例4</h2><blockquote class="iq ir is"><p id="7a68" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hm dt translated">作为所有者，Nft的用户没有权限/特权。</p></blockquote><pre class="js jt ju jv fq ly lz ma mb aw mc dt"><span id="b8ed" class="md ke ht lz b fv me mf l mg mh"><strong class="lz hu">def test_user_nft_transfer(testNft) :</strong></span><span id="f381" class="md ke ht lz b fv ms mf l mg mh">   <strong class="lz hu"># User should not be able to transfer NFTs</strong></span><span id="6f5c" class="md ke ht lz b fv ms mf l mg mh">   with brownie.<strong class="lz hu">reverts</strong>(<br/>    <strong class="lz hu">"ERC721: transfer caller is not owner nor approved"</strong>):</span><span id="2ed4" class="md ke ht lz b fv ms mf l mg mh">    testNft.<strong class="lz hu">safeTransferFrom</strong>(<br/>                             owner1.address, user1.address, <strong class="lz hu">1</strong>,<br/>                             {"from":<strong class="lz hu">user1</strong>.address}<br/>    )</span></pre><p id="265d" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je ld jg jh ji lf jk jl jm lh jo jp jq jr hm dt translated">这里我们执行一个非常简单的健全性检查，只是为了证明用户作为所有者没有权限和特权。这里，用户试图将NFT从所有者的地址转移到他自己的钱包地址。但是，我们期望交易回复到声明<code class="eh mt mu mv lz b">"<em class="iv">caller is not owner nor approved"</em></code> <em class="iv">。</em></p><h2 id="6d21" class="md ke ht bd kf mw mx my kj mz na nb kn ld nc nd kr lf ne nf kv lh ng nh kz ni dt translated">测试案例5</h2><blockquote class="iq ir is"><p id="1296" class="it iu iv iw b ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr hm dt translated">为Nft分配的用户角色在给定的过期时间戳后过期。</p></blockquote><pre class="js jt ju jv fq ly lz ma mb aw mc dt"><span id="554f" class="md ke ht lz b fv me mf l mg mh"><strong class="lz hu">def test_renting_expired(testNft):</strong></span><span id="be70" class="md ke ht lz b fv ms mf l mg mh">   <strong class="lz hu"># 2 days After Renting<br/>   </strong>chain.<strong class="lz hu">sleep</strong>(<strong class="lz hu">2*DAY</strong> + 1)      <em class="iv">#Fast forwarding 2 days</em><br/>   chain.mine(1)</span><span id="aee9" class="md ke ht lz b fv ms mf l mg mh">   <strong class="lz hu"># Check expires<br/>   </strong>assert testNft.<strong class="lz hu">userExpires</strong>(1) &lt; chain.time()<br/>   assert testNft.<strong class="lz hu">userExpires</strong>(2) &lt; chain.time()</span><span id="1a4f" class="md ke ht lz b fv ms mf l mg mh">   <strong class="lz hu"># check Users</strong><br/>   assert testNft.<strong class="lz hu">userOf</strong>(1) == ADDRESS_ZERO<br/>   assert testNft.<strong class="lz hu">userOf</strong>(2) == ADDRESS_ZERO</span></pre><p id="70c1" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je ld jg jh ji lf jk jl jm lh jo jp jq jr hm dt translated">在<em class="iv">测试用例2、</em>中，我们已经将租用<code class="eh mt mu mv lz b">expires</code>时间戳设置为从当前时间起2天。因此，为了检查过期功能，我们将时间戳快进到未来的2天，并尝试查询用户。<br/>我们首先确认当前时间戳大于用户的到期时间戳，确保用户的<em class="iv">租用已经到期</em>。<br/>既然租用用户已经到期，我们期待一个<code class="eh mt mu mv lz b">Zero Address</code>，请求当前活动用户的令牌id 1和2。</p><h1 id="040e" class="kd ke ht bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">编译并运行测试用例</h1><p id="3bf8" class="pw-post-body-paragraph it iu ht iw b ix lb iz ja jb lc jd je ld le jh ji lf lg jl jm lh li jp jq jr hm dt translated">现在测试用例准备好了，让我们测试brownie的契约。<br/>假设您的系统中已经设置了brownie env。确保您的<code class="eh mt mu mv lz b">Tests</code>文件夹中有test _ cases(<a class="ae lj" href="https://github.com/sidarth16/Rentable-NFTs/blob/main/tests/test_rentable.py" rel="noopener ugc nofollow" target="_blank"><em class="iv">test _ rentable . py</em></a>)。<br/>现在打开cmd并运行:</p><pre class="js jt ju jv fq ly lz ma mb aw mc dt"><span id="77c9" class="md ke ht lz b fv me mf l mg mh">&gt;&gt;&gt; brownie test -v</span></pre><figure class="js jt ju jv fq jw fe ff paragraph-image"><div role="button" tabindex="0" class="mj mk di ml bf mm"><div class="fe ff pa"><img src="../Images/3fe08620399f256cf53f58ea52a163df.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gkhUcKjU-LQ2NOJb8fLWOg.png"/></div></div></figure><p id="5e0d" class="pw-post-body-paragraph it iu ht iw b ix iy iz ja jb jc jd je ld jg jh ji lf jk jl jm lh jo jp jq jr hm dt translated">耶！我们所有的测试用例都成功地通过了。</p><h1 id="8b87" class="kd ke ht bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">结论:</h1><p id="6bdf" class="pw-post-body-paragraph it iu ht iw b ix lb iz ja jb lc jd je ld le jh ji lf lg jl jm lh li jp jq jr hm dt translated">通过这种双重角色的实现，现在可以高效地实现租用NFT。<br/>这里使用的租用逻辑仅用于<em class="iv">模拟实现</em>的目的。<br/>你可以根据需要随时更新实现的逻辑。其他功能如<code class="eh mt mu mv lz b">userTransfership()</code>等。。。可以添加到这个现有的实现中，使它更加有趣和有用。</p><h1 id="1649" class="kd ke ht bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la dt translated">创作者笔记</h1><p id="9f81" class="pw-post-body-paragraph it iu ht iw b ix lb iz ja jb lc jd je ld le jh ji lf lg jl jm lh li jp jq jr hm dt translated">非常感谢您的阅读。如果有任何疑问，请随时联系我们。<br/>关注区块链、NFTs、Defi、智能合约等更多内容<br/> <em class="iv">联系我</em><a class="ae lj" href="https://twitter.com/sidarthx0" rel="noopener ugc nofollow" target="_blank"><strong class="iw hu"><em class="iv">Twitter</em></strong></a><em class="iv"/><a class="ae lj" href="https://www.linkedin.com/in/sidarths/" rel="noopener ugc nofollow" target="_blank"><strong class="iw hu"><em class="iv">LinkedIn</em></strong></a><a class="ae lj" href="http://ssidarth1999@gmail.com/" rel="noopener ugc nofollow" target="_blank"><strong class="iw hu"><em class="iv">邮箱</em> </strong> </a>。</p></div></div>    
</body>
</html>