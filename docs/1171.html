<html>
<head>
<title>Learn Solidity lesson 8. Types, operators and enum.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习第八课“坚实”。类型、运算符和枚举。</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/learn-solidity-lesson-8-types-operators-and-enum-b5975aaa546f?source=collection_archive---------7-----------------------#2022-07-24">https://medium.com/coinmonks/learn-solidity-lesson-8-types-operators-and-enum-b5975aaa546f?source=collection_archive---------7-----------------------#2022-07-24</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/d778e9850fede307f90c04d9e7f60918.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iql7EQW8MkNERnDKN-9HZw.jpeg"/></div></div></figure><p id="43d8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">Solidity是一种静态类型语言，类型必须在变量声明的时候被赋值。这是必要的，因为区块链将在存储中为变量值保留一个专用空间。</p><p id="5ce6" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">存储器</strong>是存储区块链状态变量的地方。它是一个键/值存储，由数据库实现。通常使用LevelDB数据库，但是程序员不需要知道这样的实现细节。</p><p id="9fae" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">实体中的变量被分类为类型<strong class="jd hu">值</strong>或类型<strong class="jd hu">引用</strong>。值类型变量的值直接由变量存储，而引用类型变量指向存储值的位置。</p><p id="c2c7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">基本上，值类型变量的值最多可容纳32个字节，而引用类型变量的值是动态的，可能需要超过32个字节，如字符串、结构、数组和映射。</p><h1 id="9e51" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">文字</h1><p id="7691" class="pw-post-body-paragraph jb jc ht jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy hm dt translated">文字是给定类型的不可变值。Solidity中整数文字的例子有<code class="eh lc ld le lf b">3</code>和<code class="eh lc ld le lf b">-7</code>，第一个是类型<em class="lg"> int </em>(或<em class="lg"> uint </em>)的文字，第二个是类型<em class="lg"> int </em>的文字。</p><p id="5358" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu"> Boolean </strong>是编程语言中非常常见的类型，可以取两个值:<code class="eh lc ld le lf b">true</code>或<code class="eh lc ld le lf b">false</code>。这是这种类型仅有的两个文字。</p><p id="cf38" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">另一种类型的稳固性是<strong class="jd hu">地址</strong>。这不是编程语言中的标准类型，但在区块链很重要，因为它表示一个帐户。例如，这个类型的属性和方法允许检查一个帐户的余额，或者向它发送以太网。</p><p id="b7e0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">地址的文字是20字节的十六进制数，例如，<code class="eh lc ld le lf b">0xC66d07097f4823343bf116463070B3be5e941C4E</code>。前缀“0x”用于表示十六进制基数。</p><p id="9971" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">Solidity也有类型<strong class="jd hu"> byteX </strong>，其中<strong class="jd hu"> X </strong>表示该类型的字节数，范围从1到32。同样，最大字节数是32字节，与256位相同。这样做的原因是因为以太坊使用每个值为32字节的内存(以及数据库)。</p><p id="0d19" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">bytesX的文字是它的十六进制表示，作为一个由<em class="lg"> X </em>字节组成的数组。例如，字节2的文字是<code class="eh lc ld le lf b">0x83a3</code>，字节4的文字是<code class="eh lc ld le lf b">0x84a8b3cc</code>。</p><p id="864c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">字符串是引用类型的，因为它们的值不一定占用少于32个字节。它的文字用单引号或双引号括起来。文字的例子有<code class="eh lc ld le lf b">“Hello”</code>和<code class="eh lc ld le lf b">‘World’</code>。</p><p id="3b91" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">Solidity中可以使用任何<strong class="jd hu"> Unicode </strong>字符，但是必须明确说明。Unicode是一种字符编码形式，包括许多语言的字符以及现代符号，如表情符号。Unicode字符可以占用1到4个字节。</p><p id="ab96" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果字符串文字有编译器错误，请尝试将该值显式指示为Unicode。例如，参见下面关于坚固性的声明。</p><pre class="lh li lj lk fq ll lf lm ln aw lo dt"><span id="db18" class="lp ka ht lf b fv lq lr l ls lt">string name = "João";</span></pre><p id="7849" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">编译器会显示一个错误，如下图所示。</p><figure class="lh li lj lk fq iu fe ff paragraph-image"><div class="fe ff lu"><img src="../Images/f4b15726fff2daab5b181727556503f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:894/format:webp/1*xO5BoTTOvcJht56UcsmfiQ.png"/></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">Some characters are not accepted by the compiler unless we indicate that they should be treated as Unicode.</figcaption></figure><p id="2a13" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">要修复这个错误，只需更改如下声明。</p><pre class="lh li lj lk fq ll lf lm ln aw lo dt"><span id="b619" class="lp ka ht lf b fv lq lr l ls lt">string name = unicode"João";</span></pre><p id="8f0f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">另一种可能是在Unicode中显式使用字符值，如下面的声明所示。</p><pre class="lh li lj lk fq ll lf lm ln aw lo dt"><span id="a66b" class="lp ka ht lf b fv lq lr l ls lt">string name = 'Jo\u00E3o';</span></pre><p id="43ef" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在整个课程中，我们将会看到更多其他类型的实性，尤其是动态类型，如结构、数组和映射。</p><h1 id="1dda" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">经营者</h1><p id="3d9b" class="pw-post-body-paragraph jb jc ht jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy hm dt translated">运算符类似于作用于表达式以返回某个值的函数。运算符对值进行运算以生成新值是很常见的。运算符的一个简单例子是sum运算符，它作用于两个整数并返回一个新的整数。</p><p id="0d56" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">Solidity和任何编程语言一样，有几个运算符，比如算术运算符、比较运算符等。我们不会详细讨论所有的问题，只是一些可能会引起混淆的问题。</p><p id="9f3e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">例如，sum运算符不能用于连接字符串。在许多编程语言中这是可能的，但在Solidity中不允许。禁止下列语句。</p><pre class="lh li lj lk fq ll lf lm ln aw lo dt"><span id="c7c1" class="lp ka ht lf b fv lq lr l ls lt">string name = "John " + "Paul";</span></pre><p id="5008" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">相反，您需要使用串联方法，如下面的语句所示。</p><pre class="lh li lj lk fq ll lf lm ln aw lo dt"><span id="15a7" class="lp ka ht lf b fv lq lr l ls lt">string name = string.concat("John","Paul");</span></pre><p id="2115" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">比较运算符是一个双等号<code class="eh lc ld le lf b">==</code>，而不等式运算符是<code class="eh lc ld le lf b">!=</code>。逻辑运算符有:<code class="eh lc ld le lf b">!</code>(否定)、<code class="eh lc ld le lf b">&amp;&amp;</code>(与)和<code class="eh lc ld le lf b">||</code>(或)。其他不那么显而易见的运算符是模数运算符<code class="eh lc ld le lf b">%</code>，它返回除法的余数，以及由运算符<code class="eh lc ld le lf b">**</code>执行的取幂运算。</p><h1 id="08f8" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">枚举</h1><p id="8a12" class="pw-post-body-paragraph jb jc ht jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy hm dt translated">枚举是用户定义的值类型。解释枚举类型的最好方式是用一个例子。假设我们正在创建一个帮助台程序，每个票证都有一个状态:打开、进度、关闭。</p><p id="db13" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">每张票从一个阶段移动到另一个阶段，这个赋值必须在程序中完成。为此，您需要做出如下陈述。</p><pre class="lh li lj lk fq ll lf lm ln aw lo dt"><span id="598b" class="lp ka ht lf b fv lq lr l ls lt">status = "open";</span></pre><p id="1762" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">假设程序员犯了一个错误，把一些字母从允许值改成了状态。</p><pre class="lh li lj lk fq ll lf lm ln aw lo dt"><span id="980e" class="lp ka ht lf b fv lq lr l ls lt">status = "opened";</span></pre><p id="9215" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这将创建一个不同于3个可接受值的新状态类型。为了尽量减少这种问题，建议使用枚举。</p><p id="54ca" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">使用枚举，可以使用预定义的选项定义新类型，如下所示。</p><pre class="lh li lj lk fq ll lf lm ln aw lo dt"><span id="058b" class="lp ka ht lf b fv lq lr l ls lt">enum Status {Open,Progress,Closed}</span></pre><p id="58e6" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在，我们可以将状态变量声明为<em class="lg">状态</em>类型，并使用枚举来更改其值，而不是将状态变量定义为字符串类型。让我们看看下面的语句作为例子。</p><pre class="lh li lj lk fq ll lf lm ln aw lo dt"><span id="d0b3" class="lp ka ht lf b fv lq lr l ls lt">Status status = Status.Open;</span></pre><p id="8afa" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">尽管是用户定义的类型，枚举变量的值还是一个数字。每个值按顺序被分配一个0到255之间的数字。在上面的示例中，打开状态相当于数字0，进度状态相当于数字1，关闭状态相当于数字2。</p><p id="ee3e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">要看到这一点，请编写以下契约。</p><pre class="lh li lj lk fq ll lf lm ln aw lo dt"><span id="8305" class="lp ka ht lf b fv lq lr l ls lt">//SPDX-License-Identifier: MIT<br/>pragma solidity ^0.8.12;</span><span id="13d8" class="lp ka ht lf b fv lz lr l ls lt">contract Enums {<br/>   enum Status {Open,Progress,Closed}<br/>   Status public status = Status.Closed;<br/>}</span></pre><p id="2903" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">保存合同并部署它。由于变量<code class="eh lc ld le lf b">status</code>是公共的，编译器将生成一个函数，允许我们检索它的值。当调用这个函数时，在Remix中，我们看到变量<code class="eh lc ld le lf b">status</code>的值为<code class="eh lc ld le lf b">2</code>，如下图所示。</p><figure class="lh li lj lk fq iu fe ff paragraph-image"><div class="fe ff ma"><img src="../Images/80a9f7cd1640995869ff9f12d8ab1f16.png" data-original-src="https://miro.medium.com/v2/resize:fit:854/format:webp/1*tKSmgNdfDWby0p9ZS7n-aQ.png"/></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">The enumeration is, in essence, a variable of type uint8.</figcaption></figure><p id="e7fa" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">本质上，枚举类型是一个类型为<em class="lg"> uint8 </em>的变量。它的主要功能是避免可能导致bug的错别字。</p><p id="1fdf" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">感谢阅读！</strong></p><p id="23d1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎任何投稿。<a class="ae mb" href="http://www.buymeacoffee.com/jpmorais" rel="noopener ugc nofollow" target="_blank">www.buymeacoffee.com/jpmorais</a></p><blockquote class="mc"><p id="9069" class="md me ht bd mf mg mh mi mj mk ml jy ek translated">交易新手？尝试<a class="ae mb" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae mb" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>