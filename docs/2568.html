<html>
<head>
<title>Data Storage in Solidity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">数据存储的可靠性</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/data-storage-in-solidity-83c7fa52587e?source=collection_archive---------30-----------------------#2022-08-22">https://medium.com/coinmonks/data-storage-in-solidity-83c7fa52587e?source=collection_archive---------30-----------------------#2022-08-22</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="ba5d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh jo jp jq jr b">storage</code>和<code class="eh jo jp jq jr b">memory</code>是Solidity中存储数据的两种方式。</p><p id="29b2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh jo jp jq jr b">memory</code>就像RAM存储，它的数据是易失的，它在每次调用结束时被销毁，在每次函数调用开始时被创建，类似于当计算机关机时RAM被擦除，当计算机启动和运行时数据被添加。</p><p id="91b2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh jo jp jq jr b">storage</code>就像硬盘一样，它的数据是不可变的，数据一旦设置，将在将来的函数调用中持续存在，类似于硬盘，当计算机关机时，其数据不会被擦除/销毁。</p><p id="72f0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">一般来说，除了函数的自变量和显式定义的<code class="eh jo jp jq jr b">memory</code>变量外，大多数数据类型都是</strong> <code class="eh jo jp jq jr b"><strong class="is hu">storage</strong></code>。</p><ul class=""><li id="ec22" class="js jt ht is b it iu ix iy jb ju jf jv jj jw jn jx jy jz ka dt translated"><strong class="is hu">状态变量</strong>和<strong class="is hu">结构</strong>的局部变量，数组默认总是存储在<code class="eh jo jp jq jr b">storage</code>中。</li></ul><pre class="kb kc kd ke fq kf jr kg kh aw ki dt"><span id="7929" class="kj kk ht jr b fv kl km l kn ko">uint totalCount;</span><span id="a116" class="kj kk ht jr b fv kp km l kn ko">address owner;</span><span id="3907" class="kj kk ht jr b fv kp km l kn ko">address[] participants;</span><span id="d151" class="kj kk ht jr b fv kp km l kn ko">string messageData;</span><span id="0704" class="kj kk ht jr b fv kp km l kn ko">struct person {<br/>   string name;<br/>   string age;<br/>}<br/>person[] personDatabase;</span><span id="8e48" class="kj kk ht jr b fv kp km l kn ko">mapping(uint =&gt; person) register;</span></pre><p id="489f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh jo jp jq jr b">totalCount</code>、<code class="eh jo jp jq jr b">owner</code>、<code class="eh jo jp jq jr b">participants</code>、<code class="eh jo jp jq jr b">messageData</code>、<code class="eh jo jp jq jr b">personDatabase</code>、<code class="eh jo jp jq jr b">register</code>都是<code class="eh jo jp jq jr b">storage</code>类型。</p><ul class=""><li id="8757" class="js jt ht is b it iu ix iy jb ju jf jv jj jw jn jx jy jz ka dt translated"><strong class="is hu">函数参数</strong>在<code class="eh jo jp jq jr b">memory</code>中。</li></ul><pre class="kb kc kd ke fq kf jr kg kh aw ki dt"><span id="60d2" class="kj kk ht jr b fv kl km l kn ko">string memory messageData;</span><span id="3bc8" class="kj kk ht jr b fv kp km l kn ko"><em class="kq">function</em> Action1(uint minimumBet, uint maxAmountOfBets, string memory userDescription) {...}</span></pre><p id="ed26" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh jo jp jq jr b">minimumBet</code>、<code class="eh jo jp jq jr b">maxAmountOfBets</code>、<code class="eh jo jp jq jr b">userDescription</code>都是记忆类型</p><ul class=""><li id="a605" class="js jt ht is b it iu ix iy jb ju jf jv jj jw jn jx jy jz ka dt translated">每当使用关键字<code class="eh jo jp jq jr b">memory</code>、<strong class="is hu">创建数组</strong>的新<strong class="is hu">实例时，在每次调用</strong>时都会创建该变量的新副本，因此，当数组在每次调用时被重置回原点时，更改新实例的数组值不会反映出来。</li></ul><blockquote class="kr"><p id="6f94" class="ks kt ht bd ku kv kw kx ky kz la jn ek translated">交易新手？尝试<a class="ae lb" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae lb" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>