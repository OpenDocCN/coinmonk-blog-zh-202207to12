<html>
<head>
<title>CSC101 -Abstract Contract</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CSC 101-抽象合同</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/csc101-abstract-contract-d6e4c32e82d2?source=collection_archive---------29-----------------------#2022-08-30">https://medium.com/coinmonks/csc101-abstract-contract-d6e4c32e82d2?source=collection_archive---------29-----------------------#2022-08-30</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="18db" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">抽象契约是一种具有抽象设计的契约，实现契约提供了抽象函数的实现。在前面的教程中，我们提到了抽象契约，现在让我们更深入一些。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff jo"><img src="../Images/78db353f85d00a7149d8bc2b6bc3c9de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nYib8N6wIy-Papn96wyEKg.png"/></div></div></figure><h2 id="265a" class="ka kb ht bd kc kd ke kf kg kh ki kj kk jb kl km kn jf ko kp kq jj kr ks kt ku dt translated">抽象合同</h2><p id="0bf1" class="pw-post-body-paragraph iq ir ht is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hm dt translated">抽象契约是至少有一个函数没有实现的契约，或者是在没有为所有的基契约构造函数提供参数的情况下。</p><p id="ec50" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">实体中的契约类似于面向对象语言中的类</p><p id="6b4e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">抽象合同是用<strong class="is hu">抽象</strong>关键字创建的合同。</p><p id="d292" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">语法:</strong></p><pre class="jp jq jr js fq la lb lc ld aw le dt"><span id="515d" class="ka kb ht lb b fv lf lg l lh li">abstract contract Contract_Name{<br/>    function Function_name() public virtual returns (bytes32);<br/>}</span></pre><p id="9fa8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">举例</strong>:</p><pre class="jp jq jr js fq la lb lc ld aw le dt"><span id="7662" class="ka kb ht lb b fv lf lg l lh li">contract Calculator {<br/>   function getResult() public virtual returns(uint);<br/>}<br/>contract Cal is Calculator {<br/>   function getResult() public view returns(uint) {<br/>      uint X = 1;<br/>      uint Y = 2;<br/>      uint result = a + b;<br/>      return result;<br/>   }<br/>}</span></pre><p id="9ca2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">注意</strong>:一旦创建了抽象契约，你需要使用is关键字来扩展它</p><p id="c972" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">抽象契约是一种不能自行部署的契约。抽象契约必须由另一个契约继承。</p><p id="ae67" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当您想要将模式灌输到您正在构建的dapp中时，抽象契约尤其有用。它们让你能够实现契约的大部分内容，但是你仍然可以在其中包含抽象函数，以便定义和自文档化你的dapp的框架。其他契约可以从抽象契约继承。</p><p id="5cfc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">抽象契约有点类似于接口，但它们之间存在一些差异。抽象契约可以定义函数签名，也可以实现它的一些功能。</p><h2 id="e123" class="ka kb ht bd kc kd ke kf kg kh ki kj kk jb kl km kn jf ko kp kq jj kr ks kt ku dt translated">抽象契约VS接口</h2><p id="0a84" class="pw-post-body-paragraph iq ir ht is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hm dt translated">接口类似于抽象契约，因为它必须被另一个像抽象契约一样的契约继承。接口函数的可见性必须标记为<strong class="is hu">外部</strong>。它不能有构造函数，也不能声明状态变量。</p><ul class=""><li id="c0f1" class="lk ll ht is b it iu ix iy jb lm jf ln jj lo jn lp lq lr ls dt translated">接口不能有构造函数，而抽象协定可以实现构造函数。</li><li id="c3ff" class="lk ll ht is b it lt ix lu jb lv jf lw jj lx jn lp lq lr ls dt translated">接口不能定义状态变量，但是抽象契约可以。</li><li id="e3e9" class="lk ll ht is b it lt ix lu jb lv jf lw jj lx jn lp lq lr ls dt translated">继承契约必须实现接口中定义的所有函数，而在抽象契约中，继承契约必须实现抽象契约的至少一个函数。</li><li id="0b22" class="lk ll ht is b it lt ix lu jb lv jf lw jj lx jn lp lq lr ls dt translated">抽象协定可以从另一个协定或抽象协定继承，而接口不能从协定或另一个接口继承。</li></ul><h2 id="e51d" class="ka kb ht bd kc kd ke kf kg kh ki kj kk jb kl km kn jf ko kp kq jj kr ks kt ku dt translated">什么时候应该使用抽象契约？</h2><p id="4257" class="pw-post-body-paragraph iq ir ht is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hm dt translated">当您想要将模式灌输到您正在构建的dapp中时，抽象契约尤其有用</p><h2 id="abff" class="ka kb ht bd kc kd ke kf kg kh ki kj kk jb kl km kn jf ko kp kq jj kr ks kt ku dt translated">我们什么时候应该使用界面？</h2><p id="a8d2" class="pw-post-body-paragraph iq ir ht is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hm dt translated">当您构建大型复杂的dapps时，可扩展性是关键。当涉及到在全面实现之前设计更大规模的dapps时，接口是最有用的。</p><blockquote class="ly"><p id="cf48" class="lz ma ht bd mb mc md me mf mg mh jn ek translated">交易新手？尝试<a class="ae mi" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae mi" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>