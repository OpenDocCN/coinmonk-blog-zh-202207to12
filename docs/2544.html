<html>
<head>
<title>Learn Solidity lesson 28. Understanding the ERC-20 token.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习第28课固体。了解ERC-20令牌。</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/solidity-lesson-28-understanding-the-erc-20-token-928758f053e1?source=collection_archive---------6-----------------------#2022-08-22">https://medium.com/coinmonks/solidity-lesson-28-understanding-the-erc-20-token-928758f053e1?source=collection_archive---------6-----------------------#2022-08-22</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/41316486394b43caf6f8f9c2b723ac1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WwspBzy3CBmhQ2EDdaTD-w.jpeg"/></div></div></figure><p id="0be0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">ERC-20令牌是可替换令牌的最低标准模板。Fabian Vogelsteller和Vitalik Buterin在2015年底的以太坊第20期征求意见中提出了这样一个模型，它是当前资产令牌化的基础。</p><p id="434d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">可替代代币是一种可以自由兑换成等价代币的代币，就像法定货币一样。还有一种不可替代的令牌(NFT)，其中每种资产都与其他资产不同，就像收藏中可收集的项目一样。</p><p id="3c3b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">ERC-20标准是当今交易的大多数加密货币的基础。许多外行人仍然困惑的一个问题是他们所拥有的资产的来源。例如，当某人拥有一定数量的代币时，这些代币存储在哪里？答案是，令牌不过是区块链上的一个变量值。</p><p id="35cc" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">不知何故，这不应该是一个惊喜。我们在银行拥有的资产也在一个数据库中被总结为价值，最大的区别是这种数据库是不公开的。以太坊数据库可以被网络上的任何节点查看，甚至更改。共识机制确保即使有人更改了数据库中的余额，该更改也会被阻止，不会在网络上传播。</p><p id="57f2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">区块链给金融业带来的最大新奇之处在于，资产所有权不再由银行等中央实体决定。它是由网络中所有节点一致决定的。</p><p id="de3c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在让我们看看ERC 20标准的状态变量和函数，并创建我们自己的令牌。</p><h1 id="3fd5" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">令牌的基本信息</h1><p id="d9a0" class="pw-post-body-paragraph jb jc ht jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy hm dt translated">ERC-20标准有3个可选函数，它们返回令牌的名称、符号和小数位数。尽管是可选的，但标准做法是包含所有这些信息。例如，钱包和块浏览器使用小数位数来正确列出帐户拥有的令牌数量。</p><p id="11a3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">ERC-20标准告诉我们，这三个函数必须如下:</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="656e" class="ll ka ht lh b fv lm ln l lo lp">function name() public view returns (string)<br/>function symbol() public view returns (string)<br/>function decimals() public view returns (uint8)</span></pre><p id="f4a3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">实现这些功能最简单的方法是通过公共状态变量。我们可以在构造函数中给这样的变量赋值，但是在上面的例子中，我们将在声明的时候赋值。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="cae9" class="ll ka ht lh b fv lm ln l lo lp">string public name = "My Token";<br/>string public symbol = "MTK";<br/>uint8 public decimals = 18;</span></pre><p id="1924" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">另一个基本函数是返回契约创建的令牌总数的函数。该函数不是可选的，应该如下所示:</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="b2b4" class="ll ka ht lh b fv lm ln l lo lp">function totalSupply() public view returns (uint256)</span></pre><p id="b50f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">同样，实现这个函数最简单的方法是通过一个公共状态变量。应该注意的是，这个总的令牌供应是一个无符号整数，它也必须包括小数位。见下文。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="40c3" class="ll ka ht lh b fv lm ln l lo lp">uint public totalSupply = 1_000_000 * 10 ** decimals;</span></pre><p id="4fb1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在Solidity中，可以包含符号<code class="eh lq lr ls lh b">_</code>，以便更好地显示整数值。为了包含小数位数，我们将初始报价(100万代币)乘以小数位数的10倍。</p><h1 id="cabe" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">平衡和转移</h1><p id="905a" class="pw-post-body-paragraph jb jc ht jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy hm dt translated">ERC-20标准中最重要的状态变量是将地址(账户)与其余额联系起来的映射。变量的名字是任意的，但是有必要实现一个函数来返回某个账户的余额，如下所示。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="1b53" class="ll ka ht lh b fv lm ln l lo lp">function balanceOf(address _owner) public view returns (uint256 balance)</span></pre><p id="63c9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">实现上述函数的最简单方法是给存储帐户余额的状态变量命名为<code class="eh lq lr ls lh b">balanceOf </code>，并将其声明为public。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="16d2" class="ll ka ht lh b fv lm ln l lo lp">mapping(address =&gt; uint256) public balanceOf;</span></pre><p id="cda4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">ERC-20标准要求实现两个传递函数。其中一个必须由想要转移一定数量代币的帐户调用。这样的功能必须实现为下面的接口。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="0005" class="ll ka ht lh b fv lm ln l lo lp">function transfer(address _to, uint256 _value) public returns (bool success)</span></pre><p id="ce3f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">其实现的基础非常简单。发送令牌的账户的余额必须扣除该金额，而接收账户的余额必须加上该金额。下面是上述函数最简单的实现。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="2ce9" class="ll ka ht lh b fv lm ln l lo lp">function transfer(address _to, uint256 _value) public returns (bool success) {<br/>    balanceOf[msg.sender] = balanceOf[msg.sender] - _value;<br/>    balanceOf[_to] = balanceOf[_to] + _value;<br/>    emit Transfer(msg.sender, _to, _value); <br/>    return true;<br/>}</span></pre><p id="80a4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在返回<code class="eh lq lr ls lh b">true</code>之前，我们发出了一个<code class="eh lq lr ls lh b">Transfer </code>事件。我们这样做是因为这是ERC-20标准的另一个要求。有必要定义一个名为<code class="eh lq lr ls lh b">Transfer</code>的事件，如下所示。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="b433" class="ll ka ht lh b fv lm ln l lo lp">event Transfer(address indexed _from, address indexed _to, uint256 _value)</span></pre><p id="4540" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">因为发送令牌的帐户是调用函数的帐户，所以余额减少的地址必须是<code class="eh lq lr ls lh b">msg.sender</code>。将接收令牌的地址以及要传输的令牌的值作为函数的参数接收。</p><p id="bed5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们可以在<code class="eh lq lr ls lh b">transfer</code>函数体中做一些其他的检查。可能的检查是检查将发送令牌的账户的余额是否大于或等于要转移的金额，否则指示错误。这种检查的一个例子是:</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="5b31" class="ll ka ht lh b fv lm ln l lo lp">require(balanceOf[msg.sender] &gt;= _value, "ERC20: transfer amount exceeds balance");</span></pre><p id="bae9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这种验证不是完全必要的，因为如果账户余额不足，其最终余额将是负的。然而<code class="eh lq lr ls lh b">balanceOf</code>是一个变量，它的值必须是正整数。试图在此变量中保存负值将会引发错误。</p><p id="8c61" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">另一种常见的验证是验证接收令牌的地址不是地址零。地址零用于创建新合同，因此通常会阻止令牌发送到该地址。这种验证的实现如下。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="010f" class="ll ka ht lh b fv lm ln l lo lp">require(to != address(0), "ERC20: transfer to the zero address");</span></pre><h1 id="9e68" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">批准和允许</h1><p id="9e16" class="pw-post-body-paragraph jb jc ht jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy hm dt translated">ERC-20标准的最后一个强制性特征是，令牌持有者可以允许另一个帐户代表他们发送令牌。例如，分散式交换机就使用这种方法。</p><p id="3b3f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">令牌所有者必须做的第一件事是批准另一个帐户转移他们的令牌。这是由<code class="eh lq lr ls lh b">approve</code>函数完成的，其接口如下。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="ec32" class="ll ka ht lh b fv lm ln l lo lp">function approve(address _spender, uint256 _value) public returns (bool success)</span></pre><p id="1b82" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh lq lr ls lh b">_spender</code>参数是被授权转移代币的账户的地址。授权帐户的地址就是调用该函数的地址，即<code class="eh lq lr ls lh b">msg.sender</code>。<code class="eh lq lr ls lh b">_value</code>参数是<code class="eh lq lr ls lh b">msg.sender</code>授权<code class="eh lq lr ls lh b">_spender</code>代为转账的金额。</p><p id="ee2b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">关于某个帐户授权另一个帐户代表它转移多少令牌的信息存储在一个状态变量中。同样，这个状态变量的名称是任意的，但是必须实现下面的函数。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="2aff" class="ll ka ht lh b fv lm ln l lo lp">function allowance(address _owner, address _spender) public view returns (uint256 remaining)</span></pre><p id="4285" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">上面的函数应该返回关于<code class="eh lq lr ls lh b">_owner</code>账户允许<code class="eh lq lr ls lh b">_spender</code>账户代表其转账多少的信息。实现上述功能的最简单方法是将状态变量命名为<code class="eh lq lr ls lh b">allowance</code>，如下所示。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="7a12" class="ll ka ht lh b fv lm ln l lo lp">mapping(address =&gt; mapping(address =&gt; uint)) public allowance;</span></pre><p id="8824" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh lq lr ls lh b">allowance</code>状态变量是ERC-20标准中最难理解的，因为它是嵌套映射。然而，这个想法很简单。某个账户，比如说Ana，允许Bob代他转20个代币，允许Zoe转40个代币，允许Peter转15个代币。它是将地址(Ana)链接到地址(Bob、Zoe、Peter……)和值之间的映射的映射。下图是一个示意图。</p><figure class="lc ld le lf fq iu fe ff paragraph-image"><div class="fe ff lt"><img src="../Images/8a50dd2ca0e35cf733852a424b82085c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1108/format:webp/1*kBB0f8kOFdV0UsmNJKKc4g.png"/></div><figcaption class="lu lv fg fe ff lw lx bd b be z ek">The allowance variable is a map of a map.</figcaption></figure><p id="fa7a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh lq lr ls lh b">approve </code>功能的最小实现如下。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="0e2b" class="ll ka ht lh b fv lm ln l lo lp">function approve(address _spender, uint256 _value) public returns (bool success) {</span><span id="7e74" class="ll ka ht lh b fv ly ln l lo lp">   allowance[msg.sender][_spender] = _value;<br/>   emit Approval(msg.sender, _spender, _value);<br/>   return true;<br/>}</span></pre><p id="036c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">该函数至少应该改变变量<code class="eh lq lr ls lh b">allowance</code>并发出一个事件。除了<code class="eh lq lr ls lh b">Transfer</code>事件，<code class="eh lq lr ls lh b">Approval</code>事件也是强制的，它有如下接口。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="24bd" class="ll ka ht lh b fv lm ln l lo lp">event Approval(address indexed _owner, address indexed _spender, uint256 _value)</span></pre><p id="2fce" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">事件<code class="eh lq lr ls lh b">Transfer </code>和<code class="eh lq lr ls lh b">Approval</code>是ERC-20标准中仅有的两个强制事件。第一个必须在每次转账时发出，而第二个必须在一个账户批准另一个账户代表他们转移代币时发出。</p><p id="82ab" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">最后，一旦<code class="eh lq lr ls lh b">_owner</code>账户批准<code class="eh lq lr ls lh b">_spender</code>账户代表其转移代币，必须使用<code class="eh lq lr ls lh b">transferFrom</code>功能完成此类转移。这是我们需要实现的最后一个功能，它的接口如下。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="2a91" class="ll ka ht lh b fv lm ln l lo lp">function transferFrom(address _from, address _to, uint256 _value) public returns (bool success)</span></pre><p id="3a21" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">上面的函数应该减少<code class="eh lq lr ls lh b">_from</code>的账户余额，增加<code class="eh lq lr ls lh b">_to</code>的账户余额，两者都增加变量<code class="eh lq lr ls lh b">_value</code>的值。但是，请注意，任何人都可以调用该函数。因此，有必要验证调用交易(<code class="eh lq lr ls lh b">msg.sender</code>)的人是否被允许代表账户<code class="eh lq lr ls lh b">_from</code>转移代币。</p><p id="e7fb" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh lq lr ls lh b">transferFrom </code>功能的最小实现如下。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="d598" class="ll ka ht lh b fv lm ln l lo lp">function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {<br/>    <br/>    require(allowance[_from][msg.sender] &gt;= _value);<br/>    balanceOf[_from] -= _value;<br/>    balanceOf[_to] += _value;  <br/>    emit Transfer(_from, _to, _value);<br/>    allowance[_from][msg.sender] -= value;  <br/>    return true;<br/>}</span></pre><p id="841e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">注意，这次我使用了操作符<code class="eh lq lr ls lh b">+=</code>和<code class="eh lq lr ls lh b">-=</code>。它们与将值添加到变量中具有相同的效果。</p><p id="d6a8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在函数体的第一行，检查账户<code class="eh lq lr ls lh b">_from</code>是否允许账户<code class="eh lq lr ls lh b">msg.sender</code>代表它至少传输变量<code class="eh lq lr ls lh b">_value</code>的值。接下来的两行改变了账户余额<code class="eh lq lr ls lh b">_from</code>和<code class="eh lq lr ls lh b">_to</code>。有必要发出传输事件，就像我们在<code class="eh lq lr ls lh b">transfer</code>函数中所做的那样。</p><p id="e303" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">随后，<code class="eh lq lr ls lh b">allowance</code>变量的值被改变，因为<code class="eh lq lr ls lh b">msg.sender</code>账户已经使用了允许转移的部分，这一点必须考虑在内。最后，它返回true。</p><h1 id="c95d" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">一份完整的ERC-20代币合同</h1><p id="b8fe" class="pw-post-body-paragraph jb jc ht jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy hm dt translated">在这一节中，我们将基于我们所做的一切，向您展示ERC-20标准的一个非常简单的实现。在接下来的课程中，我们将看到如何扩展这个模型。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="bbe3" class="ll ka ht lh b fv lm ln l lo lp">pragma solidity ^0.8.7;<br/>    <br/>contract MyToken {</span><span id="6561" class="ll ka ht lh b fv ly ln l lo lp">string public name = "My Token";<br/>string public symbol = "MTK";<br/>uint8 public decimals = 18;<br/>uint public totalSupply = 100_000 * 10 ** decimals;<br/>    <br/>mapping(address =&gt; uint) public balanceOf;<br/>mapping(address =&gt; mapping(address =&gt; uint)) public allowance;</span><span id="f205" class="ll ka ht lh b fv ly ln l lo lp">event Transfer(address indexed _from, address indexed _to, uint256 _value);</span><span id="c32d" class="ll ka ht lh b fv ly ln l lo lp">event Approval(address indexed _owner, address indexed _spender, uint256 _value);</span><span id="c11e" class="ll ka ht lh b fv ly ln l lo lp">function transfer(address _to, uint256 _value) public returns (bool success) {<br/>    <br/>   balanceOf[msg.sender] -= _value;<br/>   balanceOf[_to] += _value;<br/>   emit Transfer(msg.sender, _to, _value); <br/>   return true;<br/>}</span><span id="847a" class="ll ka ht lh b fv ly ln l lo lp">function approve(address _spender, uint256 _value) public returns (bool success) {</span><span id="ebca" class="ll ka ht lh b fv ly ln l lo lp">   allowance[msg.sender][_spender] = _value;<br/>   emit Approval(msg.sender, _spender, _value);<br/>   return true;<br/>}<br/>    <br/>function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {<br/>    <br/>   require(allowance[_from][msg.sender] &gt;= _value);<br/>   balanceOf[_from] += _value;<br/>   balanceOf[_to] -= _value;  <br/>   emit Transfer(_from, _to, _value);<br/>   allowance[_from][msg.sender] -= _value;  <br/>   return true;<br/>}<br/>    <br/>}</span></pre><p id="4920" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">感谢阅读</strong>！</p><p id="5529" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎对本文提出意见和建议。</p><p id="e361" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎任何投稿。<a class="ae lz" href="http://www.buymeacoffee.com/jpmorais" rel="noopener ugc nofollow" target="_blank">www.buymeacoffee.com/jpmorais</a>。</p><blockquote class="ma"><p id="7b62" class="mb mc ht bd md me mf mg mh mi mj jy ek translated">交易新手？试试<a class="ae lz" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或者<a class="ae lz" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>