<html>
<head>
<title>Learn Solidity lesson 22. Type casting.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习第22课坚固性。铅字铸造。</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/learn-solidity-lesson-22-type-casting-656d164b9991?source=collection_archive---------3-----------------------#2022-08-12">https://medium.com/coinmonks/learn-solidity-lesson-22-type-casting-656d164b9991?source=collection_archive---------3-----------------------#2022-08-12</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/57172ec0c8969944d3c27d01bbfbc976.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*21s_PpvpgGlYNPRW8-pC0g.jpeg"/></div></div></figure><p id="c72d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">Solidity是静态类型语言，所以所有变量都有固定的类型；在声明变量后，不能改变变量的类型。这是必要的，因为状态变量在存储器中有一个专用空间。</p><p id="e35d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">然而，将一种类型转换成另一种类型是可能的。这叫做类型转换。有两种方法可以做到这一点:显式和隐式。</p><p id="467a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当表达式有逻辑意义并且在转换时没有信息丢失时，就会发生隐式转换。这听起来可能有些武断，但是通过一些例子应该会变得更加清晰。</p><p id="bedb" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">假设我们有两个变量，一个类型为<em class="jz"> uint8 </em>，一个类型为<em class="jz"> uint16 </em>。为方便起见，我们分别称它们为<code class="eh ka kb kc kd b">narrow</code>和<code class="eh ka kb kc kd b">broad</code>。变量<code class="eh ka kb kc kd b">narrow</code>接受0和2⁸-1之间的值，而变量<code class="eh ka kb kc kd b">broad</code>接受0和2⁶-1之间的值。因此，变量<code class="eh ka kb kc kd b">narrow</code>接受的所有值也被变量<code class="eh ka kb kc kd b">broad</code>接受，但反之则不然。</p><p id="8b3b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">下面的代码完全符合逻辑，没有任何信息丢失。</p><pre class="ke kf kg kh fq ki kd kj kk aw kl dt"><span id="268c" class="km kn ht kd b fv ko kp l kq kr">uint8 narrow = 140;<br/>uint16 broad = narrow; // 140</span></pre><p id="c9d6" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">隐式转换的另一个例子发生在不同类型(无符号)的整数之间有和的时候。下面的代码也是完全合法的，没有信息丢失。</p><pre class="ke kf kg kh fq ki kd kj kk aw kl dt"><span id="eca2" class="km kn ht kd b fv ko kp l kq kr">uint8 valor1 = 140;<br/>uint16 valor2 = 480;<br/>uint16 valor3 = valor1 + valor2; // 620</span></pre><p id="774d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">虽然变量<code class="eh ka kb kc kd b">value1</code>和<code class="eh ka kb kc kd b">value2</code>是不同的类型，但是求和不会有问题。没有信息丢失。</p><p id="9455" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">其他编程语言中允许的一些转换，比如从<em class="jz">字符串</em>到<em class="jz">整数</em>的转换，或者从<em class="jz">布尔</em>到0/1的转换，在Solidity中并不存在。不允许使用类似下面的表达式。</p><pre class="ke kf kg kh fq ki kd kj kk aw kl dt"><span id="a966" class="km kn ht kd b fv ko kp l kq kr">uint8 number = 100 + false; // error<br/>uint8 number = 100 + "2"; // error</span></pre><h1 id="28d8" class="ks kn ht bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo dt translated">显式转换</h1><p id="5431" class="pw-post-body-paragraph jb jc ht jd b je lp jg jh ji lq jk jl jm lr jo jp jq ls js jt ju lt jw jx jy hm dt translated">在Solidity中进行显式类型转换是可能的，但是在这样做的时候你需要非常小心。让我们看一个从类型<em class="jz"> int8 </em>转换为<em class="jz"> uint8 </em>的例子。首先，我们来了解一下计算机是如何表示数字的。</p><p id="cbbe" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们假设下面的8位代表一个数:11111111。它代表什么数字？没有正确的答案。如果它表示无符号整数，则其十进制值为255。但是如果它表示一个既可以是正数也可以是负数的整数，那么它的十进制值就是-1。</p><p id="3780" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在考虑一个具有以下主体的函数，其中我们显式地将int类型转换为uint。</p><pre class="ke kf kg kh fq ki kd kj kk aw kl dt"><span id="ec47" class="km kn ht kd b fv ko kp l kq kr">int8 negative = -1;<br/>return uint8(negative);</span></pre><p id="2d91" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">变量<code class="eh ka kb kc kd b">negative</code>的位值是11111111，不管它代表什么。对于无符号整数，其值为255。注意，通过进行显式转换，我们将-1的值转换为255。</p><figure class="ke kf kg kh fq iu fe ff paragraph-image"><div class="fe ff lu"><img src="../Images/912b505f8ca062a2fdff7b5adc3b2374.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*ntcJE7c4YZJ2LnPoTILlGA.png"/></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">The 8-bit value 11111111 can be either -1 or 255, depending on the type.</figcaption></figure><p id="024d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在上面的例子中，我们将8位类型转换为8位类型。我们已经看到，将8位无符号整数转换为16位很简单，转换是隐式的。但是有可能从16位转换到8位吗？如果不丢失信息，就不可能将16位值存储在8位中。这就像试图把一个大盒子放进一个小盒子而不折叠它。</p><p id="a0d6" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">考虑16位二进制值0000101000001001。十进制写成2569。现在让我们做一个到<em class="jz"> uint8 </em>的显式转换。你认为结果应该是什么？</p><p id="44c0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">仅保留最后8位。值0000101000001001被转换为00001001，即9位小数。当从较大的整数类型转换为较小的整数类型时，右边的位会保留，而左边的位会丢失。</p><p id="13ff" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在转换字节类型时，情况正好相反。当一个较大的字节类型被转换成较小的类型时，前几个字节被保留，最后几个字节丢失。当将较小的字节转换为较大的字节时，空字节会附加到右边。让我们在下面的例子中看到这一点。</p><pre class="ke kf kg kh fq ki kd kj kk aw kl dt"><span id="fbec" class="km kn ht kd b fv ko kp l kq kr">bytes4 value = 0x12345678;<br/>bytes1 smallValue = bytes1(value); // 0x12<br/>bytes5 largeValue = value; // 0x1234567800;</span></pre><p id="88a1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">请注意，当信息丢失时，需要进行显式转换。当没有信息丢失时，就会发生隐式转换。</p><h1 id="1ab7" class="ks kn ht bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo dt translated">字节、字符串和地址</h1><p id="d385" class="pw-post-body-paragraph jb jc ht jd b je lp jg jh ji lq jk jl jm lr jo jp jq ls js jt ju lt jw jx jy hm dt translated">类型<em class="jz">地址</em>是一个20字节的十六进制数，所以您可以通过20 类型将<em class="jz">地址</em>和<em class="jz">相互转换。转换必须是显式的。</em></p><pre class="ke kf kg kh fq ki kd kj kk aw kl dt"><span id="b499" class="km kn ht kd b fv ko kp l kq kr">address myAddress = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4<br/>bytes20 addressInBytes = bytes20(myAddress)</span></pre><p id="6249" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><em class="jz">字节</em>和<em class="jz">字符串</em>也可以转换，转换需要明确。字符串是以UTF-8编码的字节数组，使用Unicode表示符号。</p><p id="feca" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu"> Unicode </strong>是表示文本和表情符号等符号的标准。每个符号需要1到4个字节来表示。普通字母只使用1个字节，而表情符号使用4个字节。我们来看看下图的函数<code class="eh ka kb kc kd b">showUnicode</code>。它将2个普通字母、一个空白和一个表情符号转换成类型<em class="jz">字节</em>。</p><figure class="ke kf kg kh fq iu fe ff paragraph-image"><div class="fe ff lz"><img src="../Images/97c9dcd0a863c3664b408c20c27feb6e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*4FOtfMKYpTCMNG9-kBU-GA.png"/></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">Converting string to bytes.</figcaption></figure><p id="2b05" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在Remix中调用该函数，我们得到如下结果:</p><pre class="ke kf kg kh fq ki kd kj kk aw kl dt"><span id="cc57" class="km kn ht kd b fv ko kp l kq kr">0x486920f09f9880</span></pre><p id="f262" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">它是一个14位的十六进制数字，意味着7个字节:2个字节用于普通字母，1个字节用于空格，4个字节用于表情符号。</p><p id="8206" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">要明白Unicode和UTF-8是两码事。Unicode是一种将值与符号联系起来的标准；每个符号都有一个相关的值，这个值最多可以占用4个字节。UTF-8是一种以8位数据包或1字节表示Unicode符号的方式。与UTF-16相比，后者代表16位包中的Unicode。</p><p id="3213" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">有几个网站可以找到Unicode符号的UTF-8表示。网站<a class="ae ma" href="http://onlineunicodetools.com/convert-unicode-to-utf8" rel="noopener ugc nofollow" target="_blank">onlineunicodetools.com/convert-unicode-to-utf8</a>就是一个例子。在下图中，我们将一个笑脸转换为UTF-8。</p><figure class="ke kf kg kh fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mb"><img src="../Images/b1a5ab6e148b73f0f84416d3bfb8649f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*HS7KaTtWN8i52wlY1vw3kQ.png"/></div></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">UTF-8 representation of a smiley.</figcaption></figure><p id="acf5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">请注意，结果<em class="jz"> f0 9f 98 80 </em>，正好是函数<code class="eh ka kb kc kd b">showUnicode</code>返回的最后4个字节。这表明Solidity使用UTF-8来表示Unicode中的符号。</p><p id="fe82" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当我们将<em class="jz">字符串</em>转换为<em class="jz">字节</em>时，不可能将<em class="jz">字节</em>显式转换为<em class="jz">字符串</em>。</p><p id="5498" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">应该清楚的是，将字符串转换为字节不会改变变量的值。字符串变量是一个静态的字节数组，这正是我们在转换为字节时所看到的。将字符串转换为字节的一个原因是能够使用类型为<em class="jz"> bytes </em>的方法。让我们看看下面的例子。</p><pre class="ke kf kg kh fq ki kd kj kk aw kl dt"><span id="2682" class="km kn ht kd b fv ko kp l kq kr">string memory value = "Hello";<br/>bytes1 firstByte = bytes(value)[0]; // ok<br/>bytes1 firstByteFail = value[0]; // error</span></pre><p id="e267" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">为了检索字符串“Hello”的第一个字节，我们需要将其类型转换为<em class="jz">字节</em>。类型<em class="jz">字符串</em>没有检索单个字节的方法。</p><p id="ce24" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">感谢阅读！</strong></p><p id="6c13" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎对本文提出意见和建议。</p><p id="b14e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎任何投稿。<a class="ae ma" href="http://www.buymeacoffee.com/jpmorais" rel="noopener ugc nofollow" target="_blank">www.buymeacoffee.com/jpmorais</a></p><blockquote class="mc"><p id="2596" class="md me ht bd mf mg mh mi mj mk ml jy ek translated">交易新手？试试<a class="ae ma" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae ma" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>