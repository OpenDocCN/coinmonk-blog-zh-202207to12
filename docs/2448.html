<html>
<head>
<title>Ethernaut-Fallout — A few words about constructor</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以太辐射——关于构造函数的一些话</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/ethereum-fallout-a-few-words-about-constructor-76530a0c76c4?source=collection_archive---------54-----------------------#2022-08-19">https://medium.com/coinmonks/ethereum-fallout-a-few-words-about-constructor-76530a0c76c4?source=collection_archive---------54-----------------------#2022-08-19</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="14aa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">构造函数是使用<strong class="is hu">构造函数</strong>关键字声明的特殊函数。这不是一个必须的函数，只能调用一个，不能再调用一个。呼叫时刻是我们的智能合同创建的时刻。构造函数给了我们初始化状态变量的可能性。在构造器代码执行后，最终代码被部署到区块链。该代码包括公共函数和可通过公共函数访问代码。构造函数代码或任何仅由构造函数使用的内部方法不包含在最终代码中。</p><h1 id="7421" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl dt translated">创建构造函数</h1><p id="7326" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hm dt translated">创建构造函数很容易。让我们看看。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div class="fe ff kr"><img src="../Images/b31eac2331c865056651d48f7b8eca4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1012/format:webp/1*ynObPH_N0J5vKVwAsPGB1g.png"/></div><figcaption class="kz la fg fe ff lb lc bd b be z ek">Example of using of constructor.</figcaption></figure><p id="606d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当我们声明构造函数的时候，我们只使用这个关键字——没有这个构造函数的名字或者其他的。此外，我们必须添加<strong class="is hu">访问修饰符</strong>(我稍后会谈到它们)。构造函数可以是空的，也可以有任何输入变量(就像我们的例子)。</p><p id="216b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">每个合同只能有<strong class="is hu">一个建造师</strong>。编写更多的构造函数会在编译过程中给我们带来错误。但有趣的是，如果我们不定义构造函数，在契约中就会有一个默认的构造函数。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div class="fe ff ld"><img src="../Images/c95f9f5ff05906c0c31d7e76b3895291.png" data-original-src="https://miro.medium.com/v2/resize:fit:640/format:webp/1*VRU4MeNUHxDfOxQ-UkB0dQ.png"/></div><figcaption class="kz la fg fe ff lb lc bd b be z ek">Default constructor</figcaption></figure><h1 id="b50d" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl dt translated">继承中的构造函数</h1><p id="e963" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hm dt translated">更有趣的是，当我们想要创建一个从其他契约继承而来的契约时，它需要构造函数的参数。我们不能给任何参数，我们的合同将必须是一个抽象的合同(这也将在后面解释)。或者我们可以传递每个需要的参数。这里我们又有两个选择:</p><ol class=""><li id="9e61" class="le lf ht is b it iu ix iy jb lg jf lh jj li jn lj lk ll lm dt translated"><strong class="is hu">直接初始化:</strong>我们初始化父构造函数的契约使用硬代码方法，就像我们在例子中看到的那样。</li></ol><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div class="fe ff ln"><img src="../Images/9cc1bcbcbb48b747814ab1dce5ab4098.png" data-original-src="https://miro.medium.com/v2/resize:fit:944/format:webp/1*bClGmVREHVJtkkHScZZ5Dw.png"/></div><figcaption class="kz la fg fe ff lb lc bd b be z ek">Example of direct initialization</figcaption></figure><p id="1cad" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当我们定义ChildContract从ParentContract继承时，我们立即为ParentContract的构造函数传递值。</p><p id="27be" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">2.<strong class="is hu">间接初始化:</strong>parent contract的变量通过其构造函数进行初始化是在ChildContract内部进行的。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div class="fe ff lo"><img src="../Images/d80a300314c7703c44ba05c4cad9f5ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1340/format:webp/1*50oTL2JUy7Gz_8XkPzAZEg.png"/></div><figcaption class="kz la fg fe ff lb lc bd b be z ek">Example of indirect initialization</figcaption></figure><p id="f9ad" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">通过这种方法，我们可以在部署ChildContract时确定ParentContract的参数。这种方法更加灵活。</p><p id="f84f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">不允许同时通过直接和间接方式初始化ParentContract。</p><h1 id="25e5" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl dt translated">函数和状态变量的可见性</h1><p id="ede1" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hm dt translated">也就是说，当我们想要声明构造函数时，我们必须添加访问修饰符。构造函数可以是<strong class="is hu">公共</strong>或<strong class="is hu">内部</strong>。</p><p id="31ac" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">但是我们为什么要用这个词，它们是什么？Solidity知道两种类型的函数调用:不创建实际的EVM调用(也称为“消息调用”)的内部调用和创建的外部调用。因此，函数和状态变量有四种可见性。</p><ul class=""><li id="e5eb" class="le lf ht is b it iu ix iy jb lg jf lh jj li jn lp lk ll lm dt translated"><strong class="is hu">外部:</strong>外部函数是合同接口的一部分，这意味着它们可以从其他合同和通过事务调用。外部函数<code class="eh lq lr ls lt b">f</code>不能在内部调用(即<code class="eh lq lr ls lt b">f()</code>不起作用，但<code class="eh lq lr ls lt b">this.f()</code>起作用)。外部函数在接收大型数据数组时有时会更有效，因为数据不是从calldata复制到内存中的。</li><li id="9df3" class="le lf ht is b it lu ix lv jb lw jf lx jj ly jn lp lk ll lm dt translated"><strong class="is hu"> Public : </strong>公共函数是契约接口的一部分，可以在内部调用，也可以通过消息调用。对于公共状态变量，会生成一个自动getter函数。这意味着编译器生成一个函数，叫做like变量，不带任何参数，返回这个变量的状态值。</li><li id="6af7" class="le lf ht is b it lu ix lv jb lw jf lx jj ly jn lp lk ll lm dt translated"><strong class="is hu">内部:</strong>这些函数和状态变量只能在内部访问(即从当前合同或从其派生的合同中访问)，不使用<code class="eh lq lr ls lt b">this</code>。</li><li id="94e3" class="le lf ht is b it lu ix lv jb lw jf lx jj ly jn lp lk ll lm dt translated"><strong class="is hu">私有:</strong>私有函数和状态变量仅对定义它们的契约可见，在派生契约中不可见。</li></ul><p id="87c5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">本段信息来自<a class="ae lz" href="https://docs.soliditylang.org/en/v0.6.2/contracts.html" rel="noopener ugc nofollow" target="_blank">固化文件</a>。</p><p id="0dcb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">公共构造函数的行为与本文开头描述的完全一样。当构造函数是内部的时，整个契约是抽象的。</p><h1 id="78af" class="jo jp ht bd jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl dt translated">抽象合同</h1><p id="656a" class="pw-post-body-paragraph iq ir ht is b it km iv iw ix kn iz ja jb ko jd je jf kp jh ji jj kq jl jm jn hm dt translated">我喜欢<a class="ae lz" href="https://www.tutorialspoint.com/solidity/solidity_abstract_contracts.htm" rel="noopener ugc nofollow" target="_blank">教程观点</a>中的描述。</p><blockquote class="ma mb mc"><p id="9219" class="iq ir md is b it iu iv iw ix iy iz ja me jc jd je mf jg jh ji mg jk jl jm jn hm dt translated">抽象契约是包含至少一个功能但没有任何实现的契约。这种合同被用作基础合同。通常，抽象契约既包含实现的功能，也包含抽象的功能。派生契约将实现抽象函数，并在需要时使用现有函数。</p><p id="b0d5" class="iq ir md is b it iu iv iw ix iy iz ja me jc jd je mf jg jh ji mg jk jl jm jn hm dt translated">如果派生契约没有实现抽象函数，那么该派生契约将被标记为抽象。</p></blockquote><p id="972e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">抽象契约不能被编译。但是，它们可以用作其他协定可以继承的基础协定。</p><p id="bc41" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们看看这个例子。</p><figure class="ks kt ku kv fq kw fe ff paragraph-image"><div role="button" tabindex="0" class="mi mj di mk bf ml"><div class="fe ff mh"><img src="../Images/c25dbb2dcf0ca36ef57e75e17f3bb343.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PB9CrixaArz2AjSjHq6cgA.png"/></div></div><figcaption class="kz la fg fe ff lb lc bd b be z ek">Using of abstract contract</figcaption></figure><p id="a2f3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">AbstractContract包含没有主体的函数。我们知道它在输入端需要什么，在输出端会有什么。我们也知道这个函数是公共的。但除了“虚拟”这个神奇的词之外，别无其他。这个词通知Solidity这个函数将被其他函数覆盖，具有相同的名称和' override '修饰符。</p><p id="8267" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">abstract和virtual关键字表示关联的代码将在代码中的其他地方实现或重写。主要区别是抽象适用于契约，虚拟适用于函数。</p></div><div class="ab cl mm mn hb mo" role="separator"><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr ms"/><span class="mp bw bk mq mr"/></div><div class="hm hn ho hp hq"><p id="b90c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我希望这篇文章对你有用。如果你有任何想法，我如何能使我的帖子更好，请告诉我。我随时准备学习。你可以通过<a class="ae lz" href="https://pl.linkedin.com/in/szymon-skrzy%C5%84ski-881462214" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>和<a class="ae lz" href="https://t.me/eszymi" rel="noopener ugc nofollow" target="_blank"> Telegram </a>与我联系。</p><p id="0b39" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果你想和我谈论这个话题或者我写的其他话题，请随意。我乐于交谈。</p><p id="f9fe" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">快乐学习！</p><blockquote class="mt"><p id="b345" class="mu mv ht bd mw mx my mz na nb nc jn ek translated">交易新手？试试<a class="ae lz" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a>或<a class="ae lz" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>