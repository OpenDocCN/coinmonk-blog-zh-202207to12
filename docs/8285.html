<html>
<head>
<title>Learn Ethereum programming #4. JSON-RPC with Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习以太坊编程#4。带有Node.js的JSON-RPC</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/learn-ethereum-programming-4-json-rpc-with-node-js-6e0ca00c3c50?source=collection_archive---------9-----------------------#2022-12-30">https://medium.com/coinmonks/learn-ethereum-programming-4-json-rpc-with-node-js-6e0ca00c3c50?source=collection_archive---------9-----------------------#2022-12-30</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/a1cb1da03a6d4a3259f189833278a546.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*SogeYz38ZpKgB_r9jOUdiw.jpeg"/></div></div></figure><p id="a767" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">JSON-RPC是一个远程调用协议，它的数据是用JSON编码的。大多数区块链客户端通过JSON-RPC发送请求。发送JSON-RPC的协议可以是http、WebSocket，在某些情况下也可以是gRPC。实际上，每种编程语言都有一个通过HTTP发送请求的模块，所以我们可以使用这些语言中的任何一种连接到区块链。</p><p id="ad82" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在本课中，我们将使用Node.js发送请求。理论上，这就是我们在Ethereum上编写一个分散式应用程序所需的全部内容，还有一些加密库来签署我们的事务。在现实生活中(不是在理论上)，我们使用具有专门方法的库来与区块链进行交互，以便使我们的生活更容易。</p><p id="c977" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在任何情况下，理解事情如何在幕后工作，以及了解以太坊执行客户端接受的方法都是很重要的。许多web3库方法只不过是可以通过JSON-RPC执行的方法的简单包装。</p><p id="b441" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">首先，我将在某个目录下创建一个名为<em class="jz"> jsonrpc </em>的文件夹，并在其中启动Visual Studio代码。之后，我会用<code class="eh ka kb kc kd b">npm init -y</code>指令启动一个程序。然后我们将安装3个包:<em class="jz"> axios </em>、<em class="jz"> ws </em>和<em class="jz"> dotenv </em>。</p><pre class="ke kf kg kh fq ki kd kj bn kk kl bi"><span id="5904" class="km kn ht kd b be ko kp l kq kr">npm i axios ws dotenv </span></pre><p id="4bec" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">Axios是一个创建HTTP客户端的库。Ws是一个使用WebSocket的库。Dotenv是一个在Node中使用环境变量的模块。</p><h1 id="e9a1" class="ks kn ht bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo dt translated">遵守守则</h1><p id="9183" class="pw-post-body-paragraph jb jc ht jd b je lp jg jh ji lq jk jl jm lr jo jp jq ls js jt ju lt jw jx jy hm dt translated">向Alchemy(或任何其他)节点发送请求的代码非常简单。考虑下面的代码。</p><pre class="ke kf kg kh fq ki kd kj bn kk kl bi"><span id="a9bb" class="km kn ht kd b be ko kp l lu kr">require("dotenv").config();<br/>const axios = require("axios");<br/><br/>const payload = {<br/>    jsonrpc: "2.0",<br/>    id: 0,<br/>    method: "eth_getBalance",<br/>    params: ["0x8303539291922EF29B518B5B93e8Ab07F22F2D1d","latest"]    <br/>};<br/><br/>(async () =&gt; {<br/>    const response = await axios.post(`https://eth-goerli.g.alchemy.com/v2/${process.env.ALCHEMY_KEY}`, payload)<br/>    console.log(response.data)<br/>})();    </span></pre><p id="eb9e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">首先我们导入两个我们需要的库，<em class="jz"> dotenv </em>和<em class="jz"> axios </em>。有效负载是必须作为JSON发送的javascript对象，它要求执行<code class="eh ka kb kc kd b">eth_getBalance</code>方法。我将它与两个参数一起使用，一个是恢复余额的地址，另一个是我想要最近余额的指示(可选)。</p><blockquote class="lv"><p id="a558" class="lw lx ht bd ly lz ma mb mc md me jy ek translated">交易新手？在<a class="ae mf" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易</a>上尝试<a class="ae mf" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae mf" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">副本交易</a></p></blockquote><p id="17fd" class="pw-post-body-paragraph jb jc ht jd b je mg jg jh ji mh jk jl jm mi jo jp jq mj js jt ju mk jw jx jy hm dt translated">然后我编写一个异步函数并立即执行，使用<em class="jz"> axios </em>库发送HTTP请求。它需要两个参数:节点地址和作为JSON发送的JavaScript对象。</p><p id="dd62" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">注意，我使用<code class="eh ka kb kc kd b">process.env.ALCHEMY_KEY</code>作为键。为此，您需要在同一个目录中创建一个<code class="eh ka kb kc kd b">.env</code>文件，并声明Alchemy密钥，如下所示。</p><pre class="ke kf kg kh fq ki kd kj bn kk kl bi"><span id="a91b" class="km kn ht kd b be ko kp l kq kr">ALCHEMY_KEY=1P_1HHvUYb...nZhZ5DY</span></pre><p id="900a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">最后，我只将响应的<em class="jz">数据</em>属性写入控制台，因为在那里可以找到返回数据。注意使用Node.js发送HTTP(或HTTPS)请求是多么简单</p><h1 id="9706" class="ks kn ht bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo dt translated">HTTP或WebSocket</h1><p id="b2bd" class="pw-post-body-paragraph jb jc ht jd b je lp jg jh ji lq jk jl jm lr jo jp jq ls js jt ju lt jw jx jy hm dt translated">大多数以太坊客户端同时使用HTTP和WebSocket接受请求。它们是不同的协议，行为也不同。使用WebSocket，在客户端和服务器之间打开一个通信通道，并且该通道保持打开，直到它被显式关闭。</p><p id="c968" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当我们只想要特定的信息时，使用HTTP就足够了。然而，有时我们希望持续接收信息，比如当我们订阅一个请求以持续接收智能合约发出的事件信息时。在这种情况下，有必要使用WebSocket。</p><p id="8ab3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们修改代码来发送订阅请求。在其中，我们将请求接收以太坊上由戴令牌发出的所有事件。让我们看看下面的代码。</p><pre class="ke kf kg kh fq ki kd kj bn kk kl bi"><span id="1e25" class="km kn ht kd b be ko kp l lu kr">require("dotenv").config();<br/>const WebSocket = require("ws")<br/><br/>const payload = {<br/>    jsonrpc: "2.0",<br/>    id: 0,<br/>    method: "eth_subscribe",<br/>    params: [<br/>        "logs",<br/>        {<br/>            address: '0x6b175474e89094c44da98b954eedeac495271d0f',<br/>            topics: []<br/>        }<br/>    ]    <br/>};<br/><br/>const ws = new WebSocket(`wss://eth-mainnet.g.alchemy.com/v2/${process.env.ALCHEMY_KEY}`)<br/><br/>ws.on('open', () =&gt; {<br/>    ws.send(JSON.stringify(payload))<br/>})<br/><br/>ws.on('message', (data) =&gt; {<br/>    console.log(`received: ${data} \n`)<br/>})</span></pre><p id="59af" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">比上一部长一点，但也不复杂。首先，我们不再使用axios，而是使用一个名为<em class="jz"> ws </em>的库。</p><p id="1433" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们的有效负载也不同，因为我们现在要求执行<code class="eh ka kb kc kd b">eth_subscribe</code>方法。在第一个参数中，我们指出我们想要接收什么，日志，在第二个参数中，我们指出我们想要接收事件的契约的地址。在本课中将看不到名为“主题”的字段，我们可以将其留空。</p><p id="7059" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们使用带有支持WebSocket的Alchemy节点地址的<code class="eh ka kb kc kd b">new WebSocket </code>创建WebSocket对象的新实例。请注意，我将节点地址更改为Mainnet，因为我要监控的契约就在上面。</p><p id="0702" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在创建的实例中，我们为两个事件定义了回调。</p><p id="d53f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在<em class="jz"> open </em>事件中，我们发送我们创建的有效载荷，编码为JSON。在<em class="jz">消息</em>事件中，我们将接收到的数据写入控制台。每次智能合约发出事件时，都会执行<em class="jz">消息</em>事件。</p><p id="da06" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在下图中，我们可以看到执行上述代码的回报。该连接将保持活动状态，接收来自Alchemy的消息，直到被其中一方终止。</p><figure class="ke kf kg kh fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff ml"><img src="../Images/c3913c3d52c8614e3ec91fbb090246d5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hB2VvgoHytCjI2zKck4TTg.png"/></div></div><figcaption class="mm mn fg fe ff mo mp bd b be z ek">Subscribing to receive events.</figcaption></figure><p id="44fd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我希望清楚使用Node.js与区块链交互是多么简单，不需要任何以太坊专用的库。</p><p id="94ba" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">感谢阅读！</strong></p><p id="b58a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎对本文提出意见和建议。</p><p id="2349" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎任何投稿。www.buymeacoffee.com/jpmorais。</p></div></div>    
</body>
</html>