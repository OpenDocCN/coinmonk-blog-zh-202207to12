<html>
<head>
<title>Learn Solidity lesson 15. Structures.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习第15课坚固性。结构。</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/learn-solidity-lesson-15-structures-85dde79ed042?source=collection_archive---------9-----------------------#2022-08-05">https://medium.com/coinmonks/learn-solidity-lesson-15-structures-85dde79ed042?source=collection_archive---------9-----------------------#2022-08-05</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/29fd20d7e3ea1bac2760bdef996ba316.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*scUUnah-KzmNXtSSaMerqQ.jpeg"/></div></div></figure><p id="5523" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">结构是用户定义的类型。这是一种将不同类型组合成更复杂结构的方式。</p><p id="8b88" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">假设我们想要创建一个包含多个信息字段的记录。这可以使用如下结构来完成。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="d197" class="ki kj ht ke b fv kk kl l km kn">struct Person {<br/>   string firstName;<br/>   string lastName;<br/>   uint8 age;<br/>}</span></pre><p id="e262" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这些变量被组合在一个结构中，而不是必须管理三个独立的变量。</p><p id="9ff3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">要声明一个结构类型的变量，只需使用该结构的名字。例如，创建一个新的类型为<em class="ko"> Person </em>的状态变量。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="b433" class="ki kj ht ke b fv kk kl l km kn">Person person;</span></pre><p id="0a50" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">由于结构是引用类型的值，如果我们想在函数中声明一个新的结构，我们必须指出它们是在内存中还是存储中。</p><p id="7309" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">结构可以包含复杂的值，如数组，甚至其他结构。也可以使用结构作为<em class="ko">映射</em>中的值。下面的代码完全有效。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="8cf3" class="ki kj ht ke b fv kk kl l km kn">struct Document {<br/>   Person person;<br/>   uint id;<br/>}</span><span id="f69b" class="ki kj ht ke b fv kp kl l km kn">struct Person {<br/>   string firstName;<br/>   string lastName;<br/>   uint8 age;<br/>}</span><span id="5537" class="ki kj ht ke b fv kp kl l km kn">mapping(bytes32 =&gt; Document) documents;</span></pre><h1 id="303e" class="kq kj ht bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">初始化结构</h1><p id="a826" class="pw-post-body-paragraph jb jc ht jd b je ln jg jh ji lo jk jl jm lp jo jp jq lq js jt ju lr jw jx jy hm dt translated">有几种方法可以初始化一个结构。仅仅声明一个类型为<em class="ko"> struct </em>的新变量就会将其字段初始化为默认值。</p><p id="fb5b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在名为<code class="eh ls lt lu ke b">Person</code>的结构中，字段<code class="eh ls lt lu ke b">firstName</code>和<code class="eh ls lt lu ke b">lastName</code>将初始化为空字符串，而字段<code class="eh ls lt lu ke b">age</code>将初始化为<code class="eh ls lt lu ke b">0</code>。</p><p id="e731" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">也可以在声明时初始化该结构，如下所示。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="ab8f" class="ki kj ht ke b fv kk kl l km kn">Person person = Person("John","Doe",41);</span></pre><h1 id="09be" class="kq kj ht bd kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm dt translated">管理结构</h1><p id="182f" class="pw-post-body-paragraph jb jc ht jd b je ln jg jh ji lo jk jl jm lp jo jp jq lq js jt ju lr jw jx jy hm dt translated">结构模型一旦定义就不能更改，但是每个对象的值可以更改。</p><p id="9f2a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">为了访问类型为<em class="ko"> struct </em>的对象的某个字段，我们使用句点(。)，后跟字段的名称。在下面的代码中，我们展示了两种改变类型为<em class="ko"> struct </em>的对象的类似方法。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="8ad1" class="ki kj ht ke b fv kk kl l km kn">// Directly as a struct<br/>person = Person("Paul","Doe",32);</span><span id="77b5" class="ki kj ht ke b fv kp kl l km kn">// Changing the fields individually<br/>person.firstName = "Paul";<br/>person.lastName = "Doe";<br/>person.age = 32;</span></pre><p id="5dec" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">很多时候我们只想改变对象的某个字段，为此我们必须使用使用句点的语法。我们可以认为结构是一种有属性但没有方法的对象。</p><p id="3d22" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">用结构作为参数声明函数是可能的，我们把参数作为数组传递给这个函数。让我们看看创建修改类型为<em class="ko"> struct </em>的对象的函数的两种方法。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="3538" class="ki kj ht ke b fv kk kl l km kn">function changePerson(Person calldata _person) public {<br/>   person = _person;<br/>}</span><span id="4573" class="ki kj ht ke b fv kp kl l km kn">function changePersonByFields(string calldata _firstName, string calldata _lastName, uint8 _age) public {<br/>   person.firstName = _firstName;<br/>   person.lastName = _lastName;<br/>   person.age = _age;<br/>}</span></pre><p id="d74b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这两个函数有相同的目的，改变<em class="ko">人</em>类型的<code class="eh ls lt lu ke b">person</code>状态变量。第一个函数将结构作为参数，而第二个函数将各个字段作为参数。</p><p id="9d43" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">一个简短的旁白:我使用了关键字calldata而不是memory，因为我们不需要在内存中为参数创建一个新的变量，因为它们只会在变量<code class="eh ls lt lu ke b">person</code>的赋值中使用。</p><p id="346d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这两种方法有区别吗？虽然结果一样，但是函数<code class="eh ls lt lu ke b">changePerson </code>的气费更低。</p><p id="ebaa" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">由于该结构是一个复杂的类型，要将参数传递给函数<code class="eh ls lt lu ke b">changePerson</code>，我们必须将其作为一个没有定义类型的静态数组或枚举来传递。这一点可以从下图中看出。</p><figure class="jz ka kb kc fq iu fe ff paragraph-image"><div class="fe ff lv"><img src="../Images/0eb03f04652bf4571892407b4e377ea3.png" data-original-src="https://miro.medium.com/v2/resize:fit:774/format:webp/1*YE0FwaG3d6nWOek4feXfHA.png"/></div><figcaption class="lw lx fg fe ff ly lz bd b be z ek">Structure-type objects are passed as arguments in square brackets.</figcaption></figure><p id="036e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">也可以在函数中返回结构，就像我们返回其他类型一样。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="5f55" class="ki kj ht ke b fv kk kl l km kn">function getPerson() public view returns (Person memory) {<br/>   return person;<br/>}</span></pre><p id="1f09" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">上面的代码与我们将变量<code class="eh ls lt lu ke b">person</code>声明为public时的代码相同。我们可以通过两种方式访问返回结果，或者作为一个数组，通过它的索引，或者作为一个对象，通过它的属性。这在编写与区块链交互的应用程序代码时表现得最为明显。</p><p id="cf34" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">感谢阅读！</strong></p><p id="f695" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎对本文提出意见和建议。</p><p id="ed7e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎任何投稿。【www.buymeacoffee.com/jpmorais T4】</p><blockquote class="mb"><p id="705c" class="mc md ht bd me mf mg mh mi mj mk jy ek translated">交易新手？尝试<a class="ae ma" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae ma" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>