<html>
<head>
<title>A custom Hyperledger Fabric wallet store</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">自定义Hyperledger结构钱包商店</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/a-custom-hyperledger-fabric-wallet-store-90aa45f42aa8?source=collection_archive---------2-----------------------#2022-08-03">https://medium.com/coinmonks/a-custom-hyperledger-fabric-wallet-store-90aa45f42aa8?source=collection_archive---------2-----------------------#2022-08-03</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/4ae0b1b98e6ed90835f664344983a55b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*REfS9Skqx_KCxh3jVIowvg.png"/></div></div></figure></div><div class="ab cl jb jc hb jd" role="separator"><span class="je bw bk jf jg jh"/><span class="je bw bk jf jg jh"/><span class="je bw bk jf jg"/></div><div class="hm hn ho hp hq"><h1 id="9ba5" class="ji jj ht bd jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dt translated">先决条件</h1><p id="49cc" class="pw-post-body-paragraph kg kh ht ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">本教程要求读者对Hyperledger Fabric有一个基本的了解。如果你是织物的初学者，我真的建议你好好看看它的<a class="ae le" href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/" rel="noopener ugc nofollow" target="_blank">文档</a>。按照<a class="ae le" href="https://hyperledger-fabric.readthedocs.io/en/release-2.2/getting_started.html" rel="noopener ugc nofollow" target="_blank">【入门】</a>中描述的步骤，您应该能够与两到三个组织一起运行fabric测试网络。</p><p id="58b4" class="pw-post-body-paragraph kg kh ht ki b kj lf kl km kn lg kp kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated"><strong class="ki hu">调出测试网络</strong></p><p id="d5b3" class="pw-post-body-paragraph kg kh ht ki b kj lf kl km kn lg kp kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">您可以在<code class="eh lk ll lm ln b">fabric-samples</code>存储库的<code class="eh lk ll lm ln b">test-network</code>目录中找到启动网络的脚本。使用以下命令导航到测试网络目录:</p><pre class="lo lp lq lr fq ls ln lt lu aw lv dt"><span id="10f3" class="lw jj ht ln b fv lx ly l lz ma">cd fabric<strong class="ln hu">-</strong>samples<strong class="ln hu">/</strong>test<strong class="ln hu">-</strong>network</span></pre><p id="e7df" class="pw-post-body-paragraph kg kh ht ki b kj lf kl km kn lg kp kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">在这个目录中，您可以找到一个带注释的脚本，<code class="eh lk ll lm ln b">network.sh</code>，它使用本地机器上的Docker映像建立了一个Fabric网络。您可以运行<code class="eh lk ll lm ln b">./network.sh -h</code>来打印脚本帮助文本，或者使用以下命令启动测试网络</p><pre class="lo lp lq lr fq ls ln lt lu aw lv dt"><span id="a3e4" class="lw jj ht ln b fv lx ly l lz ma">./network.sh up createChannel -ca -c mychannel -s couchdb</span></pre><p id="a3b1" class="pw-post-body-paragraph kg kh ht ki b kj lf kl km kn lg kp kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">这将创建一个网络，其中有一个名为“mychannel”的通道，带有CA(证书颁发机构)和CouchDB。</p><h1 id="9f7f" class="ji jj ht bd jk jl mb jn jo jp mc jr js jt md jv jw jx me jz ka kb mf kd ke kf dt translated">背景</h1><p id="d5d3" class="pw-post-body-paragraph kg kh ht ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">那么这个教程的目的是什么呢？</p><blockquote class="mg mh mi"><p id="3a66" class="kg kh mj ki b kj lf kl km kn lg kp kq mk lh kt ku ml li kx ky mm lj lb lc ld hm dt translated">本教程帮助读者为Fabric创建一个自定义钱包商店。</p></blockquote><p id="d15b" class="pw-post-body-paragraph kg kh ht ki b kj lf kl km kn lg kp kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">但是为什么我们需要一个定制钱包商店呢？安装Hyperledger Fabric并浏览其示例源代码后，您可能会发现非常有趣的一点是，您的钱包信息存储在<strong class="ki hu">文件</strong>中。让我们看看<code class="eh lk ll lm ln b">fabric-samples</code>文件夹中一个众所周知的<code class="eh lk ll lm ln b">fabcar</code>的例子。在我们安装了应用程序依赖项之后，我们可以使用Node.js SDK <br/>来创建我们的监听器应用程序将用来与<br/>网络交互的身份。运行以下命令注册管理员用户:</p><pre class="lo lp lq lr fq ls ln lt lu aw lv dt"><span id="9d27" class="lw jj ht ln b fv lx ly l lz ma">node enrollAdmin.js</span></pre><p id="6983" class="pw-post-body-paragraph kg kh ht ki b kj lf kl km kn lg kp kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">将在<code class="eh lk ll lm ln b">wallet</code>文件夹下创建一个名为<code class="eh lk ll lm ln b">admin.id</code>的文件来存储管理员的身份。该身份将用于代表测试网络管理员与Hyperledger进行交互。</p><p id="37ca" class="pw-post-body-paragraph kg kh ht ki b kj lf kl km kn lg kp kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated"><strong class="ki hu">一个问题</strong>是，在web服务器文件系统上存储身份不是一个好主意。如果我们需要将单个web服务器扩展到多个实例，并将它们放在web负载平衡器后面，该怎么办？身份文件需要在所有服务器之间同步，以使请求成为可能，这非常麻烦。</p><pre class="lo lp lq lr fq ls ln lt lu aw lv dt"><span id="9f9a" class="lw jj ht ln b fv lx ly l lz ma">We need to store user's identity in a central database (although by doing this we lost the decentralization). </span></pre><p id="1c28" class="pw-post-body-paragraph kg kh ht ki b kj lf kl km kn lg kp kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">除了我们目前使用FileSystemWalletStore之外，Fabric还支持另外两种钱包:</p><ul class=""><li id="f039" class="mn mo ht ki b kj lf kn lg kr mp kv mq kz mr ld ms mt mu mv dt translated">CouchDB钱包商店</li><li id="18b9" class="mn mo ht ki b kj mw kn mx kr my kv mz kz na ld ms mt mu mv dt translated">内存中的钱包存储</li></ul><p id="ba73" class="pw-post-body-paragraph kg kh ht ki b kj lf kl km kn lg kp kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">※参考资料:<a class="ae le" href="https://github.com/hyperledger/fabric-sdk-node/tree/7a1eedfb3d13a1797fd9fb4a7a8ca34c46733d06/fabric-network/src/impl/wallet" rel="noopener ugc nofollow" target="_blank">https://github . com/hyperledger/fabric-SDK-node/tree/7 a1 eed FB 3d 13 a 1797 FD 9 FB 4 a7 A8 ca 34 c 46733d 06/fabric-network/src/impl/wallet</a></p><p id="bc68" class="pw-post-body-paragraph kg kh ht ki b kj lf kl km kn lg kp kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">这些钱包存储作为中间的存储库，帮助应用程序将用户的钱包存储在CouchDB或内存中。</p><pre class="lo lp lq lr fq ls ln lt lu aw lv dt"><span id="341a" class="lw jj ht ln b fv lx ly l lz ma">The question is : What if we need MySQL wallet store or Postgres wallet store? </span></pre><h1 id="e663" class="ji jj ht bd jk jl mb jn jo jp mc jr js jt md jv jw jx me jz ka kb mf kd ke kf dt translated">实现自定义钱包存储</h1><p id="86e0" class="pw-post-body-paragraph kg kh ht ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">在我的例子中，我和我的团队在NetsJS api服务器上工作，它有Postgres数据库。我们希望将用户的钱包存储在Postgres中，而不是文件系统或沙发数据库或内存中。这一需求导致我们需要实现一个支持Postgres DB的自定义钱包商店。起初这似乎很难，但随着深入研究，我们发现实现这种事情是很容易的。首先，我们来看看所有Wallet Store实现都必须遵循的钱包商店接口:</p><pre class="lo lp lq lr fq ls ln lt lu aw lv dt"><span id="7cdf" class="lw jj ht ln b fv lx ly l lz ma">/// &lt;reference types="node" /&gt;<br/>export interface WalletStore {<br/>    get(label: string): Promise&lt;Buffer | undefined&gt;;<br/>    list(): Promise&lt;string[]&gt;;<br/>    put(label: string, data: Buffer): Promise&lt;void&gt;;<br/>    remove(label: string): Promise&lt;void&gt;;<br/>}</span></pre><p id="e46f" class="pw-post-body-paragraph kg kh ht ki b kj lf kl km kn lg kp kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">很简单，不是吗？只需要实现4个方法</p><ul class=""><li id="54a0" class="mn mo ht ki b kj lf kn lg kr mp kv mq kz mr ld ms mt mu mv dt translated"><strong class="ki hu"> get </strong>():获取与给定标签相关的数据。</li><li id="d2e5" class="mn mo ht ki b kj mw kn mx kr my kv mz kz na ld ms mt mu mv dt translated"><strong class="ki hu">列表</strong>():列出所有存储数据的标签</li><li id="d403" class="mn mo ht ki b kj mw kn mx kr my kv mz kz na ld ms mt mu mv dt translated"><strong class="ki hu"> put </strong>():放置与给定标签相关的数据。</li><li id="0200" class="mn mo ht ki b kj mw kn mx kr my kv mz kz na ld ms mt mu mv dt translated"><strong class="ki hu">删除</strong>():删除与给定标签相关的数据。</li></ul><p id="2a8e" class="pw-post-body-paragraph kg kh ht ki b kj lf kl km kn lg kp kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">因此，如果执行这4个函数，我们需要访问存储钱包的Postgres表。在我们的例子中，一个名为table的用户将存储所有用户信息，它的<code class="eh lk ll lm ln b">wallet</code>字段用于存储相应的他/她的身份。</p><pre class="lo lp lq lr fq ls ln lt lu aw lv dt"><span id="a7a6" class="lw jj ht ln b fv lx ly l lz ma">import { Entity, Column, PrimaryGeneratedColumn } from 'typeorm';<br/><br/>@Entity({ name: 'users' })<br/>export class User {<br/>  @PrimaryGeneratedColumn()<br/>  public id: number;<br/><br/>  @Column({ unique: true })<br/>  public email: string;<br/><br/>  @Column({ select: false })<br/>  public password?: string;<br/><br/>  @Column()<br/>  public name: string;<br/><br/>  @Column({ select: false, nullable: true })<br/><strong class="ln hu">  public wallet: string;<br/></strong><br/>  @Column({ name: 'display_name', nullable: true })<br/>  public displayName: string;<br/><br/>  @Column({ type: 'text', nullable: true })<br/>  public avatar: string;<br/><br/>  @Column({ nullable: true, type: 'date' })<br/>  public dob: Date;<br/><br/>  @Column({ nullable: true })<br/>  public address: string;<br/>}</span></pre><p id="a35c" class="pw-post-body-paragraph kg kh ht ki b kj lf kl km kn lg kp kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">通过使用userRepository作为与表交互的方法，wallet store的实现将会很简单。请注意:</p><ul class=""><li id="9cb7" class="mn mo ht ki b kj lf kn lg kr mp kv mq kz mr ld ms mt mu mv dt translated">我们使用电子邮件(唯一的)作为寻找钱包的标签</li><li id="8299" class="mn mo ht ki b kj mw kn mx kr my kv mz kz na ld ms mt mu mv dt translated">由于默认情况下<code class="eh lk ll lm ln b">wallet</code>是<code class="eh lk ll lm ln b">select:false</code>,因此select查询不会检索到它，这就是为什么我们需要手动显式添加<code class="eh lk ll lm ln b">wallet</code>。</li></ul><pre class="lo lp lq lr fq ls ln lt lu aw lv dt"><span id="2347" class="lw jj ht ln b fv lx ly l lz ma">import { User } from '../user/entities/user.entity';<br/>import { Repository } from 'typeorm';<br/>import { WalletStore } from 'fabric-network';<br/><br/>export class DbWalletStore implements WalletStore {<br/>  constructor(private readonly userRepository: Repository&lt;User&gt;) {}<br/><br/>  public async remove(email: string): Promise&lt;any&gt; {<br/>    const user: User = await this.userRepository.findOneOrFail({<br/>      where: { email: email },<br/>    });<br/>    user.wallet = null;<br/>    try {<br/>      await this.userRepository.save(user);<br/>      return true;<br/>    } catch (e) {<br/>      return false;<br/>    }<br/>  }<br/><br/>  public async get(email: string): Promise&lt;Buffer&gt; {<br/>    const user: User = await this.userRepository<br/>      .createQueryBuilder('users')<br/>      .select('users')<br/>      .where({ email: email })<br/>      .addSelect('users.wallet')<br/>      .getOneOrFail();<br/>    return user.wallet ? <strong class="ln hu"><em class="mj">Buffer</em></strong>.from(user.wallet, 'utf-8') : null;<br/>  }<br/><br/>  public async list(): Promise&lt;string[]&gt; {<br/>    const users: User[] = await this.userRepository<br/>      .createQueryBuilder('users')<br/>      .select('users')<br/>      .addSelect('users.wallet')<br/>      .getMany();<br/>    return users.map((user) =&gt; {<br/>      return user.wallet;<br/>    });<br/>  }<br/><br/>  public async put(email: string, data: Buffer): Promise&lt;any&gt; {<br/>    const user: User = await this.userRepository.findOneOrFail({<br/>      where: { email: email },<br/>    });<br/>    user.wallet = data.toString('utf8');<br/>    try {<br/>      await this.userRepository.save(user);<br/>      return true;<br/>    } catch (e) {<br/>      return false;<br/>    }<br/>  }<br/>}</span></pre><p id="a508" class="pw-post-body-paragraph kg kh ht ki b kj lf kl km kn lg kp kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">要使用DBWalletStore，我们需要在它的构造函数中注入<code class="eh lk ll lm ln b">userRepository</code>。为此，我们创建了一个名为fabric的模块，并在fabric服务中启动钱包存储。</p><p id="fd0a" class="pw-post-body-paragraph kg kh ht ki b kj lf kl km kn lg kp kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated"><strong class="ki hu"><em class="mj">fabric . module . ts</em></strong></p><pre class="lo lp lq lr fq ls ln lt lu aw lv dt"><span id="6211" class="lw jj ht ln b fv lx ly l lz ma">import { Module } from '@nestjs/common';<br/>import { FabricService } from './fabric.service';<br/>import { DbWalletStore } from './dbwallet-store';<br/>import { TypeOrmModule } from '@nestjs/typeorm';<br/>import { User } from '../user/entities/user.entity';<br/>import { ConfigModule, ConfigService} from '@nestjs/config';<br/><br/>@Module({<br/>  imports: [TypeOrmModule.<em class="mj">forFeature</em>([User]), ConfigModule],<br/>  providers: [DbWalletStore, FabricService, ConfigService],<br/>  exports: [FabricService, ConfigService],<br/>})<br/>export class FabricModule {}</span></pre><p id="c452" class="pw-post-body-paragraph kg kh ht ki b kj lf kl km kn lg kp kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated"><strong class="ki hu">T20T22】</strong></p><pre class="lo lp lq lr fq ls ln lt lu aw lv dt"><span id="1d02" class="lw jj ht ln b fv lx ly l lz ma">export class FabricService {<br/>  <em class="mj">/**<br/>   * Inject User repository for R/W wallet information<br/>   */<br/>  </em>private readonly connectionConfigurations: Record&lt;string, any&gt;[];<br/>  private readonly walletStore: DbWalletStore;<br/><br/>  constructor(<br/>    @InjectRepository(User)<br/>    private readonly userRepository: Repository&lt;User&gt;,<br/>    private configService: ConfigService,<br/>  ) {<br/><strong class="ln hu">    this.walletStore = new DbWalletStore(this.userRepository);<br/></strong>  }</span></pre><p id="03bb" class="pw-post-body-paragraph kg kh ht ki b kj lf kl km kn lg kp kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">现在，您可以将示例中使用FileSystemWalletStore的代码替换为我们的自定义钱包存储:</p><p id="6f1a" class="pw-post-body-paragraph kg kh ht ki b kj lf kl km kn lg kp kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">替换这个:</p><pre class="lo lp lq lr fq ls ln lt lu aw lv dt"><span id="e5d3" class="lw jj ht ln b fv lx ly l lz ma">const walletPath = path.join(process.cwd(), 'wallet');<br/>const wallet = await Wallets.newFileSystemWallet(walletPath);<br/></span></pre><p id="4345" class="pw-post-body-paragraph kg kh ht ki b kj lf kl km kn lg kp kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">通过这个:</p><pre class="lo lp lq lr fq ls ln lt lu aw lv dt"><span id="6e53" class="lw jj ht ln b fv lx ly l lz ma">const wallet = new Wallet(this.walletStore);</span></pre><p id="8693" class="pw-post-body-paragraph kg kh ht ki b kj lf kl km kn lg kp kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">我们不再使用Wallet类，因为如果您查看源代码，您会发现Wallet实际上遵循工厂模式，除了创建一个Wallet实例之外什么也不做</p><pre class="lo lp lq lr fq ls ln lt lu aw lv dt"><span id="ca7d" class="lw jj ht ln b fv lx ly l lz ma">/**<br/>  * Create a wallet backed by the provided file system directory.<br/>  * <a class="ae le" href="http://twitter.com/param" rel="noopener ugc nofollow" target="_blank">@param</a> {string} directory A directory path.<br/>  * <a class="ae le" href="http://twitter.com/returns" rel="noopener ugc nofollow" target="_blank">@returns</a> {Promise&lt;module:fabric-network.Wallet&gt;} A wallet.<br/>  */<br/> public static async newFileSystemWallet(directory: string): Promise&lt;Wallet&gt; {<br/>  const store = await FileSystemWalletStore.newInstance(directory);<br/>  return new Wallet(store);<br/> }</span></pre><h1 id="c646" class="ji jj ht bd jk jl mb jn jo jp mc jr js jt md jv jw jx me jz ka kb mf kd ke kf dt translated">#结束</h1><p id="f73c" class="pw-post-body-paragraph kg kh ht ki b kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld hm dt translated">感谢KC Tam先生关于Hyperledger Fabric的有价值的系列文章，它激励我写这篇教程。</p><p id="a515" class="pw-post-body-paragraph kg kh ht ki b kj lf kl km kn lg kp kq kr lh kt ku kv li kx ky kz lj lb lc ld hm dt translated">在下一篇教程中，我将向您展示如何使用NestJS以更简洁的方式与Hyperledger Fabric进行交互。尽情享受吧！</p><blockquote class="nd"><p id="1f38" class="ne nf ht bd ng nh ni nj nk nl nm ld ek translated">交易新手？试试<a class="ae le" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a>或者<a class="ae le" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>