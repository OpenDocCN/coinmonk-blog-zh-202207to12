<html>
<head>
<title>Learn Solidity lesson 21. Abi encode and decode.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习第21课坚固性。Abi编码和解码。</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/learn-solidity-lesson-21-abi-encode-and-decode-e99ed3524098?source=collection_archive---------0-----------------------#2022-08-11">https://medium.com/coinmonks/learn-solidity-lesson-21-abi-encode-and-decode-e99ed3524098?source=collection_archive---------0-----------------------#2022-08-11</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/b17be82731521e408db7dfe121ea6ac8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*F9jaz2JxQ1_yDAWrZCQPMw.jpeg"/></div></div></figure><p id="edc1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当我们想在契约中调用一个函数时，我们编写类似于<em class="jz"> function(arguments) </em>的表达式。然而，EVM不理解这种表达方式。我们需要发送给区块链的是一个二进制表达式，按照它的<strong class="jd hu"> ABI </strong> ( <strong class="jd hu"> A </strong>应用<strong class="jd hu"> B </strong>二进制<strong class="jd hu"> I </strong>接口)进行编码。</p><p id="6b7e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">合同的ABI可以理解为如何与合同交互的手册。在ABI中，我们可以找到关于其所有公共或外部函数的信息，以及每个函数接收的参数的数量和类型。</p><p id="f105" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">有了这些信息和编码规则，就有可能对将要发送到EVM的交易进行编码。人类更容易理解表达式<em class="jz"> function(arguments) </em>，但EVM只理解二进制(实际上是十六进制)。</p><p id="7f4d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">通过一个例子更容易理解这种编码是如何工作的。让我们写下面的合同。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="7efa" class="kj kk ht kf b fv kl km l kn ko">pragma solidity ^0.8.7;</span><span id="ef25" class="kj kk ht kf b fv kp km l kn ko">contract Abi {</span><span id="a49f" class="kj kk ht kf b fv kp km l kn ko">   uint256 public value;</span><span id="ada1" class="kj kk ht kf b fv kp km l kn ko">   function setValue(uint256 _value) public {<br/>      value = _value;<br/>   }<br/>}</span></pre><p id="c508" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">要调用函数<code class="eh kq kr ks kf b">setValue</code>，将<code class="eh kq kr ks kf b">7</code>的值作为参数<code class="eh kq kr ks kf b">_value</code>的参数，我们必须将以下数据(通常称为有效载荷)发送到EVM。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="15f6" class="kj kk ht kf b fv kl km l kn ko">0x552410770000000000000000000000000000000000000000000000000000000000000007</span></pre><p id="75e6" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">信不信由你(最好相信)，上面的十六进制数是EVM调用带有参数值<code class="eh kq kr ks kf b">7</code>的函数<code class="eh kq kr ks kf b">setValue</code>的指令。</p><p id="099b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这可以在Remix控制台中看到。部署契约后，使用上述参数创建一个调用该函数的事务，并在调试面板(右下角)中打开该事务。寻找输入。</p><figure class="ka kb kc kd fq iu fe ff paragraph-image"><div class="fe ff kt"><img src="../Images/0a774e655ee405a59bf74aa7983a65ae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1046/format:webp/1*keXzCKPUcY__g7EWmrHD0w.png"/></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">In Remix, you can see the data that was sent in the transaction.</figcaption></figure><p id="36b8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">问题是:知道了函数<code class="eh kq kr ks kf b">setValue</code>的结构，我们如何构造这个有效载荷？我们如何对这个事务进行编码？让我们看看。</p><h1 id="de13" class="ky kk ht bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">函数的签名</h1><p id="038b" class="pw-post-body-paragraph jb jc ht jd b je lv jg jh ji lw jk jl jm lx jo jp jq ly js jt ju lz jw jx jy hm dt translated">Solidity中的每个函数都有一个签名，它是作为函数的Keccak256散列的前4个字节以及它的参数计算出来的。明白了吗？也许我应该解释得更清楚些。</p><p id="a4ee" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu"> Keccak256 </strong>是一个哈希函数。哈希函数是加密函数，它将任何数据作为输入，并返回一个固定值(在本例中为32字节)。有几个库实现了函数keccak256，包括Solidity。</p><p id="0e7b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在我们不使用Solidity来计算keccak256，而是使用一个在线站点来生成一个字符串的散列。例如，你可以使用emn178.github.io/online-tools/keccak\_256.html的网站。如果没有，谷歌搜索几乎肯定会把你指向一个可以计算字符串keccak256的站点。</p><figure class="ka kb kc kd fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mb"><img src="../Images/4cc94ee53c6dcab7e997c4e1c177f4a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-1VvrC6573EinzaHGvdy9A.png"/></div></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">Hashing the string ‘’Olá mundo!’’</figcaption></figure><p id="69e7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">字符串“Hello World”的hash在上面的底部，即<em class="jz"> 37707…3f0e </em>。请注意，哈希是一个64位数字，因为它可以是介于“a”和“f”之间的数字或字母。我们正在处理一个十六进制数(基数为16)。每个字节需要2个数字，所以这是32个字节。</p><p id="f0e0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">要计算函数<code class="eh kq kr ks kf b">setValue</code>的签名，只需计算函数名及其参数的hash，就像这样:<strong class="jd hu">keccak 256(setValue(uint 256))</strong>。签名是前4个字节(8位数)。</p><p id="c49c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这是在下图中完成的。hash是一个很长的数字<em class="jz"> 5524107728b6…becbd </em>，但是签名只是前4个字节:<strong class="jd hu"> 55241077 </strong>。</p><figure class="ka kb kc kd fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mc"><img src="../Images/952a0d739341a459178484ef975b5d4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yPCb6bjNyRolJzURB6cJlg.png"/></div></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">Hashing the string setValue(uint256)</figcaption></figure><p id="c830" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们记住发送到EVM的有效载荷，以执行函数<code class="eh kq kr ks kf b">setValue</code>:<em class="jz">0x 55241077000000…000007</em>。前4个字节正是函数签名。在签名之后，我们有32个字节来表示函数参数，数字7。</p><h1 id="b25c" class="ky kk ht bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">对参数进行编码和解码</h1><p id="442d" class="pw-post-body-paragraph jb jc ht jd b je lv jg jh ji lw jk jl jm lx jo jp jq ly js jt ju lz jw jx jy hm dt translated">函数参数的编码可能简单也可能复杂，这取决于参数的数量，尤其是参数的类型。尽管对整数进行编码非常简单，但对字符串和数组进行编码却有些复杂。</p><p id="c5a7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">幸运的是，Solidity为我们提供了一个名为<strong class="jd hu"> abi </strong>的全局变量，有几种方法可以对函数和参数进行编码和解码。</p><p id="6244" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">幸运的是，我们通常不需要对函数调用进行编码，因为各种编程语言中有几个库可以为我们做这些。然而，理解ABI和函数签名是很重要的。</p><p id="3aab" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们使用solidity全局变量<em class="jz"> abi </em>来编码函数的参数，遵循abi协议。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="82e7" class="kj kk ht kf b fv kl km l kn ko">function encode() public pure returns (bytes memory) {<br/>   return abi.encode(7);<br/>}</span></pre><p id="5d2f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们使用方法<code class="eh kq kr ks kf b">abi.encode</code>来编码一个假定函数的参数。因为参数的数量是任意的，所以返回的总是类型为<em class="jz">字节</em>。在上面的示例中，该函数返回:</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="2815" class="kj kk ht kf b fv kl km l kn ko">0x0000000000000000000000000000000000000000000000000000000000000007</span></pre><p id="ef5b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">基本上就是十六进制写的数字7，用32个字节来表示。</p><p id="81f2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">本课的目的不是详细解释EVM如何编码和解码函数参数，而是让我们看一些例子。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="6cb0" class="kj kk ht kf b fv kl km l kn ko">abi.encode(14, 22); <br/>// 0x000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000016</span><span id="bd37" class="kj kk ht kf b fv kp km l kn ko">abi.encode(0x7EF2e0048f5bAeDe046f6BF797943daF4ED8CB47, "Hello") <br/>//<br/>0x0000000000000000000000007ef2e0048f5baede046f6bf797943daf4ed8cb470000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000548656c6c6f000000000000000000000000000000000000000000000000000000</span></pre><p id="edbd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">Solidity也有解码一个先前在ABI协议中编码的值的方法。我们来解码之前的编码。</p><p id="dae8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">下面我们来看看函数。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="bc27" class="kj kk ht kf b fv kl km l kn ko">function encode() public pure returns (bytes memory) {<br/>   return abi.encode(0x7EF2e0048f5bAeDe046f6BF797943daF4ED8CB47, "Hello");<br/>}</span><span id="3616" class="kj kk ht kf b fv kp km l kn ko">function decode() public pure returns (address, string memory) {<br/>   bytes memory encodedData = encode();<br/>   return abi.decode(encodedData, (address, string));<br/>}</span></pre><p id="b9fa" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们使用encode方法对参数进行编码。为了解码参数，我们使用方法<code class="eh kq kr ks kf b">abi.decode</code>。这个方法有两个参数:第一个是编码值，类型为<em class="jz">字节</em>，第二个是具有期望值类型的元组。在上面的例子中，我们期望返回一个地址和一个字符串。回报可以在下图中看到。</p><figure class="ka kb kc kd fq iu fe ff paragraph-image"><div class="fe ff md"><img src="../Images/bee629746cb3b6fb69d2793a247542e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*TslFtoawU2fI3CWXUMzELA.png"/></div><figcaption class="ku kv fg fe ff kw kx bd b be z ek">Decoding the arguments using abi.decode.</figcaption></figure><h1 id="d203" class="ky kk ht bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">全局变量abi</h1><p id="619a" class="pw-post-body-paragraph jb jc ht jd b je lv jg jh ji lw jk jl jm lx jo jp jq ly js jt ju lz jw jx jy hm dt translated">全局变量<em class="jz"> abi </em>有几种方法。我们看到了上面的方法<em class="jz"> abi.encode </em>和<em class="jz"> abi.decode </em>。让我们看看这个全局变量的其他一些方法。</p><h2 id="c001" class="kj kk ht bd kz me mf mg ld mh mi mj lh jm mk ml ll jq mm mn lp ju mo mp lt mq dt translated">用签名编码</h2><p id="1614" class="pw-post-body-paragraph jb jc ht jd b je lv jg jh ji lw jk jl jm lx jo jp jq ly js jt ju lz jw jx jy hm dt translated">让我们记住，当我们在EVM中调用一个函数时，有效载荷的前四个字节代表函数的签名。可以使用方法<em class="jz"> abi.encodeWithSignature </em>将函数的参数与其签名一起编码。</p><p id="733e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们使用这个方法对函数<code class="eh kq kr ks kf b">setValue(uint256 _value)</code>进行编码，将数字7作为它的参数。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="245b" class="kj kk ht kf b fv kl km l kn ko">abi.encodeWithSignature("setValue(uint256)", 7); // 0x552410770000000000000000000000000000000000000000000000000000000000000007</span></pre><p id="9391" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果函数有多个参数，参数的类型必须用逗号分隔，中间不能有空格。见下文。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="f3f4" class="kj kk ht kf b fv kl km l kn ko">abi.encodeWithSignature("setTwoValues(uint32,uint32)",7,12); <br/>// 0xd80aa9ea0000000000000000000000000000000000000000000000000000000000000007000000000000000000000000000000000000000000000000000000000000000c</span></pre><p id="d885" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">计算函数签名时的一些重要提示。</p><ul class=""><li id="db0b" class="mr ms ht jd b je jf ji jj jm mt jq mu ju mv jy mw mx my mz dt translated">字符串中错位的空格表示该函数将为该函数生成不同的签名。“setTwoValues(uint32，uint32)”的哈希与“setTwoValues(uint32，uint32)”不同(逗号后有空格)。</li><li id="c3e7" class="mr ms ht jd b je na ji nb jm nc jq nd ju ne jy mw mx my mz dt translated">类型<em class="jz"> uint </em>和<em class="jz"> int </em>分别是<em class="jz"> uint256 </em>和<em class="jz"> int256 </em>的别名。在哈希中始终使用<em class="jz"> uint256 </em>和<em class="jz"> int256 </em>。</li></ul><p id="bd23" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">请注意，参数以32字节的块进行编码，即使其中一些需要更少的空间来这样做。虽然上述两个参数都只占用8个字节，但它们是用32个字节编码的。这就是EVM所期望的事务负载。</p><p id="aaa6" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">有一种方法可以对值进行编码，只占用其类型所需的大小，方法是<em class="jz"> encodePacked </em>。</p><h2 id="8408" class="kj kk ht bd kz me mf mg ld mh mi mj lh jm mk ml ll jq mm mn lp ju mo mp lt mq dt translated">abi.encodePacked</h2><p id="08c4" class="pw-post-body-paragraph jb jc ht jd b je lv jg jh ji lw jk jl jm lx jo jp jq ly js jt ju lz jw jx jy hm dt translated">使用方法<em class="jz"> abi.encodePacked </em>，参数被编码成只占用它们需要的大小。这不是EVM在接收函数时的工作方式，我们不能从以这种方式编码的函数中发送参数，但这种“打包”编码在某些情况下是有用的。</p><p id="b07f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">首先，让我们通过一个例子来看看它是如何工作的:</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="b412" class="kj kk ht kf b fv kl km l kn ko">abi.encodePacked(string("Hello"), uint8(134), bool(false), string("World!")); // 0x48656c6c6f8600576f726c6421</span></pre><p id="d1e1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">请注意，我们需要通过类型转换显式通知要编码的变量的类型。如果您不知道什么是类型转换，不要担心，它将在后面的课程中介绍。</p><p id="189e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我将把返回分成几部分，这样我们可以更好地理解编码是如何完成的。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="20d0" class="kj kk ht kf b fv kl km l kn ko">// 0x48656c6c6f8600576f726c6421 <br/>// 48656c6c6f -&gt; "Hello" in UTF-8<br/>// 86 -&gt; 134 in hexadecimal<br/>// 00 -&gt; false<br/>// 576f726c6421 -&gt; "World!" in UTF-8</span></pre><p id="4822" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">请注意，每个变量只占用其类型所需的空间。字符串“Hello”占用5个字节；类型<em class="jz"> uint8 </em>占用1个字节；布尔型占用1个字节；字符串“世界！”占用6个字节。这与普通编码完全不同，普通编码使用32字节的块。</p><p id="82b5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当我们想要连接不同类型的值时，方法<em class="jz"> abi.encodePacked </em>是有用的，例如，生成数据集合的散列。我们将在更高级的课程中看到它的用途。</p><p id="1e84" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当我们想要直接处理存储在<em class="jz">存储器</em>中的值时，它也是有用的，因为它们是以“打包”的方式写入的。</p><p id="f588" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">感谢阅读！</strong></p><p id="56e7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎对本文提出意见和建议。</p><p id="b00f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎任何投稿。【www.buymeacoffee.com/jpmorais T4】</p><blockquote class="nf"><p id="eecb" class="ng nh ht bd ni nj nk nl nm nn no jy ek translated">交易新手？尝试<a class="ae ma" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae ma" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>