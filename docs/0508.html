<html>
<head>
<title>Solidity — Arrays + Examples</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">坚固性——数组+示例</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/solidity-arrays-examples-1870cc18ce1c?source=collection_archive---------5-----------------------#2022-07-11">https://medium.com/coinmonks/solidity-arrays-examples-1870cc18ce1c?source=collection_archive---------5-----------------------#2022-07-11</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/49a7718d7446f8e61a083a1eaa997d6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s2VkKnuUdYleAw5Edc_LFw.jpeg"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">Photo by <a class="ae jf" href="https://unsplash.com/es/@markusspiske?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae jf" href="https://unsplash.com/s/photos/data-array?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2d82" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在Solidity中，数组采用了与JavaScript类似的结构和风格，但是仍然有一些复杂的语言特有的细节。这篇文章是Solidity数组的入门，并试图总结其中的一些特性。一如既往，如果我做错了什么，请告诉我。</p></div><div class="ab cl ke kf hb kg" role="separator"><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj kk"/><span class="kh bw bk ki kj"/></div><div class="hm hn ho hp hq"><h2 id="4f6a" class="kl km ht bd kn ko kp kq kr ks kt ku kv jr kw kx ky jv kz la lb jz lc ld le lf dt translated">介绍</h2><p id="2916" class="pw-post-body-paragraph jg jh ht ji b jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd hm dt translated">Solidity中的数组是一种引用类型，这意味着它们<em class="ll">引用</em>现有数据。这与值类型形成对比，值类型传递该值的独立副本以供使用。因此，这意味着引用类型可以通过多个不同的名称(即它们的每个引用)来修改。这类似于JavaScript引用类型。</p><p id="9ff3" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在下面的例子中，<code class="eh lm ln lo lp b">z</code>和<code class="eh lm ln lo lp b">y</code>都引用了<code class="eh lm ln lo lp b">x</code>，因此当调用<code class="eh lm ln lo lp b">f()</code>时，它们都可以改变(中的第三个元素)<code class="eh lm ln lo lp b">x</code>:</p><figure class="lq lr ls lt fq iu"><div class="bz el l di"><div class="lu lv l"/></div></figure><p id="ee92" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在Solidity中，引用类型由结构、数组和映射组成，使用起来比基本值类型(int、bools等)更复杂，因为数据位置也必须显式声明:或者<code class="eh lm ln lo lp b">memory</code>、<code class="eh lm ln lo lp b">storage</code>或者<code class="eh lm ln lo lp b">calldata</code>。唯一的例外是状态变量，自动假设，只能是<code class="eh lm ln lo lp b">storage</code>。前一篇<a class="ae jf" rel="noopener" href="/coinmonks/solidity-storage-vs-memory-vs-calldata-8c7e8c38bce">文章</a>探讨了其中的一些差异。我们将只在这里探索数组。</p><p id="26a4" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">总的来说:</p><ul class=""><li id="8eae" class="lw lx ht ji b jj jk jn jo jr ly jv lz jz ma kd mb mc md me dt translated"><code class="eh lm ln lo lp b">memory</code> —生存期限于外部函数调用，可变，作用域在函数内(非持久，可修改)</li><li id="6e1d" class="lw lx ht ji b jj mf jn mg jr mh jv mi jz mj kd mb mc md me dt translated"><code class="eh lm ln lo lp b">storage</code> —其生存期限于包含它的<em class="ll">契约</em>的生存期，是可变的，并且是存储所有状态变量的位置(持久的，可变的)</li><li id="d865" class="lw lx ht ji b jj mf jn mg jr mh jv mi jz mj kd mb mc md me dt translated"><code class="eh lm ln lo lp b">calldata</code> —类似于<code class="eh lm ln lo lp b">memory</code>，不可变，是一个包含函数参数的特殊数据位置(非持久、不可修改)</li></ul><blockquote class="mk ml mm"><p id="ad7a" class="jg jh ll ji b jj jk jl jm jn jo jp jq mn js jt ju mo jw jx jy mp ka kb kc kd hm dt translated">交易新手？试试<a class="ae jf" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或者<a class="ae jf" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote><h1 id="a6cc" class="mq km ht bd kn mr ms mt kr mu mv mw kv mx my mz ky na nb nc lb nd ne nf le ng dt translated">数据位置效应</h1><p id="0672" class="pw-post-body-paragraph jg jh ht ji b jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd hm dt translated">数组(和其他引用类型)的数据位置对赋值行为有影响:</p><ul class=""><li id="4664" class="lw lx ht ji b jj jk jn jo jr ly jv lz jz ma kd mb mc md me dt translated"><strong class="ji hu">赋值在</strong> <code class="eh lm ln lo lp b"><strong class="ji hu">storage</strong></code> <strong class="ji hu">和</strong> <code class="eh lm ln lo lp b"><strong class="ji hu">memory</strong></code> <strong class="ji hu">(或从</strong> <code class="eh lm ln lo lp b"><strong class="ji hu">calldata</strong></code> <strong class="ji hu">)之间总是创建一个独立的副本</strong></li></ul><p id="87be" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在下面的例子中，即使<code class="eh lm ln lo lp b">x</code>是一个<code class="eh lm ln lo lp b">storage</code>数组，并且<code class="eh lm ln lo lp b">g</code>接受<code class="eh lm ln lo lp b">memory</code>数组，也可以在内部调用<code class="eh lm ln lo lp b">g(x)</code>(通过在外部调用<code class="eh lm ln lo lp b">f() </code>),因为<code class="eh lm ln lo lp b">g(x)</code>调用在<code class="eh lm ln lo lp b">memory</code>中传递了一个单独的、独立的<code class="eh lm ln lo lp b">x</code>副本。</p><figure class="lq lr ls lt fq iu"><div class="bz el l di"><div class="lu lv l"/></div></figure><ul class=""><li id="dd20" class="lw lx ht ji b jj jk jn jo jr ly jv lz jz ma kd mb mc md me dt translated"><strong class="ji hu">从</strong> <code class="eh lm ln lo lp b"><strong class="ji hu">memory</strong></code> <strong class="ji hu">到</strong> <code class="eh lm ln lo lp b"><strong class="ji hu">memory</strong></code> <strong class="ji hu">的赋值只创建引用。这意味着对一个内存变量的更改在引用相同数据的所有其他内存变量中也是可见的</strong></li></ul><p id="a657" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在下面的例子中，因为<code class="eh lm ln lo lp b">z</code>和<code class="eh lm ln lo lp b">zz</code> <code class="eh lm ln lo lp b">memory</code>数组引用相同的底层<code class="eh lm ln lo lp b">memory</code>数组(<code class="eh lm ln lo lp b">y</code>)，所以对一个<code class="eh lm ln lo lp b">memory</code>变量的更改会影响引用相同数据的所有其他变量。</p><figure class="lq lr ls lt fq iu"><div class="bz el l di"><div class="lu lv l"/></div></figure><ul class=""><li id="6203" class="lw lx ht ji b jj jk jn jo jr ly jv lz jz ma kd mb mc md me dt translated"><strong class="ji hu">赋值从</strong> <code class="eh lm ln lo lp b"><strong class="ji hu">storage</strong></code> <strong class="ji hu">到一个局部</strong> <code class="eh lm ln lo lp b"><strong class="ji hu">storage</strong></code> <strong class="ji hu">变量也只赋值一个引用</strong></li></ul><p id="bdef" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在下面的例子中，局部<code class="eh lm ln lo lp b">storage</code>变量<code class="eh lm ln lo lp b">z</code>引用<code class="eh lm ln lo lp b">x</code>，因此能够通过调用<code class="eh lm ln lo lp b">f()</code>更新第<code class="eh lm ln lo lp b">0</code>个索引中<code class="eh lm ln lo lp b">x</code>的值。私有函数<code class="eh lm ln lo lp b">h(y)</code>也可以更新<code class="eh lm ln lo lp b">x</code>，因为再次传递的是对<code class="eh lm ln lo lp b">x</code>的引用，而不是副本。</p><p id="d093" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">*注意，如果<code class="eh lm ln lo lp b">h</code>既不是<code class="eh lm ln lo lp b">private</code>也不是<code class="eh lm ln lo lp b">internal</code>，那么这个例子甚至无法编译，因为在那种情况下<code class="eh lm ln lo lp b">h</code>的函数参数将被要求要么是<code class="eh lm ln lo lp b">memory</code>要么是<code class="eh lm ln lo lp b">calldata</code>——局部<code class="eh lm ln lo lp b">storage</code>变量只能作为对现有存储变量的引用传入函数，而不能用于公共函数。它们特别适用于1)代替引用变量的操作，或2)在库函数中访问存储数据。</p><figure class="lq lr ls lt fq iu"><div class="bz el l di"><div class="lu lv l"/></div></figure><ul class=""><li id="86f0" class="lw lx ht ji b jj jk jn jo jr ly jv lz jz ma kd mb mc md me dt translated"><strong class="ji hu">对</strong> <code class="eh lm ln lo lp b"><strong class="ji hu">storage</strong></code> <strong class="ji hu">的所有其他赋值总是复制——包括对状态变量的赋值，即使局部变量本身只是一个引用</strong></li></ul><p id="1815" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在下面的例子中，允许将状态变量<code class="eh lm ln lo lp b">x</code>赋给<code class="eh lm ln lo lp b">memory</code>或<code class="eh lm ln lo lp b">calldata</code>数组，因为整个数组都被复制到了<code class="eh lm ln lo lp b">storage</code>中。它们被显示为副本(而不是引用),因为更新<code class="eh lm ln lo lp b">x[0]</code>对<code class="eh lm ln lo lp b">y</code>或<code class="eh lm ln lo lp b">z</code>都没有影响。</p><figure class="lq lr ls lt fq iu"><div class="bz el l di"><div class="lu lv l"/></div></figure><h2 id="8527" class="kl km ht bd kn ko kp kq kr ks kt ku kv jr kw kx ky jv kz la lb jz lc ld le lf dt translated">动态大小与固定大小阵列</h2><p id="5ef8" class="pw-post-body-paragraph jg jh ht ji b jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd hm dt translated">数组可以具有编译时的固定大小，也可以具有动态大小。对于固定大小<code class="eh lm ln lo lp b">k</code>(即5个元素)和元素类型<code class="eh lm ln lo lp b">T</code>(即<code class="eh lm ln lo lp b">uint256</code>)，固定大小数组用<code class="eh lm ln lo lp b">T[k]</code>(即<code class="eh lm ln lo lp b">uint256[5]</code>)表示，动态大小数组用<code class="eh lm ln lo lp b">T[]</code>(即<code class="eh lm ln lo lp b">uint256[]</code>)表示。</p><p id="15ce" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">所有的<code class="eh lm ln lo lp b">memory</code>数组都有固定的大小——然而，动态数组也可以依赖于运行时参数。</p><p id="72e1" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">数组可以有任何类型的元素，包括映射或结构，尽管同样的类型限制适用于这些引用类型——映射只能存储在<code class="eh lm ln lo lp b">storage</code>数据位置。</p><p id="f33c" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">数组也可以是多维的。例如，<code class="eh lm ln lo lp b">uint[][5] memory x</code>将创建一个由5个动态数组<code class="eh lm ln lo lp b">uint</code>组成的<code class="eh lm ln lo lp b">memory</code>数组。与JS中一样，索引是从零开始的，访问方向与声明的方向相反，这意味着要访问<strong class="ji hu">第二个</strong>动态数组中的<strong class="ji hu">第三个</strong> <code class="eh lm ln lo lp b">uint</code>，需要使用<code class="eh lm ln lo lp b">x[1][2]</code>。</p><p id="f612" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">与其他状态变量类型一样，将状态数组指定为<code class="eh lm ln lo lp b">public</code>会自动在Solidity中创建一个getter。但是，在getter中还必须包含一个数字索引作为必需的参数(否则，将不知道“获取”哪个元素，因为不会返回整个数组，以避免高开销):</p><ul class=""><li id="49a7" class="lw lx ht ji b jj jk jn jo jr ly jv lz jz ma kd mb mc md me dt translated">因此，对于数组<code class="eh lm ln lo lp b">uint[] public x</code>，第三个元素将通过调用<code class="eh lm ln lo lp b">x(2)</code>来访问</li></ul><p id="c6d5" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">请注意，试图访问超过其长度的数组会导致断言失败。</p><h2 id="82d0" class="kl km ht bd kn ko kp kq kr ks kt ku kv jr kw kx ky jv kz la lb jz lc ld le lf dt translated">初始化数组</h2><p id="e44c" class="pw-post-body-paragraph jg jh ht ji b jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd hm dt translated"><strong class="ji hu">动态存储器阵列</strong>可以使用<code class="eh lm ln lo lp b">new</code>操作符进行初始化。然而，尽管是动态的，<code class="eh lm ln lo lp b">memory</code>数组不能<strong class="ji hu">也不能</strong>调整大小——需要的大小必须提前确定，或者完全复制到新的<code class="eh lm ln lo lp b">memory</code>数组中进行更新。新分配的数组总是用该类型的默认值初始化(即<code class="eh lm ln lo lp b">uint256</code>用<code class="eh lm ln lo lp b">0</code>):</p><figure class="lq lr ls lt fq iu"><div class="bz el l di"><div class="lu lv l"/></div></figure><p id="359f" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">要更新这些值，必须单独分配元素:</p><figure class="lq lr ls lt fq iu"><div class="bz el l di"><div class="lu lv l"/></div></figure><p id="a2bc" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu">静态大小(固定大小)的内存数组</strong>可以由数组文字初始化——一个或多个表达式的逗号分隔列表，形式为<code class="eh lm ln lo lp b">[…]</code>。数组文字被解释为静态大小的内存数组，其长度等于表达式的数量。数组的基本类型是列表中第一个表达式的类型，以便其他表达式可以隐式转换为它。否则抛出一个类型错误:<code class="eh lm ln lo lp b">Unable to deduce common type for array elements</code>。注意，列表<strong class="ji hu">中的一个元素必须</strong>显式地是该类型——只有一个所有元素都可以隐式转换的类型是不够的。</p><p id="c9c1" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">例如，下面是一个<code class="eh lm ln lo lp b">uint8[3] memory</code>，因为<code class="eh lm ln lo lp b">1</code>的类型是显式的<code class="eh lm ln lo lp b">uint8</code>，列表中剩余的值(<code class="eh lm ln lo lp b">2</code>、<code class="eh lm ln lo lp b">3</code>)可以隐式转换为<code class="eh lm ln lo lp b">uint8</code>。</p><p id="1e82" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><code class="eh lm ln lo lp b">[1, 2, 3]</code></p><p id="01f3" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">相反，要创建一个<code class="eh lm ln lo lp b">uint[3] memory</code>，其中一个元素必须显式转换为<code class="eh lm ln lo lp b">uint</code>:</p><figure class="lq lr ls lt fq iu"><div class="bz el l di"><div class="lu lv l"/></div></figure><p id="6928" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">以下是不允许的，因为<code class="eh lm ln lo lp b">bool</code>不能隐式转换为<code class="eh lm ln lo lp b">uint</code>。</p><figure class="lq lr ls lt fq iu"><div class="bz el l di"><div class="lu lv l"/></div></figure><p id="4727" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">固定大小的内存阵列也不能分配给动态大小的内存阵列:</p><figure class="lq lr ls lt fq iu"><div class="bz el l di"><div class="lu lv l"/></div></figure><h2 id="7ea3" class="kl km ht bd kn ko kp kq kr ks kt ku kv jr kw kx ky jv kz la lb jz lc ld le lf dt translated">数组成员</h2><p id="bf26" class="pw-post-body-paragraph jg jh ht ji b jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd hm dt translated">数组以类似于JavaScript的方式拥有成员，除了一些例外:</p><ul class=""><li id="a14d" class="lw lx ht ji b jj jk jn jo jr ly jv lz jz ma kd mb mc md me dt translated"><code class="eh lm ln lo lp b">length</code>:数组长度，适用于所有数组类型</li></ul><figure class="lq lr ls lt fq iu"><div class="bz el l di"><div class="lu lv l"/></div></figure><ul class=""><li id="49bf" class="lw lx ht ji b jj jk jn jo jr ly jv lz jz ma kd mb mc md me dt translated"><code class="eh lm ln lo lp b">push()</code>和<code class="eh lm ln lo lp b">push(x)</code>:两者都仅适用于存储阵列</li></ul><p id="f3b6" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">如果没有参数，它会在数组末尾追加一个初始化为零的元素，并返回对该元素的引用。</p><p id="d693" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">通过参数，它追加到数组的末尾，并且不返回任何内容。</p><figure class="lq lr ls lt fq iu"><div class="bz el l di"><div class="lu lv l"/></div></figure><ul class=""><li id="6e4c" class="lw lx ht ji b jj jk jn jo jr ly jv lz jz ma kd mb mc md me dt translated"><code class="eh lm ln lo lp b">pop()</code>:也仅适用于存储阵列。它在移除的元素上隐式调用一个<code class="eh lm ln lo lp b">delete</code>。与JS不同，它不返回那个元素。</li></ul><figure class="lq lr ls lt fq iu"><div class="bz el l di"><div class="lu lv l"/></div></figure><h2 id="238d" class="kl km ht bd kn ko kp kq kr ks kt ku kv jr kw kx ky jv kz la lb jz lc ld le lf dt translated">数组切片</h2><p id="6da2" class="pw-post-body-paragraph jg jh ht ji b jj lg jl jm jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd hm dt translated">使用<code class="eh lm ln lo lp b">x[start:end]</code>，数组的连接部分也可以作为片来访问。数组值将在<code class="eh lm ln lo lp b">x[start]</code>到<code class="eh lm ln lo lp b">x[end-1]</code>之间返回。索引必须是<code class="eh lm ln lo lp b">uint256</code>类型或者可以隐式转换成它。索引访问不是相对于底层数组，而是相对于切片的开始(并且只对动态<code class="eh lm ln lo lp b">calldata</code>数组可用)。</p><figure class="lq lr ls lt fq iu"><div class="bz el l di"><div class="lu lv l"/></div></figure><h2 id="aa78" class="kl km ht bd kn ko kp kq kr ks kt ku kv jr kw kx ky jv kz la lb jz lc ld le lf dt translated">其他阵列详细信息</h2><ul class=""><li id="293c" class="lw lx ht ji b jj lg jn lh jr nh jv ni jz nj kd mb mc md me dt translated">避免悬空引用:避免在数组中留下对已被删除或移动的存储项的引用，例如弹出元素。</li><li id="1725" class="lw lx ht ji b jj mf jn mg jr mh jv mi jz mj kd mb mc md me dt translated">bytes和string作为数组:都是特殊数组(<code class="eh lm ln lo lp b">bytes</code>类似于<code class="eh lm ln lo lp b">bytes1[]</code>，但在<code class="eh lm ln lo lp b">calldata</code>和<code class="eh lm ln lo lp b">memory</code>中打包得很紧)；<code class="eh lm ln lo lp b">string</code>等于<code class="eh lm ln lo lp b">bytes</code>，但不允许<code class="eh lm ln lo lp b">length</code>或索引访问。</li></ul><p id="b1b9" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">希望这给了Solidity数组一些好的见解，以及与JavaScript的一些关键区别。感谢阅读！</p><h2 id="bad7" class="kl km ht bd kn ko kp kq kr ks kt ku kv jr kw kx ky jv kz la lb jz lc ld le lf dt translated">参考资料:</h2><ul class=""><li id="84da" class="lw lx ht ji b jj lg jn lh jr nh jv ni jz nj kd mb mc md me dt translated"><a class="ae jf" href="https://docs.soliditylang.org/en/v0.8.15/types.html#arrays" rel="noopener ugc nofollow" target="_blank">https://docs.soliditylang.org/en/v0.8.15/types.html#arrays</a></li><li id="db76" class="lw lx ht ji b jj mf jn mg jr mh jv mi jz mj kd mb mc md me dt translated"><a class="ae jf" href="https://docs.soliditylang.org/en/v0.8.15/contracts.html#getter-functions" rel="noopener ugc nofollow" target="_blank">https://docs . soliditylang . org/en/v 0 . 8 . 15/contracts . html # getter-functions</a></li></ul></div></div>    
</body>
</html>