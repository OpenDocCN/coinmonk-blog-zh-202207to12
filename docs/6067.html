<html>
<head>
<title>Unpredictable randomness to NFT minting with Chainlink VRF</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不可预测的随机性NFT铸币与链环VRF</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/unpredictable-randomness-to-nft-minting-with-chainlink-vrf-v2-f6ecd43052cc?source=collection_archive---------9-----------------------#2022-11-08">https://medium.com/coinmonks/unpredictable-randomness-to-nft-minting-with-chainlink-vrf-v2-f6ecd43052cc?source=collection_archive---------9-----------------------#2022-11-08</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/15f1f4c654c892df9e0e71fc7848e3d0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*D2KRCUuO7xnICOpk"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">Photo by <a class="ae jf" href="https://unsplash.com/@guille_velard?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Guillermo Velarde</a> on <a class="ae jf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c608" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated"><strong class="ji hu"> <em class="ke">目录</em> </strong></p><ol class=""><li id="cbcf" class="kf kg ht ji b jj jk jn jo jr kh jv ki jz kj kd kk kl km kn dt translated"><strong class="ji hu">简介</strong></li><li id="fae3" class="kf kg ht ji b jj ko jn kp jr kq jv kr jz ks kd kk kl km kn dt translated"><strong class="ji hu">实现</strong> <br/> <em class="ke"> -从Chainlink中获取随机性<br/> -找到一个随机令牌Id <br/> -编写Mint函数</em></li><li id="05bf" class="kf kg ht ji b jj ko jn kp jr kq jv kr jz ks kd kk kl km kn dt translated"><strong class="ji hu">编写测试</strong> <br/> <em class="ke"> -模拟链环VRF <br/> -测试随机性请求&amp;接收周期<br/> -分段测试</em></li></ol><h1 id="9886" class="kt ku ht bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">介绍</h1><p id="588f" class="pw-post-body-paragraph jg jh ht ji b jj lr jl jm jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd hm dt translated">像以太坊和比特币这样的区块链是透明的、确定的。这意味着生成防篡改不可预测的随机性是一项颇具挑战性的任务。然而，在许多区块链应用程序中，它仍然是一个至关重要的方面，例如确定Dao中的治理角色、赠品、即玩即赚游戏、生成随机NFT特征、公平分配资产等等。</p><p id="a7e3" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">实现这一点的一个简单方法是使用一个全局可用的变量如<code class="eh lw lx ly lz b">block.difficulty</code>或<code class="eh lw lx ly lz b">block.timestamp</code>作为熵的来源来产生随机性。但是这种产生随机性的方式，如果你正在建造一些严肃的东西，从来都不是一个好主意。为什么？因为这些都可以被矿工操纵<a class="ae jf" href="https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620" rel="noopener ugc nofollow" target="_blank">。</a></p><p id="043c" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">因此，解决方案将是使用oracle网络，它可以在链外生成随机性，但在链上提供加密证明。而<a class="ae jf" href="https://blog.chain.link/chainlink-vrf-on-chain-verifiable-randomness/" rel="noopener ugc nofollow" target="_blank">链环VRF(可验证随机函数)</a>正是这么做的。因此，我想带您看一下NFT铸币合同中VRF的一个简单实现，以便在铸币商之间公平地分配稀有的NFT。大多数NFT艺术品项目通过离线计算生成NFT特征，并将NFT图像存储在像IPFS这样的分布式存储中。然而，这带来了铸币者狙击稀有NFT的风险，从而阻碍了代币的公平分配。因此，为了解决这个问题，我们可以编写一个智能合同，使铸币商能够使用VRF链获得一个随机的令牌ID。</p><blockquote class="ma"><p id="3600" class="mb mc ht bd md me mf mg mh mi mj kd ek translated">交易新手？在<a class="ae jf" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易</a>上尝试<a class="ae jf" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae jf" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div><div class="ab cl mk ml hb mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hm hn ho hp hq"><p id="deff" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我会用安全帽和打字稿写铸造合同和测试。此外，使用chainlink模拟测试智能契约。<a class="ae jf" href="https://github.com/Ak-prog-50/VRF_minting_contract" rel="noopener ugc nofollow" target="_blank">这里有一个链接</a>指向包含合同、测试和部署脚本的GitHub存储库。</p><h1 id="7c1c" class="kt ku ht bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">履行</h1><h2 id="bc4f" class="mr ku ht bd kv ms mt mu kz mv mw mx ld jr my mz lh jv na nb ll jz nc nd lp ne dt translated">从chainlink获取随机性</h2><p id="e5d6" class="pw-post-body-paragraph jg jh ht ji b jj lr jl jm jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd hm dt translated">创建随机令牌Id首先需要来自chainlink的随机值。那么，让我们快速看一下如何做到这一点。有两个契约对获得随机性很重要。第一个是<code class="eh lw lx ly lz b"><a class="ae jf" href="https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/VRFCoordinatorV2.sol" rel="noopener ugc nofollow" target="_blank">VRFCoordinatorV2</a></code>。顾名思义，这个契约负责协调整个请求和接收随机性的过程。点击可阅读更多关于请求和接收数据周期<a class="ae jf" href="https://docs.chain.link/docs/vrf/v2/subscription/#request-and-receive-data" rel="noopener ugc nofollow" target="_blank">的信息。而另一个是<code class="eh lw lx ly lz b"><a class="ae jf" href="https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/VRFConsumerBaseV2.sol" rel="noopener ugc nofollow" target="_blank">VRFConsumerBaseV2.sol</a></code>。要从chainlink请求一个随机值，你的契约(消耗随机性的契约)必须继承这个契约并实现<code class="eh lw lx ly lz b"><a class="ae jf" href="https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/VRFConsumerBaseV2.sol#L122" rel="noopener ugc nofollow" target="_blank">fulfillRandomWords</a></code>函数。VRFConsumerBaseV2的构造函数将vrfCoordinator地址作为参数。你可以在这里</a>找到支持的网络和VRFCoordinator地址<a class="ae jf" href="https://docs.chain.link/docs/vrf/v2/subscription/supported-networks/#configurations" rel="noopener ugc nofollow" target="_blank">。</a></p><figure class="nf ng nh ni fq iu"><div class="bz el l di"><div class="nj nk l"/></div></figure><p id="7e4a" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">这里，我实现了VRFConsumerBaseV2中定义的<code class="eh lw lx ly lz b">fulfillRandomWords</code>函数。这是VRF回调函数，当随机性请求得到满足时调用。这只能由消费者合同中预定义的<code class="eh lw lx ly lz b">VRFCoordinatorV2</code>合同调用。如这里的<a class="ae jf" href="https://github.com/smartcontractkit/chainlink/blob/acdbe197438553b2c5effdf6b4f5ab6d8a0f09e8/contracts/src/v0.8/VRFConsumerBaseV2.sol#L129" rel="noopener ugc nofollow" target="_blank">所示</a>，如果任何其他契约试图调用它，它会返回<code class="eh lw lx ly lz b">OnlyCoordinatorCanFulfill</code>错误。</p><p id="b2ce" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">要发送随机性请求，消费者契约应该使用下面的参数调用<code class="eh lw lx ly lz b">VRFCoordinatorV2</code>中的<code class="eh lw lx ly lz b"><a class="ae jf" href="https://github.com/smartcontractkit/chainlink/blob/acdbe197438553b2c5effdf6b4f5ab6d8a0f09e8/contracts/src/v0.8/VRFCoordinatorV2.sol#L370" rel="noopener ugc nofollow" target="_blank">reqeustRandomWords</a></code>函数。</p><figure class="nf ng nh ni fq iu"><div class="bz el l di"><div class="nj nk l"/></div></figure><ul class=""><li id="941c" class="kf kg ht ji b jj jk jn jo jr kh jv ki jz kj kd nl kl km kn dt translated"><strong class="ji hu"> keyHash </strong>:用于表示随机性请求的气价限制。在这里找到可用的密钥散列<a class="ae jf" href="https://docs.chain.link/docs/vrf/v2/subscription/supported-networks/#configurations" rel="noopener ugc nofollow" target="_blank"/>。</li><li id="abe5" class="kf kg ht ji b jj ko jn kp jr kq jv kr jz ks kd nl kl km kn dt translated"><strong class="ji hu"> subscriptionId </strong>:您需要<a class="ae jf" href="https://docs.chain.link/docs/vrf/v2/subscription/examples/get-a-random-number/#create-and-fund-a-subscription" rel="noopener ugc nofollow" target="_blank">创建一个订阅，并用一些testnet链接令牌为其提供资金</a>，以获得一个订阅Id。</li><li id="7e03" class="kf kg ht ji b jj ko jn kp jr kq jv kr jz ks kd nl kl km kn dt translated"><strong class="ji hu">request confirmations</strong>:VRF服务将等待响应的阻塞确认的数量。最大和最小确认可在找到<a class="ae jf" href="https://docs.chain.link/docs/vrf/v2/subscription/supported-networks/#configurations" rel="noopener ugc nofollow" target="_blank">。</a></li><li id="d025" class="kf kg ht ji b jj ko jn kp jr kq jv kr jz ks kd nl kl km kn dt translated"><strong class="ji hu">callbackGasLimit</strong>:vrf coordinator契约在调用vrfConsumerBaseV2契约中的回调函数(<code class="eh lw lx ly lz b">rawFulfillRandomWords</code>)时，会使用这个量的气体。(<em class="ke">见</em>T1)</li></ul><pre class="nf ng nh ni fq nm lz nn no aw np dt"><span id="1f91" class="mr ku ht lz b fv nq nr l ns nt"><a class="ae jf" href="https://github.com/smartcontractkit/chainlink/blob/acdbe197438553b2c5effdf6b4f5ab6d8a0f09e8/contracts/src/v0.8/VRFCoordinatorV2.sol#L567" rel="noopener ugc nofollow" target="_blank"><em class="ke">VRFCoordinatorV2.sol#L567</em></a><em class="ke"><br/></em><strong class="lz hu">bytes memory resp =     abi.encodeWithSelector(v.rawFulfillRandomWords.<em class="ke">selector</em>, requestId, randomWords)</strong></span><span id="8f0d" class="mr ku ht lz b fv nu nr l ns nt"><a class="ae jf" href="https://github.com/smartcontractkit/chainlink/blob/acdbe197438553b2c5effdf6b4f5ab6d8a0f09e8/contracts/src/v0.8/VRFCoordinatorV2.sol#L575" rel="noopener ugc nofollow" target="_blank">VRFCoordinatorV2.sol#L575</a><br/><strong class="lz hu">bool success = callWithExactGas(rc.callbackGasLimit, rc.sender,resp);</strong></span></pre><ul class=""><li id="8ae2" class="kf kg ht ji b jj jk jn jo jr kh jv ki jz kj kd nl kl km kn dt translated"><strong class="ji hu"> numWords: </strong>要请求的随机数的个数。最大值可以在<a class="ae jf" href="https://docs.chain.link/docs/vrf/v2/subscription/supported-networks/#configurations" rel="noopener ugc nofollow" target="_blank">这里</a>找到。</li></ul><p id="8674" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">您还可以指示基金链接令牌来请求随机性，而不是管理订阅。你可以在这里阅读更多相关信息<a class="ae jf" href="https://docs.chain.link/docs/vrf/v2/introduction/#two-methods-to-request-randomness" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="3822" class="mr ku ht bd kv ms mt mu kz mv mw mx ld jr my mz lh jv na nb ll jz nc nd lp ne dt translated">查找随机令牌Id</h2><p id="0663" class="pw-post-body-paragraph jg jh ht ji b jj lr jl jm jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd hm dt translated">我们从chainlink得到的随机数是一个32字节的整数。此特定合约的最大令牌供应量为3333。起始令牌索引为0。因此，要获得一个随机令牌id，我们可以将32字节的随机整数除以3333，然后得到余数。<code class="eh lw lx ly lz b">uint16 randomId = randomInt % 3333</code></p><p id="e05b" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">因此，为了避免随机令牌id之间的冲突，我们需要检查该id是否已经被铸造。</p><figure class="nf ng nh ni fq iu"><div class="bz el l di"><div class="nj nk l"/></div></figure><p id="1180" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">上面的函数将获得一个随机的令牌id，如果id已经生成，它将寻找下一个可用的令牌Id。您可以看到，我添加了一个require语句来检查随机性请求是否已经完成。这里看一下代码<a class="ae jf" href="https://github.com/Ak-prog-50/VRF_minting_contract/blob/main/contracts/VRFMinting.sol" rel="noopener ugc nofollow" target="_blank">。</a></p><h2 id="5f4e" class="mr ku ht bd kv ms mt mu kz mv mw mx ld jr my mz lh jv na nb ll jz nc nd lp ne dt translated">编写Mint函数</h2><figure class="nf ng nh ni fq iu"><div class="bz el l di"><div class="nj nk l"/></div></figure><p id="17d0" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">我在这里使用了OpenZeppelin的ERC721可枚举扩展。<code class="eh lw lx ly lz b"><a class="ae jf" href="https://docs.openzeppelin.com/contracts/2.x/api/token/erc721#ERC721-_safeMint-address-uint256-" rel="noopener ugc nofollow" target="_blank">_safeMint</a></code> <a class="ae jf" href="https://docs.openzeppelin.com/contracts/2.x/api/token/erc721#ERC721-_safeMint-address-uint256-" rel="noopener ugc nofollow" target="_blank">函数</a>有两个参数。NFT应该转移到的地址和令牌id。如您所见，现在剩下要做的就是将生成的随机令牌id传递给mint函数。</p><h1 id="dc4e" class="kt ku ht bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">写作测试</h1><h2 id="ccba" class="mr ku ht bd kv ms mt mu kz mv mw mx ld jr my mz lh jv na nb ll jz nc nd lp ne dt translated">模拟链节VRFCoordinatorV2</h2><p id="372b" class="pw-post-body-paragraph jg jh ht ji b jj lr jl jm jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd hm dt translated">正如我之前所说的，所有的随机性请求都由VRFCoordinator契约来协调。以太坊主网和测试网上已经部署了协调器合同。但是我想在一个孤立的本地环境中测试整个过程。所以我在chainlink GitHub repo中部署了<a class="ae jf" href="https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/mocks/VRFCoordinatorV2Mock.sol" rel="noopener ugc nofollow" target="_blank">这个</a>模拟契约来模拟协调器。</p><figure class="nf ng nh ni fq iu"><div class="bz el l di"><div class="nj nk l"/></div></figure><p id="1392" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">您可以在这里找到使用hardhat-deploy插件<a class="ae jf" href="https://github.com/Ak-prog-50/VRF_minting_contract/tree/main/deploy" rel="noopener ugc nofollow" target="_blank">编写的部署脚本。这些脚本还在模拟测试中处理VRF订阅的创建和融资。</a></p><p id="8054" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">模拟契约使用从<code class="eh lw lx ly lz b"><a class="ae jf" href="https://github.com/smartcontractkit/chainlink/blob/008d93b87840958d96483147000237563593c04e/contracts/src/v0.8/VRFCoordinatorV2.sol#L370" rel="noopener ugc nofollow" target="_blank">requestRandomWords </a></code>函数返回的request-id作为种子来生成一个假随机数。</p><pre class="nf ng nh ni fq nm lz nn no aw np dt"><span id="847c" class="mr ku ht lz b fv nq nr l ns nt"><a class="ae jf" href="https://github.com/smartcontractkit/chainlink/blob/008d93b87840958d96483147000237563593c04e/contracts/src/v0.8/mocks/VRFCoordinatorV2Mock.sol#L113" rel="noopener ugc nofollow" target="_blank"><em class="ke">VRFCoordinatorV2Mock.sol#L113</em></a></span><span id="0ae8" class="mr ku ht lz b fv nu nr l ns nt"><strong class="lz hu">for (uint256 i = 0; i &lt; req.numWords; i++) <br/>{</strong><br/>   <strong class="lz hu">_words[i] = uint256(keccak256(abi.encode(_requestId, i)))</strong>;<br/><strong class="lz hu">}</strong></span></pre><p id="9c29" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">为了模仿协调器的行为，我们必须在测试脚本中调用<code class="eh lw lx ly lz b">fulfillRandomWords</code>函数。</p><h2 id="d5aa" class="mr ku ht bd kv ms mt mu kz mv mw mx ld jr my mz lh jv na nb ll jz nc nd lp ne dt translated">测试随机性请求和接收周期</h2><figure class="nf ng nh ni fq iu"><div class="bz el l di"><div class="nj nk l"/></div></figure><p id="8cb2" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">在这里，我测试了在随机性请求和响应循环中是否返回了预期的结果。你可以在Github repo中找到这个和其他测试合同。</p><h2 id="99d5" class="mr ku ht bd kv ms mt mu kz mv mw mx ld jr my mz lh jv na nb ll jz nc nd lp ne dt translated">阶段测试</h2><p id="bf9d" class="pw-post-body-paragraph jg jh ht ji b jj lr jl jm jn ls jp jq jr lt jt ju jv lu jx jy jz lv kb kc kd hm dt translated">在Goerli等测试网络中进行测试时，请使用以下测试模块，而不是本地主机。</p><figure class="nf ng nh ni fq iu"><div class="bz el l di"><div class="nj nk l"/></div></figure><p id="3ded" class="pw-post-body-paragraph jg jh ht ji b jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd hm dt translated">当在像Goerli这样的testnet中进行测试时，我们不知道随机性要求何时会得到满足。所以我们不能期望我们的契约像在本地环境中一样立即发出<code class="eh lw lx ly lz b">RandomnessRequestFulfilled</code>事件。因此，我创建了一个承诺，当事件被发出并且预期的结果被返回时，我将解决这个问题。</p><blockquote class="ma"><p id="e05e" class="mb mc ht bd md me mf mg mh mi mj kd ek translated">加入Coinmonks <a class="ae jf" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae jf" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>了解加密交易和投资</p></blockquote><h1 id="4634" class="kt ku ht bd kv kw kx ky kz la lb lc ld le nv lg lh li nw lk ll lm nx lo lp lq dt translated">另外，阅读</h1><ul class=""><li id="c569" class="kf kg ht ji b jj lr jn ls jr ny jv nz jz oa kd nl kl km kn dt translated"><a class="ae jf" rel="noopener" href="/coinmonks/buy-bitcoin-in-india-feb50ddfef94">如何在印度购买比特币？</a> | <a class="ae jf" rel="noopener" href="/coinmonks/wazirx-review-5c811b074f5b"> WazirX审核</a></li><li id="a648" class="kf kg ht ji b jj ko jn kp jr kq jv kr jz ks kd nl kl km kn dt translated"><a class="ae jf" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a> | <a class="ae jf" href="https://coincodecap.com/probit-review" rel="noopener ugc nofollow" target="_blank"> Probit审查</a></li><li id="eb26" class="kf kg ht ji b jj ko jn kp jr kq jv kr jz ks kd nl kl km kn dt translated"><a class="ae jf" rel="noopener" href="/coinmonks/cryptohopper-alternatives-d67287b16d27"> CryptoHopper替代品</a> | <a class="ae jf" rel="noopener" href="/coinmonks/hitbtc-review-c5143c5d53c2"> HitBTC审查</a></li><li id="7e04" class="kf kg ht ji b jj ko jn kp jr kq jv kr jz ks kd nl kl km kn dt translated"><a class="ae jf" href="https://coincodecap.com/cbet-casino-review" rel="noopener ugc nofollow" target="_blank"> CBET评论</a> | <a class="ae jf" href="https://coincodecap.com/kucoin-vs-coinbase" rel="noopener ugc nofollow" target="_blank">库科恩vs比特币基地</a></li><li id="002b" class="kf kg ht ji b jj ko jn kp jr kq jv kr jz ks kd nl kl km kn dt translated"><a class="ae jf" href="https://coincodecap.com/fold-app-review" rel="noopener ugc nofollow" target="_blank">折App回顾</a> | <a class="ae jf" rel="noopener" href="/coinmonks/kucoin-trading-bot-automate-your-trades-8cf0ca2138e0">库币交易机器人</a></li></ul></div></div>    
</body>
</html>