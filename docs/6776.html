<html>
<head>
<title>Establishing an order of transactions in blockchain</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在区块链建立交易秩序</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/establishing-an-order-of-transactions-in-blockchain-66488e6e5980?source=collection_archive---------14-----------------------#2022-11-26">https://medium.com/coinmonks/establishing-an-order-of-transactions-in-blockchain-66488e6e5980?source=collection_archive---------14-----------------------#2022-11-26</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><h2 id="42a5" class="hr hs ht bd b gc hu hv hw hx hy hz ek ia translated" aria-label="kicker paragraph">区块链</h2><div class=""/><figure class="fi fk ja jb jc jd fe ff paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="fe ff iz"><img src="../Images/8ee430b9de091212b668774217373f32.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-onKzJHtY6tBJ_Sm.jpeg"/></div></div></figure><p id="0584" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">在上一篇文章中，我们详细了解了我们如何验证交易。在本文中，我们将研究为什么事务的顺序很重要，以及我们如何建立一个顺序。</p><p id="e34f" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">正如我们前面看到的，区块链系统中的每一方都可以有自己的分类帐。这有助于我们创建一个分散的货币体系。因此，一旦我签署并公布了我的交易，区块链网络中的每一方都可以验证我的交易。然后，他们可以将其添加到他们的分类帐中。</p><h1 id="c2e1" class="kj kk ht bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">订单的需求</h1><p id="6c08" class="pw-post-body-paragraph jk jl ht jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh hm dt translated">然而，事情并没有那么简单。每秒钟可能有成千上万的交易。并且网络中的每一方都必须验证所有这些交易，并将它们添加到他们的分类帐中。当有成千上万笔交易时，每一方都可以以不同的顺序将交易添加到他们的分类账中。</p><p id="fff0" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">例如，让我们考虑一下我们在前几篇文章中使用的书店例子。假设我在向书店汇款后不久，使用我发送给书店的相同比特币，在一家餐馆发起了另一笔交易。现在，网络中有我的两个未验证的交易。如果书店对自己的交易进行验证并首先将其添加到分类账中，那么它将拒绝餐馆的交易，因为我输入到后一笔交易中的比特币与我输入到前一笔交易中的相同。但这对我们来说不是问题。对我们来说重要的是书店已经接受了我们的交易。</p><p id="2b36" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">如果餐馆也向书店核实交易并首先将其添加到其分类帐中，那么它将拒绝餐馆的交易。所以，我们不会得到我们从餐馆订购的东西。然而，如果餐馆首先向餐馆核实交易，然后向书店拒绝交易，那么我们就走运了！我们会用同样的钱买两件东西，换句话说，我们会有双重花费。</p><p id="cec8" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">这显示了我们将交易添加到分类账的顺序。因此，我们应该让所有的分类账在交易顺序上达成一致。用一个更专业的术语来说，我们应该在所有账本之间建立一个<a class="ae ki" href="https://en.wikipedia.org/wiki/Consensus_(computer_science)" rel="noopener ugc nofollow" target="_blank">共识</a>。</p><blockquote class="lm"><p id="38ab" class="ln lo ht bd lp lq lr ls lt lu lv kh ek translated">交易新手？在<a class="ae ki" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易</a>上尝试<a class="ae ki" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae ki" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote><h1 id="a039" class="kj kk ht bd kl km kn ko kp kq kr ks kt ku lw kw kx ky lx la lb lc ly le lf lg dt translated">对交易进行编号以建立订单</h1><p id="ed2c" class="pw-post-body-paragraph jk jl ht jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh hm dt translated">我们可以对每笔交易进行编号，以创建特定的订单。让我们假设已经有70个交易。因此，我们将书店和餐馆的交易编号为71，因为你从分类账的最后一笔交易开始继续编号。</p><p id="9636" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">现在，当区块链网络中的节点接收到这两个事务时，它们会知道这两个事务跟在最后一个被验证的事务之后。因此，节点不会拒绝第二个事务，而是知道出现了混淆，并等待混淆的解决。我们将在以后看到如何解决这个困惑。</p><p id="1df9" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">当我们拒绝任何一个交易时，我们最终会有两个分支。让我们假设之前的70笔交易没有遇到任何问题。因此，有一系列的交易是按照它们的编号顺序进行的。现在，当两个编号为71的事务到达时，我们将它们附加到第70个事务，创建一个分支。</p><h1 id="7144" class="kj kk ht bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">为什么编号不是一个好主意</h1><p id="f29b" class="pw-post-body-paragraph jk jl ht jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh hm dt translated">但是，如果同时有另外一对交易呢？交易节点将知道最后的交易号是71，并且它们将对随后的交易进行编号72。但是有两笔交易的号码是71。那么，我们应该将这些新事务附加到哪个事务上呢？或者换句话说，接下来的交易应该选择哪个分支？</p><p id="7445" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">正如我们前面看到的，事务的输入是以前事务的输出。假设编号为72的事务之一是由餐馆发起的，它使用我的事务的输出作为输入。我在餐馆的交易编号是71。因此，编号为72的交易实际上是跟随编号为71的交易到餐馆。</p><p id="6c5a" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">实际上，这可能永远不会发生，我们稍后再来看原因。所以，在播放编号为72的交易时，应该将它附加到编号为71的从我到餐厅的交易中。但是有两笔交易的号码是71。因此，编号不能帮助我们唯一地识别我与餐馆的交易。</p><p id="22ec" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">尽管如此，我们可以通过查看事务的内容来确定最新的事务应该附加到哪个正确的事务。通过检查最新事务的输入部分，节点可以确定它应该附加到从我到餐馆的事务中。</p><h1 id="f272" class="kj kk ht bd kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg dt translated">使用哈希排序</h1><p id="f2ba" class="pw-post-body-paragraph jk jl ht jm b jn lh jp jq jr li jt ju jv lj jx jy jz lk kb kc kd ll kf kg kh hm dt translated">然而，我们可以让它变得更简单。如果事务实际上携带了它们所遵循的事务的信息，那该怎么办呢？如果餐厅编号为72的事务表示它是从我的事务到它的后续事务，该怎么办？然后，节点不需要浪费时间读取新事务的输入和以前事务的输出。但是我们如何唯一地标识一个事务呢？</p><p id="016b" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated"><a class="ae ki" href="https://www.thearmchaircritic.org/mansplainings/hashing-asymmetric-encryption-and-digital-signatures" rel="noopener ugc nofollow" target="_blank">还记得哈希</a>？如果我们散列我们的事务并使用散列作为ID会怎么样？每个事务都是唯一的，即使输入数据有微小的变化，生成的散列也会完全不同。因此，我们可以安全地使用散列来引用事务。现在，我们可以将先前事务的散列添加到新事务中，并创建新事务的散列。这样我们可以确保交易的秩序得到维护。</p><p id="cd8b" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">让我们回到我们的例子，看看这将如何工作。当餐馆想要使用我的交易输出到餐馆来启动交易时，它将简单地包括我的交易的散列。因此，接收事务的节点将知道该事务应该附加到我的餐馆事务中。</p><p id="6e42" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">现在，我们有办法创建一个事务链，确保所有节点以相同的顺序添加广播事务。在下一篇文章中，让我们看看如何解决这个困惑。</p></div><div class="ab cl lz ma hb mb" role="separator"><span class="mc bw bk md me mf"/><span class="mc bw bk md me mf"/><span class="mc bw bk md me"/></div><div class="hm hn ho hp hq"><p id="f090" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated"><em class="mg">原载于2022年11月26日</em><a class="ae ki" href="https://www.thearmchaircritic.org/mansplainings/establishing-an-order-of-transactions-in-blockchain" rel="noopener ugc nofollow" target="_blank"><em class="mg">【https://www.thearmchaircritic.org】</em></a><em class="mg">。</em></p></div></div>    
</body>
</html>