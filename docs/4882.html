<html>
<head>
<title>Proof of Life: Zero-Knowledge-Proof Implementation of Conway’s Game of Life with Circom and Solidity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">生命的证明:康威“循环而可靠的生命游戏”的零知识证明实现</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/proof-of-life-zero-knowledge-proof-implementation-of-conways-game-of-life-with-circom-and-6438521fb2b1?source=collection_archive---------5-----------------------#2022-10-12">https://medium.com/coinmonks/proof-of-life-zero-knowledge-proof-implementation-of-conways-game-of-life-with-circom-and-6438521fb2b1?source=collection_archive---------5-----------------------#2022-10-12</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div class="fe ff iq"><img src="../Images/8f088fc499199879f9a6e77d61b64216.png" data-original-src="https://miro.medium.com/v2/resize:fit:1362/format:webp/1*3IMHgZVO1oTRZrBlRJPxXQ.png"/></div></figure><p id="cc99" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">最近，关于ZKP的潜力——密码学中的零知识证明的讨论越来越多。紧跟潮流，我决定学习circom，并尝试将康威的生命游戏作为zkSNARK电路来实现，并在NFT智能合约中使用该电路。</p><p id="fbcd" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">在这篇文章中，我将简要介绍正在使用的技术，展示我的电路，并解释其工作原理。</p><p id="2fde" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">你可以在这里查看代码:<a class="ae jv" href="https://github.com/rubydusa/proof-of-life" rel="noopener ugc nofollow" target="_blank">https://github.com/rubydusa/proof-of-life</a></p><h1 id="0c19" class="jw jx ht bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">ZKP、zkSNARK和Circom简介</h1><p id="a2cf" class="pw-post-body-paragraph ix iy ht iz b ja ku jc jd je kv jg jh ji kw jk jl jm kx jo jp jq ky js jt ju hm dt translated">就本文的目的而言，零知识证明意味着一段数据支持一组约束的数学证明，而不揭示那段数据是什么，也不揭示关于它的任何其他东西。</p><p id="c025" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">zkSNARK — <em class="kz">零知识简洁的非交互式知识论证</em>是一种零知识证明，它只需要证明者和验证者之间的一次交互，并且是简短的。</p><p id="312e" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">Circom是一种编程语言，用于编写程序(称为电路)，这些程序接受一组输入，并描述关于它们的<em class="kz">约束</em>，以及有一个、多个或没有输出。</p><p id="a24a" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">使用这些约束，您可以生成<em class="kz">证明</em>，您知道一组支持约束的输入并验证证明。</p><h1 id="5690" class="jw jx ht bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">正在建造什么？</h1><p id="de94" class="pw-post-body-paragraph ix iy ht iz b ja ku jc jd je kv jg jh ji kw jk jl jm kx jo jp jq ky js jt ju hm dt translated">在这篇文章中，我将展示一个NFT契约，每当有人提供证据证明他们有以下问题的解决方案时，它就铸造一个令牌:</p><p id="12bf" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">找到一个生活游戏的网格状态，使得在N次迭代之后，网格状态匹配某个预定义的状态:</p><figure class="lb lc ld le fq iu fe ff paragraph-image"><div class="fe ff la"><img src="../Images/c28d37785c0d36a38809edc38a13e91c.png" data-original-src="https://miro.medium.com/v2/resize:fit:884/format:webp/1*94zBJJMI2uJICPPQgC2cMA.png"/></div></figure><p id="86b6" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">对于生命的有限网格状态，我将使用包装变量:</p><figure class="lb lc ld le fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="fe ff lf"><img src="../Images/ac1ef474a4d517bcae86a7903263d5e9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qwlr4Q3OJ8JYUQysn1zI2A.png"/></div></div></figure><p id="1d03" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">为了澄清，每当我说“解决方案”时，我指的是适用于上述问题的网格状态。</p><p id="7bb3" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">不允许重复的解决方案。</p><p id="6d46" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">ZKPs允许我们在提交后保持解决方案的私密性，防止抢跑，并创建这类大型谜题。</p></div><div class="ab cl lk ll hb lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="hm hn ho hp hq"><h1 id="0e49" class="jw jx ht bd jy jz lr kb kc kd ls kf kg kh lt kj kk kl lu kn ko kp lv kr ks kt dt translated">细节</h1><p id="b08f" class="pw-post-body-paragraph ix iy ht iz b ja ku jc jd je kv jg jh ji kw jk jl jm kx jo jp jq ky js jt ju hm dt translated">本节将涵盖实施细节并解释项目的体系结构:</p><figure class="lb lc ld le fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="fe ff lf"><img src="../Images/42bc679a5bae0de63221e2d6880f6980.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lRrQXKoTiCEFbupQ32jgbA.png"/></div></div></figure><h2 id="6a71" class="lw jx ht bd jy lx ly lz kc ma mb mc kg ji md me kk jm mf mg ko jq mh mi ks mj dt translated">该电路</h2><p id="1fd0" class="pw-post-body-paragraph ix iy ht iz b ja ku jc jd je kv jg jh ji kw jk jl jm kx jo jp jq ky js jt ju hm dt translated">电路参数化为N——迭代次数，W——网格宽度，H——网格高度。</p><p id="f670" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">它有三个输出:</p><ul class=""><li id="7069" class="mk ml ht iz b ja jb je jf ji mm jm mn jq mo ju mp mq mr ms dt translated">out-N次迭代后网格的状态</li><li id="d500" class="mk ml ht iz b ja mt je mu ji mv jm mw jq mx ju mp mq mr ms dt translated">solution hash—“out”的哈希，这是必需的，以便合同可以验证它不是重复的解决方案</li><li id="a939" class="mk ml ht iz b ja mt je mu ji mv jm mw jq mx ju mp mq mr ms dt translated">hash——“address”与“solutionHash”的散列，这是防止前端运行所必需的(稍后将详细介绍)</li></ul><p id="18c1" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">和两个输入:</p><ul class=""><li id="41d0" class="mk ml ht iz b ja jb je jf ji mm jm mn jq mo ju mp mq mr ms dt translated">地址(公共)—证明者的地址</li><li id="8a1e" class="mk ml ht iz b ja mt je mu ji mv jm mw jq mx ju mp mq mr ms dt translated">数据(私有)—解决“出”的方法</li></ul><p id="ae03" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">网格状态表示为一个* 254位数，并分解为一个W×H位矩阵。然后，应用寿命算法N次，并且输出被约束为无论结果如何。</p><figure class="lb lc ld le fq iu fe ff paragraph-image"><div class="fe ff my"><img src="../Images/eb2496223ccc6a932a2e5b7e7c1c7c9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:842/format:webp/1*GVrT36UpmTY3wSz8u93daA.png"/></div></figure><p id="4e17" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">*在实际电路中，通过将254位数字序列的位拼接在一起，它被扩展为支持具有超过254个单元的网格</p><h2 id="b2af" class="lw jx ht bd jy lx ly lz kc ma mb mc kg ji md me kk jm mf mg ko jq mh mi ks mj dt translated">验证者合同</h2><p id="3cbf" class="pw-post-body-paragraph ix iy ht iz b ja ku jc jd je kv jg jh ji kw jk jl jm kx jo jp jq ky js jt ju hm dt translated">为了在线验证证明，我们需要将电路编译成可靠的合同模板。这些契约有一个单一的公共函数，它将证明数据作为输入，并返回一个布尔值来指示证明是否有效。</p><p id="1b80" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">对于groth16协议，函数签名如下所示:</p><pre class="lb lc ld le fq mz na nb nc aw nd dt"><span id="3828" class="lw jx ht na b fv ne nf l ng nh">function verifyProof( <br/>    uint[2] memory a,</span><span id="1b58" class="lw jx ht na b fv ni nf l ng nh">    uint[2][2] memory b,</span><span id="c04f" class="lw jx ht na b fv ni nf l ng nh">    uint[2] memory c,</span><span id="5784" class="lw jx ht na b fv ni nf l ng nh">    uint[4] memory input</span><span id="a461" class="lw jx ht na b fv ni nf l ng nh">) public view returns (bool r)</span></pre><p id="fa38" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">由于我不是密码学家，我无法解释a、b和c的细节——请将它们视为证明的“私人部分”,输入参数由电路的公共输入和输出组成。</p><p id="08f7" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">注意，输出也是验证输入的一部分，因为契约只负责验证一个证明，而不是计算它。</p><h2 id="9b77" class="lw jx ht bd jy lx ly lz kc ma mb mc kg ji md me kk jm mf mg ko jq mh mi ks mj dt translated">NFT合同</h2><p id="fc3d" class="pw-post-body-paragraph ix iy ht iz b ja ku jc jd je kv jg jh ji kw jk jl jm kx jo jp jq ky js jt ju hm dt translated">NFT合同继承了ERC721Enumerable，并具有以下附加存储变量:</p><pre class="lb lc ld le fq mz na nb nc aw nd dt"><span id="ac11" class="lw jx ht na b fv ne nf l ng nh">uint256 public prizenum;</span><span id="0a02" class="lw jx ht na b fv ni nf l ng nh">mapping(uint256 =&gt; bool) public proofs;</span><span id="cdc1" class="lw jx ht na b fv ni nf l ng nh">IGroth16Verifier public verifier;</span></pre><ul class=""><li id="d20a" class="mk ml ht iz b ja jb je jf ji mm jm mn jq mo ju mp mq mr ms dt translated">prize num——受欢迎的网格状态</li><li id="c138" class="mk ml ht iz b ja mt je mu ji mv jm mw jq mx ju mp mq mr ms dt translated">证明—跟踪已提交解决方案的映射</li><li id="6f44" class="mk ml ht iz b ja mt je mu ji mv jm mw jq mx ju mp mq mr ms dt translated">验证者—验证者合同的地址</li></ul><p id="085b" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">它还添加了一个外部函数“mint ”,当提供一个唯一的证明时，该函数铸造一个令牌:</p><pre class="lb lc ld le fq mz na nb nc aw nd dt"><span id="b557" class="lw jx ht na b fv ne nf l ng nh">function mint(</span><span id="ba26" class="lw jx ht na b fv ni nf l ng nh">uint256 solutionHash,</span><span id="1201" class="lw jx ht na b fv ni nf l ng nh">uint256 hash,</span><span id="7097" class="lw jx ht na b fv ni nf l ng nh">uint256[2] memory a,</span><span id="2580" class="lw jx ht na b fv ni nf l ng nh">uint256[2][2] memory b,</span><span id="117a" class="lw jx ht na b fv ni nf l ng nh">uint256[2] memory c</span><span id="4f3a" class="lw jx ht na b fv ni nf l ng nh">) external {</span><span id="bf71" class="lw jx ht na b fv ni nf l ng nh">require(!proofs[solutionHash], "GOLNFT: Solution already exists!");</span><span id="a8bd" class="lw jx ht na b fv ni nf l ng nh">require(verifier.verifyProof(a, b, c, [</span><span id="5968" class="lw jx ht na b fv ni nf l ng nh">solutionHash,</span><span id="8070" class="lw jx ht na b fv ni nf l ng nh">hash,</span><span id="0613" class="lw jx ht na b fv ni nf l ng nh">prizenum,</span><span id="f1a2" class="lw jx ht na b fv ni nf l ng nh">uint256(uint160(msg.sender))</span><span id="faf0" class="lw jx ht na b fv ni nf l ng nh">]), "GOLNFT: Invalid proof");</span><span id="bb4b" class="lw jx ht na b fv ni nf l ng nh">_safeMint(msg.sender, totalSupply());</span><span id="402f" class="lw jx ht na b fv ni nf l ng nh">proofs[solutionHash] = true;</span><span id="b8bf" class="lw jx ht na b fv ni nf l ng nh">}</span></pre><h1 id="760e" class="jw jx ht bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">零知识证明如何防止抢跑？</h1><p id="6ac8" class="pw-post-body-paragraph ix iy ht iz b ja ku jc jd je kv jg jh ji kw jk jl jm kx jo jp jq ky js jt ju hm dt translated">如果我们不在乎保持解决方案的私密性，我们可以简单地模拟在solidity smart契约中执行生命，这样负担会小得多。</p><p id="e356" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">那么为什么首先要使用ZKPs呢？</p><p id="f9f9" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">上述方法的问题在于，恶意行为者可能会通过监听广播事务来窃取谜题的解决方案。一个恶意的参与者将简单地复制呼叫数据，提交一个具有更高汽油费的交易并获得回报:</p><figure class="lb lc ld le fq iu fe ff paragraph-image"><div class="fe ff nj"><img src="../Images/9a5f998aadd81ccfa6d90ef5cc15c225.png" data-original-src="https://miro.medium.com/v2/resize:fit:782/format:webp/1*vF4p2ZVg4vFEAL8hnFJWFw.png"/></div></figure><p id="f59e" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">一种散列承诺方案更好，其中用户在提交解决方案之前承诺一个散列，并且如果他未能在某个时间框架内提交解决方案则受到惩罚，但是该方案有重大缺陷:</p><ol class=""><li id="c98a" class="mk ml ht iz b ja jb je jf ji mm jm mn jq mo ju nk mq mr ms dt translated">如果承诺的成本太高，它会阻止资金不足的用户参与</li><li id="f386" class="mk ml ht iz b ja mt je mu ji mv jm mw jq mx ju nk mq mr ms dt translated">如果承诺的成本太低，恶意行为者可以抢先承诺，并故意损失金钱，如果这有利于他们看守令牌的话</li></ol><figure class="lb lc ld le fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="lg lh di li bf lj"><div class="fe ff nl"><img src="../Images/e1db72671ed4ef4f130bced20fa94d8a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NiSaNMjg7gaiqXBMx2lWbA.png"/></div></div></figure><p id="dbb3" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">我们能够通过要求事务调用者提供他的地址散列和他的解决方案来防止这种情况。验证者契约能够验证公共地址和私有解决方案是否与所提供的散列相匹配。</p><p id="9d4c" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">现在，如果一个领先者试图窃取一个解决方案，他用相同的输入调用mint函数将会失败，因为他的地址与散列不匹配。</p><h1 id="cef1" class="jw jx ht bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">零知识证明如何实现可伸缩性？</h1><p id="1733" class="pw-post-body-paragraph ix iy ht iz b ja ku jc jd je kv jg jh ji kw jk jl jm kx jo jp jq ky js jt ju hm dt translated">如果我们甚至不考虑前端运行，使用ZKPs还有另一个主要好处:可伸缩性。验证是常数时间，因此验证者契约中使用的gas是有界的。或者，对于具有大量迭代的大型网格，在solidity中实现寿命可能会多次消耗气体极限。</p><p id="7fe6" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">缺点是groth16，即正在使用的zkSNARK协议需要一个特定于电路的可信设置，这意味着为了将应用程序部署到某个链中，您需要事先进行一个可信设置仪式。</p><p id="5316" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">可信设置是在证明生成和验证过程中使用的随机性的重要来源，如果它是由一方创建的，则该方能够伪造假证明，除非他们丢弃使他们能够这样做的“密钥”(因此是可信的)。</p><p id="4242" class="pw-post-body-paragraph ix iy ht iz b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju hm dt translated">可信设置仪式是多方创建可信设置的一种方法，使得只要一方是诚实的(丢弃他们那部分“秘密密钥”)，可信设置就是安全的。</p><h1 id="ba6e" class="jw jx ht bd jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt dt translated">敬请期待！</h1><p id="9f0f" class="pw-post-body-paragraph ix iy ht iz b ja ku jc jd je kv jg jh ji kw jk jl jm kx jo jp jq ky js jt ju hm dt translated">我计划创建一个react站点用于演示目的。如果你对这个项目有任何问题，请随时询问，并通过<a class="ae jv" href="https://twitter.com/rubydusav" rel="noopener ugc nofollow" target="_blank">https://twitter.com/rubydusav</a>联系我</p><blockquote class="nm"><p id="6f23" class="nn no ht bd np nq nr ns nt nu nv ju ek translated">交易新手？试试<a class="ae jv" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a>或者<a class="ae jv" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>