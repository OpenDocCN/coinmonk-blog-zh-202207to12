<html>
<head>
<title>Learn Solidity lesson 12. Addresses and only owner.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习第12课坚固性。地址和唯一的所有者。</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/learn-solidity-lesson-12-addresses-and-only-owner-5022234848fe?source=collection_archive---------5-----------------------#2022-07-31">https://medium.com/coinmonks/learn-solidity-lesson-12-addresses-and-only-owner-5022234848fe?source=collection_archive---------5-----------------------#2022-07-31</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/ac3ce591382f2a7e3c013288a15d21f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YXRHJa2NKWV1bQKOfy8qtA.jpeg"/></div></div></figure><p id="82f4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们已经看到了Solidity中的几种类型，比如uint和strings。现在让我们来看一个新的非常重要的类型:地址。地址代表区块链上的账户，因此被广泛使用。</p><p id="bf8d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们还看到，地址是从公钥派生出来的。更准确地说，帐户的地址是公钥散列的最后20个字节。因此，Solidity中的地址类型是20字节的十六进制数。</p><p id="20b7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在下面的代码中，我们通过它的文字声明了一个address类型的变量。前缀<em class="jz"> 0x </em>表示这是一个十六进制数。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="668c" class="kj kk ht kf b fv kl km l kn ko">address myAddress = 0xC66d07097f4823343bf116463070B3be5e941C4E</span></pre><p id="c5de" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">Solidity中还有另一种地址，即<strong class="jd hu">应付地址</strong>。在合同中，有可能将基础硬币发送到某个地址，但是，为此，该地址必须是可支付类型。</p><p id="e2cd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">要将一个地址声明为应付款，只需使用关键字<strong class="jd hu"> payable </strong>，如下所示。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="00f6" class="kj kk ht kf b fv kl km l kn ko">address payable myAddress = 0xC66d07097f4823343bf116463070B3be5e941C4E</span></pre><p id="5caf" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">即使我们没有声明一个应付地址，也有可能向它发送基础货币。为此，您需要将变量转换为payable。我们将在下一课中看到这一点。</p><p id="91cc" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在让我们更好地理解以太坊账户。</p><h1 id="a2b5" class="kp kk ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">外部拥有的账户和合同账户</h1><p id="d46a" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">以太坊有两种账户:所谓的<strong class="jd hu">外部自有账户</strong> ( <strong class="jd hu"> EOA </strong>)和<strong class="jd hu">合约账户</strong>。两者都由一个地址指定，但是它们之间有很大的不同。</p><p id="3a2a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我已经说过好几次了，以太坊上的账户是公钥/私钥对，但这只适用于EOA。合同帐户没有私钥或公钥。</p><p id="e5ea" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">为什么会这样？因为合同不用签什么。合同不能启动交易，它们只对交易作出反应。这意味着没有人拥有合同；一旦放在区块链上，它就是公共的，任何人都可以与之互动。如果创建者想要契约中的特权，那么这个特权需要被明确地编程到契约代码中。我们会知道怎么做的。</p><p id="7c74" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">合约是账户，因为像外部账户一样，它们在基础货币中有余额，也就是说，它们可以持有以太。事实上，合约账户在区块链上存储了4条信息。</p><ul class=""><li id="903a" class="lr ls ht jd b je jf ji jj jm lt jq lu ju lv jy lw lx ly lz dt translated">它的平衡。</li><li id="3e9b" class="lr ls ht jd b je ma ji mb jm mc jq md ju me jy lw lx ly lz dt translated">随机数。这是区块链正常工作所必需的唯一号码(我们将在后面详细解释)。</li><li id="8c7d" class="lr ls ht jd b je ma ji mb jm mc jq md ju me jy lw lx ly lz dt translated">字节码。</li><li id="2ff8" class="lr ls ht jd b je ma ji mb jm mc jq md ju me jy lw lx ly lz dt translated">由协定定义的状态变量的值。</li></ul><p id="ddf2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">字节码是契约代码，因此它必须存储在区块链上，契约状态变量也是如此。合同有余额这一事实表明，我们可以把乙醚送到这样的账户上。但是有一个区别:我们需要在契约中写函数，允许这样的以太的撤销。由于契约没有私钥，所以它们不会主动发送以太网。契约没有自己的意志。</p><blockquote class="mf"><p id="c9cd" class="mg mh ht bd mi mj mk ml mm mn mo jy ek translated">重要的是要记住，合同不会引发交易。</p></blockquote><p id="29a6" class="pw-post-body-paragraph jb jc ht jd b je mp jg jh ji mq jk jl jm mr jo jp jq ms js jt ju mt jw jx jy hm dt translated">eoa只有前两个数据字段:余额和随机数。它们既没有字节码，也没有状态变量。</p><h1 id="e6bc" class="kp kk ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">唯一所有者</h1><p id="e810" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">让我们记住，我们的最后一份合同是负责在区块链上存放遗嘱。你注意到它有一个重大的安全缺陷吗？任何人都可以调用合同的公共功能，并改变每个继承人将获得的金额。例如，恶意继承人可以调用该函数并增加其可继承金额。</p><p id="47f8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">正如我所说的，如果写合同的人想要合同中的特权，他/她需要将它编程到代码中。这就是我们在这一部分要做的事情。</p><p id="20cd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">首先，让我们声明一个address类型的状态变量，名为<code class="eh mu mv mw kf b">owner</code>。将以下代码行添加到协定中，不包含任何函数。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="ef03" class="kj kk ht kf b fv kl km l kn ko">address owner;</span></pre><p id="1dc7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这将创建一个新的状态变量。这个变量将存储它的拥有者的地址，他将拥有特殊的特权。例如，我们将要求，为了改变每个继承人应得的金额，交易必须由所有人签字。</p><p id="7283" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在合同中，可以访问提交交易的帐户地址。为此，使用全局变量<strong class="jd hu"> msg </strong>的<strong class="jd hu">发送方</strong>属性，如下所示。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="72fc" class="kj kk ht kf b fv kl km l kn ko">msg.sender</span></pre><p id="fe42" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">使用<em class="jz"> msg.sender </em>有一个微妙之处，因为契约有可能调用其他契约中的函数，所以<em class="jz"> msg.sender </em>并不总是指示谁发起了事务。我们以后会明白的，我们现在不需要担心。</p><p id="6c5f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在我们需要要求发送调用函数<code class="eh mu mv mw kf b">addHeir</code>的事务的地址与契约的所有者相同。这是按照下面的语句完成的。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="e07b" class="kj kk ht kf b fv kl km l kn ko">require(msg.sender == owner);</span></pre><p id="0cc1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这一陈述很有解释力，完全符合我们的意图。就这样，我们解决了问题。让我们看看新功能<code class="eh mu mv mw kf b">addHeir</code>是什么样子的。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="e541" class="kj kk ht kf b fv kl km l kn ko">function addHeir(string memory _name, uint _value) public {<br/>   require(msg.sender == owner);<br/>   heranca[_name] = _value;<br/>}</span></pre><p id="7105" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当被调用时，该函数做的第一件事是检查<em class="jz"> msg.sender </em>是否与所有者的地址相同。如果是，交易继续进行。否则，事务恢复(回滚)。</p><p id="1736" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当事务<strong class="jd hu">回复</strong>时，它不会引起区块链状态的任何改变。基本上，调用的函数不会有任何效果。</p><p id="61c4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这是一种“唯一所有者”策略，只有合同的所有者才能使某些功能生效。任何人都可以调用这个函数，但如果他们没有所有者的地址私钥，调用将只是浪费汽油费。它将恢复原状，没有任何效果。</p><h1 id="3f5b" class="kp kk ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">构造函数</h1><p id="8d45" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">我们现在需要给状态变量<code class="eh mu mv mw kf b">owner</code>赋值。我们希望保存部署合同的帐户的地址。记住，契约的部署是一个事务，所以我们可以使用<em class="jz"> msg.sender </em>属性来获取部署它的帐户的地址。</p><p id="93bb" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在部署时，契约调用一个特殊的函数，该函数只在部署时执行。以后不能调用它。这样的函数称为<strong class="jd hu">构造函数</strong>，必须声明如下。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="43fa" class="kj kk ht kf b fv kl km l kn ko">constructor([parameters]) {<br/>   // body of the function<br/>}</span></pre><p id="75f0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在我们的契约中，构造函数不使用任何参数，它只是将进行事务的地址存储在变量<code class="eh mu mv mw kf b">owner</code>中。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="2e42" class="kj kk ht kf b fv kl km l kn ko">constructor() {<br/>   owner = msg.sender;<br/>}</span></pre><p id="316c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">合同现在已经完成。下面，我们可以看到他的全身。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="dd17" class="kj kk ht kf b fv kl km l kn ko">...<br/>mapping(string =&gt; uint) inheritance;<br/>address public owner;</span><span id="bd4b" class="kj kk ht kf b fv mx km l kn ko">constructor() {<br/>   owner = msg.sender;<br/>}<br/> <br/>function addHeir(string memory _name, uint _value) public {<br/>   require(msg.sender == owner);<br/>   inheritance[_name] = _value;<br/>}</span><span id="9d9f" class="kj kk ht kf b fv mx km l kn ko">function recoverInheritance(string memory _name) public view returns (uint) {<br/>   return inheritance[_name];<br/>}<br/>...</span></pre><p id="f931" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我将变量<code class="eh mu mv mw kf b">owner</code>的可见性更改为public，这样我们就可以在Remix中验证它是否采用了部署契约的地址的值。</p><p id="8d9d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在下图中，我们看到部署是由地址<code class="eh mu mv mw kf b">0x5B3…eddC4</code>完成的。</p><figure class="ka kb kc kd fq iu fe ff paragraph-image"><div class="fe ff my"><img src="../Images/157db7d8b6a4ecb3f9eb6f272777c16a.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*Q0pqFk6Fzw8TgHJ5ug7lPQ.png"/></div><figcaption class="mz na fg fe ff nb nc bd b be z ek">Deployment is done by a transaction generated by the address 0x5B3…eddC4.</figcaption></figure><p id="bb12" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">由于变量<code class="eh mu mv mw kf b">owner</code>是公共的，我们可以检索它的值。这在下图中可以看到。</p><figure class="ka kb kc kd fq iu fe ff paragraph-image"><div class="fe ff nd"><img src="../Images/71a976e7507221aec59b9a0cbb075eba.png" data-original-src="https://miro.medium.com/v2/resize:fit:770/format:webp/1*NY4bO0CeS4U_cWCdbCaQXg.png"/></div><figcaption class="mz na fg fe ff nb nc bd b be z ek">The variable \textit{owner} holds the address 0x5B3…eddC4.</figcaption></figure><p id="7444" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">由于没有编写改变变量<code class="eh mu mv mw kf b">owner</code>的函数，一旦其值被赋值，就不会被改变。</p><p id="928a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">此外，如果我们试图使用除了<code class="eh mu mv mw kf b">0x5B3…eddC4</code>之外的任何帐户调用函数<code class="eh mu mv mw kf b">addHeir</code>，事务将会恢复。这一点可以从下图中看出。</p><figure class="ka kb kc kd fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff ne"><img src="../Images/4bf74ece400713378b7954385705bbc9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eSoklZp1ApJoFu6S_q0Mag.png"/></div></div><figcaption class="mz na fg fe ff nb nc bd b be z ek">Transactions that invokes the function addHeir, sent by any other address than the owner, will revert.</figcaption></figure><p id="8986" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">将<em class="jz"> msg.sender </em>的地址分配给变量<code class="eh mu mv mw kf b">owner</code>的另一种方法是在声明变量时进行分配，如下所示。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="0592" class="kj kk ht kf b fv kl km l kn ko">address owner = msg.sender;</span></pre><p id="75e6" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">因此，没有必要显式声明构造函数。两种方法结果相同。</p><h1 id="eba1" class="kp kk ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">常量和不可变变量</h1><p id="6334" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">我们可以将变量声明为<strong class="jd hu">常量</strong>和<strong class="jd hu">不可变</strong>。两种类型的变量在初始化后都不能更改，但是常量变量必须在声明时(编译时)初始化，而不可变变量可以在构造函数中初始化(部署时)。</p><p id="3c78" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">常量变量的一个例子如下。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="343e" class="kj kk ht kf b fv kl km l kn ko">uint const MY_NUMBER = 42;</span></pre><p id="518c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">以这种方式声明，变量<code class="eh mu mv mw kf b">MY_NUMBER </code>将保存值<code class="eh mu mv mw kf b">42</code>并且不能改变。事实上，称<code class="eh mu mv mw kf b">MY_NUMBER</code>为变量是不正确的，因为区块链没有为它分配专用空间。<code class="eh mu mv mw kf b">MY_NUMBER</code>的值直接写入字节码，不是状态变量。</p><p id="0b9d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在前面的例子中，既然变量<code class="eh mu mv mw kf b">owner </code>不会改变，我们是否可以将其声明为常量？我们可以做如下声明吗？</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="abc0" class="kj kk ht kf b fv kl km l kn ko">address public constant owner = msg.sender;</span></pre><p id="b2ad" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">答案是否定的。常量必须在声明时初始化，在编译时定义。在上面的例子中，变量<code class="eh mu mv mw kf b">owner</code>只在部署时初始化。还记得我们在构造函数中初始化了变量<code class="eh mu mv mw kf b">owner </code>吗？上面的语句就像变量是在构造函数中初始化的一样。</p><p id="a765" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">因此，变量<code class="eh mu mv mw kf b">owner</code>可以被声明为<em class="jz">不可变</em>，但不能被声明为常量。下面的句子是正确的。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="3467" class="kj kk ht kf b fv kl km l kn ko">address immutable public owner = msg.sender;</span></pre><p id="62eb" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">任何时候试图改变变量<code class="eh mu mv mw kf b">owner</code>都会产生编译器错误。</p><p id="83ae" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">感谢阅读！</strong></p><p id="9dcc" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎对本文提出意见和建议。</p><p id="3323" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎任何投稿。<a class="ae nf" href="http://www.buymeacoffee.com/jpmorais" rel="noopener ugc nofollow" target="_blank">www.buymeacoffee.com/jpmorais</a></p></div></div>    
</body>
</html>