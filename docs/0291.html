<html>
<head>
<title>Ethereum data — Transaction Receipt Trie and Logs Simplified</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以太坊数据—简化的交易收据Trie和日志</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/ethereum-data-transaction-receipt-trie-and-logs-simplified-30e3ae8dc3cf?source=collection_archive---------0-----------------------#2022-07-06">https://medium.com/coinmonks/ethereum-data-transaction-receipt-trie-and-logs-simplified-30e3ae8dc3cf?source=collection_archive---------0-----------------------#2022-07-06</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/0b969658cb4f947ce5975cb922e53847.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FkfeicDs0ns5qjxiyyG0oQ.png"/></div></div></figure><p id="26cc" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">交易收据包含交易结果(状态和日志),并以trie结构组织。收据数据驻留在状态数据库中，根散列存储在块头中。收据trie包含哪些信息？谁会受益？让我们更深入地探讨这些问题。</p><figure class="ka kb kc kd fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff jz"><img src="../Images/6bdedf74f05ae3218ebece0f77f631bd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*93gggj7uP9BC5eE7XislSQ.png"/></div></div><figcaption class="ke kf fg fe ff kg kh bd b be z ek">Ethereum Full Node — Transaction Receipt Trie</figcaption></figure><p id="676a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">智能合约以两种不同的方式在区块链存储信息:帐户存储和日志。帐户存储包含定义智能合约状态以及合约可以访问的任何数据。日志用于存储合同不要求但必须由其他链外应用程序(前端、分析等)访问的信息。同样值得注意的是，日志存储比帐户存储便宜得多。</p><p id="72c9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">给定一个简单的令牌合同，允许用户拥有不可替换的(即唯一的)令牌，这就是数据存储的方式。</p><ul class=""><li id="ceea" class="ki kj ht jd b je jf ji jj jm kk jq kl ju km jy kn ko kp kq dt translated"><strong class="jd hu">令牌所有权→账户存储</strong>:智能合约显然应该知道谁拥有哪个令牌。为了使合同能够证明所有权并提供所有权转移功能，应该将<em class="kr">令牌id </em>和<em class="kr">令牌所有者</em>存储在账户存储器中。</li><li id="bb71" class="ki kj ht jd b je ks ji kt jm ku jq kv ju kw jy kn ko kp kq dt translated"><strong class="jd hu">令牌所有权历史记录→日志</strong>:契约只需要知道当前令牌所有权就可以发挥作用。另一方面，投资者或决策者会对跟踪代币的所有权历史感兴趣。每当令牌被制造或转移时，该信息可以被捕获到日志中。然后，可以汇总日志以揭示任何此类见解。</li><li id="277c" class="ki kj ht jd b je ks ji kt jm ku jq kv ju kw jy kn ko kp kq dt translated"><strong class="jd hu"> UI通知→日志:</strong>令牌生成(创建)时，前端应用程序可能希望向令牌所有者显示确认和其他详细信息。因为事务是异步的，所以智能协定不能向前端返回值。相反，当薄荷发生时，它可以将它写入日志。然后，前端可以监听通知并将它们显示给用户。</li><li id="6d83" class="ki kj ht jd b je ks ji kt jm ku jq kv ju kw jy kn ko kp kq dt translated"><strong class="jd hu">链外触发→日志:</strong>当您出于各种原因(例如，为了玩在不同区块链上构建的游戏)想要将您的令牌转移到另一个区块链时，您可以向一个公共网关发起转移，并且交易将记录该转移。然后，公共网关将挑选该信息，并在另一个链中铸造相应的令牌。</li></ul><blockquote class="kx ky kz"><p id="1615" class="jb jc kr jd b je jf jg jh ji jj jk jl la jn jo jp lb jr js jt lc jv jw jx jy hm dt translated">交易新手？尝试<a class="ae ld" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae ld" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote><p id="631b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当智能合约想要记录上述场景的数据时，它可以发出一个事件(如下所示)，然后将该事件写入交易收据的日志记录。</p><figure class="ka kb kc kd fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff le"><img src="../Images/263b91f7a253f1bb152a57a3290ebc8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RZX_UGepE0HYXYrNc3cIDg.png"/></div></div><figcaption class="ke kf fg fe ff kg kh bd b be z ek">Simple Non Fungible Token Contract — Events</figcaption></figure><p id="473f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">每笔交易只有一张交易收据。除了日志记录之外，收据还包括状态、使用的气体和日志文件，我们将详细讨论这些内容。</p><figure class="ka kb kc kd fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff lf"><img src="../Images/d9046220c0859178f93bd286e653c0c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MGdOB03spsVkTqC2H87AkA.png"/></div></div><figcaption class="ke kf fg fe ff kg kh bd b be z ek">Transaction Receipt — Fields</figcaption></figure><h2 id="24b7" class="lg lh ht bd li lj lk ll lm ln lo lp lq jm lr ls lt jq lu lv lw ju lx ly lz ma dt translated">状态</h2><p id="da82" class="pw-post-body-paragraph jb jc ht jd b je mb jg jh ji mc jk jl jm md jo jp jq me js jt ju mf jw jx jy hm dt translated">状态为0或1。它为调用者提供了一个线索来确定交易是否成功。因为事务是异步的，所以调用者必须等到块被挖掘出来才能从事务收据中读取状态。</p><pre class="ka kb kc kd fq mg mh mi mj aw mk dt"><span id="10e4" class="lg lh ht mh b fv ml mm l mn mo">💁 All events are also reverted when a transaction is reverted (due to running out of gas or condition failures). The caller can only read the status, not any further information as the logged events are reverted as well. The only way to understand what happened is to examine client node traces, which contains detailed information about the execution.</span></pre><h2 id="7e4f" class="lg lh ht bd li lj lk ll lm ln lo lp lq jm lr ls lt jq lu lv lw ju lx ly lz ma dt translated">使用的气体</h2><p id="7683" class="pw-post-body-paragraph jb jc ht jd b je mb jg jh ji mc jk jl jm md jo jp jq me js jt ju mf jw jx jy hm dt translated">它是区块中所有先前交易(包括当前交易)消耗的天然气总量。</p><h2 id="f7d3" class="lg lh ht bd li lj lk ll lm ln lo lp lq jm lr ls lt jq lu lv lw ju lx ly lz ma dt translated">日志</h2><p id="0ae1" class="pw-post-body-paragraph jb jc ht jd b je mb jg jh ji mc jk jl jm md jo jp jq me js jt ju mf jw jx jy hm dt translated">日志只是日志记录的集合。单个日志记录包括主题和数据。主题是一个列表，其中包括事件签名以及任何索引字段。一个日志记录最多可以包含四个主题。主题的存储容量有限，不建议存储大量数据。一般来说，任何可能出现在日志搜索中的数据都应该存储在被索引的主题中。任何其他信息都存储在数据字段中。</p><figure class="ka kb kc kd fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mp"><img src="../Images/00ef51f26e82c7d945b1e546c437b672.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7PNHkKSA6TpdLN56zPmH5Q.png"/></div></div><figcaption class="ke kf fg fe ff kg kh bd b be z ek">Transaction Receipt — Log Record Indexing</figcaption></figure><figure class="ka kb kc kd fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff jz"><img src="../Images/dcf1a60c3fc4aad057ec669e05ee4bd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*o6oO8M6SEK-1f6dwYsypKQ.png"/></div></div><figcaption class="ke kf fg fe ff kg kh bd b be z ek">Transaction Receipt — Log Record Creation</figcaption></figure><p id="5d0d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">因为字段<em class="kr">事件名称、从、到</em>被索引，所以可以有效地检索下面的查询。</p><ul class=""><li id="d2bd" class="ki kj ht jd b je jf ji jj jm kk jq kl ju km jy kn ko kp kq dt translated">列出今天发生的所有令牌转移。</li><li id="1fed" class="ki kj ht jd b je ks ji kt jm ku jq kv ju kw jy kn ko kp kq dt translated">返回该用户(钱包地址)在过去一小时内售出的所有令牌。</li><li id="f874" class="ki kj ht jd b je ks ji kt jm ku jq kv ju kw jy kn ko kp kq dt translated">获取该用户在上周购买的所有令牌的列表。</li></ul><p id="3433" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">但是，因为<em class="kr">令牌Id </em>没有被索引，而是存储在<em class="kr">数据</em>字段中，所以任何检查“<em class="kr">的查询今天是否在此令牌Id上完成了任何传输？</em>“会极慢。</p><p id="313a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">由于索引需要额外的计算，存储在主题中比存储在数据字段中稍微贵一些。让我们在下面的小节中看看索引是如何完成的。</p><h2 id="afe9" class="lg lh ht bd li lj lk ll lm ln lo lp lq jm lr ls lt jq lu lv lw ju lx ly lz ma dt translated">原木开花</h2><p id="9119" class="pw-post-body-paragraph jb jc ht jd b je mb jg jh ji mc jk jl jm md jo jp jq me js jt ju mf jw jx jy hm dt translated">假设我们想要</p><blockquote class="mq"><p id="0065" class="mr ms ht bd mt mu mv mw mx my mz jy ek translated">查找特定用户(钱包)在特定区块出售的所有代币。</p></blockquote><p id="f8ff" class="pw-post-body-paragraph jb jc ht jd b je na jg jh ji nb jk jl jm nc jo jp jq nd js jt ju ne jw jx jy hm dt translated">我们可以解析日志来回答这个问题，因为“发件人”地址已被捕获。但是，为了确定这一点，我们必须对块中的所有事务进行搜索。</p><p id="09a9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">假设该块包含500个事务，我们的搜索要求我们检查所有事务的所有日志记录(主题和数据)。相反，我们是否可以为每个事务创建一个字段，指示我们要寻找的信息是否存在于事务日志中？布鲁姆过滤器。</p><p id="156a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在我们继续之前，让我们看一下带有简单列表搜索示例的bloom filter。假设我们想要找出一个用户是否存在于给定的列表中。找出答案的一个简单方法是浏览列表。然而，如果一个列表包含成千上万的用户，它会变得非常昂贵和非常慢。为了改进搜索，我们可以通过散列和映射列表中的每个用户来为列表创建一个有效的索引，如下所示。</p><figure class="ka kb kc kd fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff nf"><img src="../Images/e5907abb681931b46e7f65e5bb846545.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EzyktXONQ_AdfPdJFMwbZg.png"/></div></div><figcaption class="ke kf fg fe ff kg kh bd b be z ek">Bloom filter construction— simplified</figcaption></figure><p id="78b5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">您可能已经注意到，Bloom filter是通过合并各个哈希而创建的。假设我们想知道Xin、Kia和Eva是否在列表中。通过使用布隆过滤器，我们可以在不查询列表的情况下获得答案。</p><figure class="ka kb kc kd fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff ng"><img src="../Images/a676663f2b7ff878609c80c54b83208e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*pkQPASEpu_YJYUc_ftvFmA.png"/></div></div><figcaption class="ke kf fg fe ff kg kh bd b be z ek">Bloom filter search — simplified</figcaption></figure><p id="94dc" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">布隆过滤器是一种概率数据结构，可以说“可能存在”或“肯定不存在”。在这种情况下，Bloom filter对于确定Xin或Kia是否在列表中不是很有用。要找到答案，我们必须实际查询列表。但是，它为伊娃提供了一个明确的答案，他们不在名单上。布鲁姆过滤器非常有用，尤其是当你认为大多数答案肯定不是的时候。</p><p id="3b25" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们回到查找特定用户在一个街区出售的代币的例子。假设事件在500个事务的特定块中发生了两次。我们不需要解析每个事务的所有主题，而是可以查询日志bloom(根据主题创建)中是否存在用户地址，只有匹配时才进行主题搜索，否则跳到下一个事务。</p><p id="893d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">除了事务级日志bloom之外，EVM还会合并每个事务的日志bloom，并在标头中创建一个日志bloom。假设我们必须搜索相同的查询(特定用户出售的令牌),但是要跨越许多块。我们可以简单地查询头部的bloom，而不是查询每个块中每个事务的bloom。如果匹配，继续查询事务日志，否则跳到下一个块。因此，布隆过滤器有助于提高搜索效率。</p><h2 id="5373" class="lg lh ht bd li lj lk ll lm ln lo lp lq jm lr ls lt jq lu lv lw ju lx ly lz ma dt translated">为什么是这种结构</h2><p id="39a5" class="pw-post-body-paragraph jb jc ht jd b je mb jg jh ji mc jk jl jm md jo jp jq me js jt ju mf jw jx jy hm dt translated">现在我们知道了什么是交易收据，我们需要理解为什么它是以trie结构组织的。</p><figure class="ka kb kc kd fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff nh"><img src="../Images/15ad7a3245acb950bd4cc3cc3fad3927.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eDQWxzjdNfISuLNlyA56Qg.png"/></div></div><figcaption class="ke kf fg fe ff kg kh bd b be z ek">Transaction Receipt Trie — Merkle</figcaption></figure><p id="d715" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这种trie结构的目的是使以太坊协议对客户端友好。因为轻客户端只存储块头，所以它们必须向一个完整的节点进行查询，例如"<em class="kr">检索最近n天内涉及从wallet X转移的所有交易。</em>”。因为区块链的固有假设是任何节点都不可信，所以除了结果之外，轻节点还需要来自完整节点的证明。在Merkle树结构中组织收据允许通过网络进行有效的证明分发。这篇<a class="ae ld" rel="noopener" href="/coinmonks/ethereum-data-transaction-trie-simplified-795483ff3929">的文章</a>详细介绍了这一点。</p><p id="9e55" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我希望这篇文章能让你更好地理解以太坊区块链中的交易收据trie和事件日志。我将在以后的文章中解构EVM的痕迹。如果你想在帖子发布时得到通知，请确保关注。如果您有任何问题或意见，请随时联系我们。 <a class="ae ld" href="https://twitter.com/kirubakumaresh" rel="noopener ugc nofollow" target="_blank"> <em class="kr">推特</em> </a> <em class="kr"> | </em> <a class="ae ld" href="https://www.linkedin.com/in/kirubakumaresh/" rel="noopener ugc nofollow" target="_blank"> <em class="kr">领英</em> </a></p></div></div>    
</body>
</html>