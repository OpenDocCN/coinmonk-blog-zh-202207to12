<html>
<head>
<title>Proxy — Variable immutability</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">代理——可变不变性</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/variable-immutability-proxy-112b861a9cb4?source=collection_archive---------9-----------------------#2022-09-26">https://medium.com/coinmonks/variable-immutability-proxy-112b861a9cb4?source=collection_archive---------9-----------------------#2022-09-26</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="d504" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">区块链技术是由几个理念建立的:安全、开放、平等和不变性。让我们把注意力集中在最后一个词上。当我们创建任何事务，并且它将在块内被接受时，块内的信息将永远不会改变。该事务可以是任何事情:创建新的智能合同，与其他合同交互或向某人发送以太网等。—没什么不同。保存到区块链的所有信息都将永远存在。感谢每一个区块链的用户可以放心睡觉，不用担心有人改变游戏规则，而他们没有注意到这一点。</p><p id="1594" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">但这是一把双刃剑。如果没有人能够改变区块链的内容，那么你也一样。即使您想要更改您部署的智能合约中的某些内容，并且在此之后您发现了一个错误。对不起，在你的合同中总是会有这个错误，除非你创建一个没有这个错误的新的智能合同，并部署它。但是错误的合同仍然会在区块链。但这不是问题，是吗？答案是:是也不是。当这个契约不相关时，例如，你在学习Solidity时创建了它，它就没有问题。但是当它很重要的时候，因为这个合同是一个大项目的一部分，并且有人可以通过这个错误破坏整个项目，这是一个巨大的问题，我们希望尽快解决它。但是当我们做不到的时候，怎么做呢？</p><h2 id="728e" class="jo jp ht bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki dt translated">解决方案1 —迁移</h2><p id="b385" class="pw-post-body-paragraph iq ir ht is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hm dt translated">解决方案之一是创建一个新的无错误的合同并部署它。之后，通知每个人，所有人都应该使用这个新的。很简单，不是吗？不完全是，让我们看看这一举措的潜在影响。想象一下，这个契约非常受欢迎，并且有很多用户，他们在自己的契约中努力编写它的地址。当我们部署新合同来替换旧合同时，他们都必须更改合同中的地址。我们如何改变硬编程地址？当然，通过编写新合同并部署它。你看到了吗？就像雪崩一样。一开始，这只是一个合同的变更，但它有可能产生巨大的不安全影响。为什么没有安全感？因为，例如，可能有人没有注意到地址的改变。</p><h2 id="b489" class="jo jp ht bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki dt translated">解决方案2 —代理</h2><p id="5e62" class="pw-post-body-paragraph iq ir ht is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hm dt translated">那么，另一个解决方案是什么？让我给你介绍一个代理人。最简单的方法是，代理是一个智能契约，它有第二个智能契约的地址(称之为逻辑)。当用户想要使用逻辑中的任何函数时，将带有函数名和发送值等信息的事务发送到代理的地址。理论上，代理在逻辑上没有与此同名的函数，所以来自用户的事务转到代理的回退。实现了对逻辑的<em class="ko">委托调用</em>。因为代理使用<em class="ko"> delegatecall </em>，所以所有状态的改变都将保存在代理的存储器中，而不是逻辑中。</p><figure class="kq kr ks kt fq ku fe ff paragraph-image"><div role="button" tabindex="0" class="kv kw di kx bf ky"><div class="fe ff kp"><img src="../Images/a221f515fc16af17ee6b3adf2a9b0085.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ygDbZ_9zIkNwDRRU27zBVQ.png"/></div></div><figcaption class="lb lc fg fe ff ld le bd b be z ek">The idea of Proxy.</figcaption></figure><p id="2bcc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当有人发现逻辑中的一个错误，或者有人想实现一个新的功能时，没有简单的方法来改变它。怎么会？只需替换代理内部的逻辑地址。由于这一点，用户将仍然使用相同的地址(代理地址)，但他将能够使用新版本的逻辑。</p><p id="b82c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">代理的想法是优雅和美丽的，但有几个问题。</p><h2 id="05c1" class="jo jp ht bd jq jr js jt ju jv jw jx jy jb jz ka kb jf kc kd ke jj kf kg kh ki dt translated">代理的问题</h2><p id="bc98" class="pw-post-body-paragraph iq ir ht is b it kj iv iw ix kk iz ja jb kl jd je jf km jh ji jj kn jl jm jn hm dt translated">不恰当地使用<em class="ko">委托调用</em>会导致安全漏洞，因此在代理和逻辑中保持相同的变量集非常重要。签名只有4个字节长，所以几个函数可能有相同的签名。这个问题叫做存储冲突。为了避免这种情况，我们使用三种主要的代理存储组织方式之一:<a class="ae lf" rel="noopener" href="/coinmonks/proxy-inherited-storage-7887f63944e6">继承存储</a>、<a class="ae lf" rel="noopener" href="/coinmonks/proxy-eternal-storage-f67c54972cdb">永久存储</a>和<a class="ae lf" rel="noopener" href="/coinmonks/proxy-unstructured-storage-7f41a9ac22f2">非结构化存储</a>。我将在我的下一篇文章中写下所有这些。</p><p id="5182" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">代理的下一个困难是不可能使用<em class="ko">构造函数</em>来初始化初始值。为什么？因为<em class="ko">构造函数</em>在拥有这个<em class="ko">构造函数</em>的契约的存储中设置值，而不是在代理内部，我们从那里读取值。因此，即使我们通过<em class="ko">构造函数</em>设置值，代理也不会注意到它。为了避免这种情况，我们可以使用<em class="ko">初始化器。</em>这是一个只能调用一次的函数，它包含了我们通常在<em class="ko">构造函数</em>中写入的所有信息。此外，在逻辑内部编写类似于<code class="eh lg lh li lj b">uint256 public InitValue = 42;</code>的东西不会初始化值，因为这样设置值是由编译器改变为由<em class="ko">构造器</em>设置值。因此，我们可以将所有这类操作放到<em class="ko">初始化器</em>中。</p><p id="afbf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我前面提到过，代理使用fallback方法，在那里实现了<em class="ko"> delegatecall </em>，即从逻辑上使用函数。我们知道EVM使用签名来选择被调用的函数。如果代理和逻辑有一个同名的函数会怎样。EVM将如何知道它应该打电话给他们中的哪一个？这个问题被称为代理选择器冲突。</p><p id="20ba" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">目前有3种最流行的代理模式:透明代理模式、通用可升级代理标准和钻石模式。我将在下一篇文章中展示它们。它们都是为了避免代理选择器冲突而创建的。</p><blockquote class="lk"><p id="f210" class="ll lm ht bd ln lo lp lq lr ls lt jn ek translated">交易新手？试试<a class="ae lf" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或者<a class="ae lf" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>