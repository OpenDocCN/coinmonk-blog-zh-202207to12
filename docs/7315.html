<html>
<head>
<title>Part 2: Building a Complete API in Go to Interact with a P2P Escrow Smart Contract using go-ethereum Client &amp; GoFiber Framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第2部分:在Go中构建一个完整的API，使用go-ethereum客户端和GoFiber框架与P2P托管智能契约进行交互</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/part-2-building-a-complete-api-in-go-to-interact-with-a-p2p-escrow-smart-contract-using-fa0514531032?source=collection_archive---------21-----------------------#2022-12-11">https://medium.com/coinmonks/part-2-building-a-complete-api-in-go-to-interact-with-a-p2p-escrow-smart-contract-using-fa0514531032?source=collection_archive---------21-----------------------#2022-12-11</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/094b4b7854f4ce57afc59360ad582edf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5a1o8w31T-WzODa3Su3FcQ.png"/></div></div></figure><p id="2327" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这是本系列两篇文章的第二部分</p><ul class=""><li id="45ff" class="jz ka ht jd b je jf ji jj jm kb jq kc ju kd jy ke kf kg kh dt translated"><a class="ae ki" rel="noopener" href="/coinmonks/part-1-building-a-complete-api-in-go-to-interact-with-a-p2p-escrow-smart-contract-using-9cf1f681c860">第1部分:项目概述、设置纤程、生成Go绑定、部署合同、添加get托管&amp;钱包逻辑地址端点</a></li><li id="cf43" class="jz ka ht jd b je kj ji kk jm kl jq km ju kn jy ke kf kg kh dt translated">第2部分:添加和总结P2P API端点</li></ul><p id="e129" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">你可以在GitHub的<a class="ae ki" href="https://github.com/alofeoluwafemi/-smart-contract-api-go-ethereum" rel="noopener ugc nofollow" target="_blank">这里找到代码库作为参考。</a></p><p id="9a4a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这里是API Postman集合<a class="ae ki" href="https://www.getpostman.com/collections/362a5590ccf482592588" rel="noopener ugc nofollow" target="_blank">链接</a>供你导入。</p><h1 id="5371" class="ko kp ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">P2P订单网页挂钩</h1><h1 id="5f2d" class="ko kp ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">设置USDC地址</h1><p id="0d27" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">在本文的第一部分中，我们部署了一个USDC契约，我提到过它是一个模拟的USDC，在我们的P2P系统中用作对抗Fiat的交换手段。在生产环境中，我们会将地址更改为以太坊或或戴上使用的实际地址，无论哪种稳定的货币适合我们的目的。</p><p id="0143" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">正如我们之前所做的，首先在<code class="eh lr ls lt lu b">api_router.go</code>文件中添加一条路线来设置USDC。</p><pre class="lv lw lx ly fq lz lu ma bn mb mc bi"><span id="12b0" class="md kp ht lu b be me mf l mg mh">escrow := api.Group("/escrow")<br/><br/>escrow.Post("/set-usdc-address", controllers.SetUSDCTokenAddress)</span></pre><p id="4e57" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在控制器包中，创建<code class="eh lr ls lt lu b">escrow_controllers.go</code>来保存与托管合同相关的动作的控制器方法。</p><pre class="lv lw lx ly fq lz lu ma bn mb mc bi"><span id="38c7" class="md kp ht lu b be me mf l mg mh">package controllers<br/><br/>import (<br/>	"github.com/alofeoluwafemi/go-ethereum-api/pkg/blockchain"<br/>	"github.com/gofiber/fiber/v2"<br/>)<br/><br/>func SetUSDCTokenAddress(c *fiber.Ctx) error {<br/>	conn := blockchain.CurrentConnection<br/>	type Request struct {<br/>		Address string `json:"address"`<br/>	}<br/><br/>	request := new(Request)<br/><br/>	if err := c.BodyParser(request); err != nil {<br/>		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{<br/>			"status":  "error",<br/>			"message": "Malformed data",<br/>			"data":    err,<br/>		})<br/>	}<br/><br/>	err := conn.SetUSDCAddress(request.Address)<br/><br/>	if err != nil {<br/>		return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{<br/>			"status":  "error",<br/>			"message": err,<br/>			"data":    nil,<br/>		})<br/>	}<br/><br/>	return c.Status(fiber.StatusOK).JSON(fiber.Map{<br/>		"status": "success",<br/>		"data":   request.Address,<br/>	})<br/>}</span></pre><p id="795a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">最后，在区块链包中，添加一个新文件<code class="eh lr ls lt lu b">escrow.go</code>，并添加以下内容。</p><pre class="lv lw lx ly fq lz lu ma bn mb mc bi"><span id="be90" class="md kp ht lu b be me mf l mg mh">package blockchain<br/><br/>import (<br/>	"github.com/alofeoluwafemi/go-ethereum-api/pkg/ethereum"<br/>	"github.com/ethereum/go-ethereum/common"<br/>	"log"<br/>)<br/><br/>var EscrowInstance *Escrow<br/><br/>const (<br/>	EscrowAddress = "0xd27adc3848dE1324AF87e5C235355e4a017Aa1CF"<br/>)<br/><br/>type Escrow struct {<br/>	Address  common.Address<br/>	Instance *ethereum.Escrow<br/>}<br/><br/>func (clientCon ClientConnection) newEscrow(address string) *ethereum.Escrow {<br/>	EscrowInstance = new(Escrow)<br/><br/>	contractAddress := common.HexToAddress(address)<br/><br/>	EscrowInstance.Address = contractAddress<br/><br/>	instance, err := ethereum.NewEscrow(contractAddress, clientCon.Client)<br/>	if err != nil {<br/>		log.Fatalln("Cannot get Factory contract at address ", address, " due to: ", err)<br/>	}<br/><br/>	return instance<br/>}<br/><br/>func (clientCon ClientConnection) SetUSDCAddress(address string) error {<br/><br/>	_, err := getEscrow().SetUsdcTokenAddress(clientCon.trxOpts, common.HexToAddress(address))<br/><br/>	if err != nil {<br/>		log.Printf("Cannot set new USDC token on Escrow due to: %v", err)<br/><br/>		return err<br/>	}<br/><br/>	return nil<br/>}<br/><br/>func getEscrow() *ethereum.Escrow {<br/>	return CurrentConnection.newEscrow(EscrowAddress)<br/>}</span></pre><p id="cf8f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这不需要更多的解释，因为它与我们之前遵循的格式相同。如果您还没有阅读本系列的第1部分，我建议您阅读一下。</p><p id="ac9d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">重启Fiber服务器，在Postman中向<a class="ae ki" href="http://127.0.0.1:3000/api/v1/escrow/set-usdc-address" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:3000/API/v1/escrow/set-usdc-address</a>发出POST请求，工厂契约将被部署。</p><p id="b4aa" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">成功API调用</strong></p><figure class="lv lw lx ly fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mi"><img src="../Images/d143ca7bb1e0cecac82b6d5d3df6ebe0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*7uLeDYbttPKWJrZZ.png"/></div></div></figure><p id="22d0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">错误API调用</strong></p><p id="c3a3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这将在您向使用相同nonce的API发出第二个请求后立即发生。</p><figure class="lv lw lx ly fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mj"><img src="../Images/3975c0e07fa2286c7bdd56f287d75a09.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*rBdgkri1P5CbSCbi.png"/></div></div></figure><h1 id="1b02" class="ko kp ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">创建保管人钱包</h1><p id="b7f4" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">我们将创建的下一个路由是<code class="eh lr ls lt lu b">/api/v1/factory/new-wallet/:uuid</code>，这样当我们向这个端点发出POST请求时，它将调用工厂契约上的函数<code class="eh lr ls lt lu b">newCustodian</code>。这将部署一个名为<code class="eh lr ls lt lu b">CustodianWalletProxy</code>的代理契约，将调用委托给<code class="eh lr ls lt lu b">CustodianWalletLogic</code>。</p><p id="3ea7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">首先，像往常一样。将路线添加到<code class="eh lr ls lt lu b">api_router.go</code>。</p><pre class="lv lw lx ly fq lz lu ma bn mb mc bi"><span id="30ee" class="md kp ht lu b be me mf l mg mh">api.Post("/factory/new-wallet/:uuid", controllers.NewWallet)</span></pre><p id="7b08" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">接下来是控制器，这次是在<code class="eh lr ls lt lu b">factory_controller</code>文件中。</p><pre class="lv lw lx ly fq lz lu ma bn mb mc bi"><span id="42ee" class="md kp ht lu b be me mf l mg mh">func NewWallet(c *fiber.Ctx) error {<br/>	conn := blockchain.CurrentConnection<br/>	uuid := c.Params("uuid")<br/><br/>	trx, err := conn.NewWallet(uuid)<br/><br/>	if err != nil {<br/>		return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{<br/>			"status":  "error",<br/>			"message": err,<br/>			"data":    nil,<br/>		})<br/>	}<br/><br/>	return c.Status(fiber.StatusOK).JSON(fiber.Map{<br/>		"status": "success",<br/>		"hash":   trx.Hash(),<br/>	})<br/>}</span></pre><p id="01ed" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">正如您所看到的，为了创建新的钱包，智能契约需要一个惟一的标识符来将其保存在控制器通过URL参数接受的映射中。您很快就会看到，每个唯一的ID不能分配给另一个用户。</p><p id="d6e9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">最后，将<code class="eh lr ls lt lu b">NewWallet</code>方法添加到<code class="eh lr ls lt lu b">factory.go</code>文件的<code class="eh lr ls lt lu b">blockchain</code>包中。</p><pre class="lv lw lx ly fq lz lu ma bn mb mc bi"><span id="b0bf" class="md kp ht lu b be me mf l mg mh">func (clientCon ClientConnection) NewWallet(uuid string) (*types.Transaction, error) {<br/><br/>	trx, err := getFactory().NewCustodian(clientCon.trxOpts, uuid)<br/><br/>	if err != nil {<br/>		log.Printf("Cannot create new wallet: %v", err)<br/><br/>		return new(types.Transaction), err<br/>	}<br/><br/>	return trx, nil<br/>}</span></pre><p id="9f5f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">像往常一样重新启动光纤服务器，并向http://127 . 0 . 0 . 1:3000/API/v1/factory/new-wallet/CEC 3d d14-339 a-11ed-a261-0242 AC 120002和<a class="ae ki" href="http://127.0.0.1:3000/api/v1/factory/new-wallet/b93e42b0-33a2-11ed-a261-0242ac120002" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:3000/API/v1/factory/new-wallet/b 93 e 42 b 0-33 a2-11ed-a 266发出POST请求这将为附加在两个URL末尾的每个UUID创建一个帐户。</a></p><p id="c0bc" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">创建两个帐户的目的是，当我们进一步创建订单时，我们可以使用两个帐户。</p><figure class="lv lw lx ly fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mj"><img src="../Images/c73ec9c1365ee075dd4976b847d3bf6b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*b2lPRPT1qKWlCsTA.png"/></div></div></figure><p id="56df" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果您使用相同的UUID重试，您将得到一个帐户存在错误。</p><figure class="lv lw lx ly fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mk"><img src="../Images/d73e14b4396ffaa6ecaabcb85a4a66b6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*-Bji3woP_PuOXDiX.png"/></div></div></figure><h1 id="a898" class="ko kp ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">使用UUID获取钱包地址</h1><p id="470c" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">这将是一个显而易见的，添加使用UUID获得钱包地址的路线。</p><pre class="lv lw lx ly fq lz lu ma bn mb mc bi"><span id="11cb" class="md kp ht lu b be me mf l mg mh">api.Get("/factory/wallet/:uuid", controllers.GetWallet)</span></pre><p id="aba1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在<code class="eh lr ls lt lu b">factory_controller.go</code></p><pre class="lv lw lx ly fq lz lu ma bn mb mc bi"><span id="0992" class="md kp ht lu b be me mf l mg mh">func GetWallet(c *fiber.Ctx) error {<br/>	conn := blockchain.CurrentConnection<br/>	uuid := c.Params("uuid")<br/><br/>	address, err := conn.GetAccountByUUID(uuid)<br/><br/>	if err != nil {<br/>		return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{<br/>			"status":  "error",<br/>			"message": err,<br/>			"data":    nil,<br/>		})<br/>	}<br/><br/>	return c.Status(fiber.StatusOK).JSON(fiber.Map{<br/>		"status": "success",<br/>		"hash":   address.String(),<br/>	})<br/>}</span></pre><p id="b4d3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在区块链包中，添加<code class="eh lr ls lt lu b">GetAccountByUUID</code>方法来调用契约方法。</p><pre class="lv lw lx ly fq lz lu ma bn mb mc bi"><span id="e4d5" class="md kp ht lu b be me mf l mg mh">func (clientCon ClientConnection) GetAccountByUUID(uuid string) (*common.Address, error) {<br/><br/>	address, err := getFactory().Accounts(clientCon.callOpts, uuid)<br/><br/>	if err != nil {<br/>		log.Printf("Cannot get account: %v due to error %v", uuid, err)<br/><br/>		return new(common.Address), err<br/>	}<br/><br/>	return &amp;address, nil<br/>}</span></pre><p id="9a2e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">重启服务器并使用Postman向<a class="ae ki" href="http://127.0.0.1:3000/api/v1/factory/wallet/b93e42b0-33a2-11ed-a261-0242ac120002" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:3000/API/v1/factory/wallet/b 93 e 42 b 0-33 a2-11ed-a261-0242 AC 120002</a>发出GET请求。记得将UUID更改为您之前使用的那个，并注意返回的两个帐户地址。</p><p id="bcd2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在我自己的情况下，我返回的两个帐户地址是</p><figure class="lv lw lx ly fq iu"><div class="bz el l di"><div class="ml mm l"/></div></figure><h1 id="cfcb" class="ko kp ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">修复随机数过低错误</h1><p id="0794" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">到目前为止，您可能已经遇到了一个回复错误，返回的<strong class="jd hu"> nonce太低</strong>。如下所示，我花了一段时间才意识到我在将nonce设置为transact选项时引入了这个问题。要解决这个问题，只需添加下面的方法，并且在每个传递<code class="eh lr ls lt lu b">clientCon.trxOpts</code>的方法中，这意味着它是一个状态改变方法，调用它来增加下一个事务的nonce。</p><pre class="lv lw lx ly fq lz lu ma bn mb mc bi"><span id="e1df" class="md kp ht lu b be me mf l mg mh">func (clientCon ClientConnection) postTransact() {<br/>	clientCon.trxOpts.Nonce = new(big.Int).SetUint64(clientCon.nonceAt(clientCon.SignerPublicAddress))<br/>}</span></pre><p id="dfd6" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">用途</strong></p><pre class="lv lw lx ly fq lz lu ma bn mb mc bi"><span id="7660" class="md kp ht lu b be me mf l mg mh">func (clientCon ClientConnection) NewWallet(uuid string) (*types.Transaction, error) {<br/><br/>	trx, err := getFactory().NewCustodian(clientCon.trxOpts, uuid)<br/><br/>	if err != nil {<br/>		log.Printf("Cannot create new wallet: %v", err)<br/><br/>		return new(types.Transaction), err<br/>	}<br/><br/>	clientCon.postTransact()<br/><br/>	return trx, nil<br/>}</span></pre><h1 id="d2ba" class="ko kp ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">向USDC的帐户地址提供资金(模拟)</h1><p id="4fdd" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">打开Metamask并单击<strong class="jd hu"> import token </strong>，输入已部署的USDC地址，并确保对钱包地址执行此操作，您在env中将私钥用作部署者帐户。所有初始令牌都将分配给该帐户，请参见下图。</p><figure class="lv lw lx ly fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mn"><img src="../Images/603936da97319d3283733a16d782f480.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*9rfexc1cvVCtF8Px.png"/></div></div></figure><p id="9921" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">使用元掩码为这两个地址分配100个USDC。</p><h1 id="8d79" class="ko kp ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">打开P2P购买订单</h1><p id="dc29" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">该功能在钱包地址上直接可用。请记住，每个钱包都是一个智能合同，而不是你所期望的EOA。我们的部署者帐户拥有超级管理员权限来调用它的方法。</p><p id="da86" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这种方法利用了代理模式，因此，将来我们可以通过简单地升级钱包逻辑来为已经部署的钱包添加更多功能，钱包逻辑不会自行执行，而是通过使用已部署的钱包代理的状态通过<code class="eh lr ls lt lu b">delegatecall</code>调用其功能。</p><p id="b7ed" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">添加路线</strong></p><p id="bece" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这里的<code class="eh lr ls lt lu b">:address</code>参数是保管钱包的地址。</p><pre class="lv lw lx ly fq lz lu ma bn mb mc bi"><span id="ab20" class="md kp ht lu b be me mf l mg mh">api.Post("/wallet/order/new/:address", controllers.NewBuyOrder)</span></pre><p id="abda" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">添加控制器的方法</strong></p><pre class="lv lw lx ly fq lz lu ma bn mb mc bi"><span id="fbe2" class="md kp ht lu b be me mf l mg mh">func NewBuyOrder(c *fiber.Ctx) error {<br/>	conn := blockchain.CurrentConnection<br/>	request := new(blockchain.Order)<br/>	wallet := c.Params("address")<br/><br/>	blockchain.WalletAddress = wallet<br/><br/>	if err := c.BodyParser(request); err != nil {<br/>		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{<br/>			"status":  "error",<br/>			"message": "Malformed data",<br/>			"data":    err,<br/>		})<br/>	}<br/><br/>	trx, err := conn.OpenBuyOrder(*request)<br/><br/>	if err != nil {<br/>		return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{<br/>			"status":  "error",<br/>			"message": err,<br/>			"data":    nil,<br/>		})<br/>	}<br/><br/>	return c.Status(fiber.StatusOK).JSON(fiber.Map{<br/>		"status": "success",<br/>		"data":   trx.Hash(),<br/>	})<br/>}</span></pre><p id="1a03" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">最后在区块链包裹的<code class="eh lr ls lt lu b">wallet.go</code>里面。</p><pre class="lv lw lx ly fq lz lu ma bn mb mc bi"><span id="6d20" class="md kp ht lu b be me mf l mg mh">func (clientCon ClientConnection) OpenBuyOrder(order Order) (*types.Transaction, error) {<br/><br/>	trx, err := getWalletLogic().NewBuyOrder(<br/>		clientCon.trxOpts,<br/>		common.HexToAddress(order.Seller),<br/>		common.HexToAddress(order.Receiver),<br/>		big.NewInt(order.Amount),<br/>		big.NewInt(order.Rate),<br/>		big.NewInt(order.Fee),<br/>	)<br/><br/>	if err != nil {<br/>		log.Printf("Cannot open order : %v", err)<br/><br/>		return new(types.Transaction), err<br/>	}<br/><br/>	clientCon.postTransact()<br/><br/>	return trx, nil<br/>}</span></pre><p id="14c4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">使用Postman向<a class="ae ki" href="http://127.0.0.1:3000/api/v1/wallet/order/new/0xC1F07Db647Aa3002c12BbaF8D598F0ef19c4ddd3" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:3000/API/v1/wallet/order/new/0x C1 f 07 db 647 aa 3002 c 12 BBA F8 d 598 f 0 ef 19 C4 DDD 3</a>发出POST请求将返回事务哈希。</p><p id="218c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">请记住用适用于您的参数替换URL中的钱包地址参数。</p><h1 id="3a11" class="ko kp ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">获取未结订单后的账户总余额</h1><p id="7fde" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">终于到最后一点了！</p><p id="bab6" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">钱包合同的<code class="eh lr ls lt lu b">GetTotalBalance</code>返回钱包余额减去当前未完成的订单，因此一旦我们打开订单，我们不希望他们花费和无法履行订单。</p><p id="2dd2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">添加路线</strong></p><pre class="lv lw lx ly fq lz lu ma bn mb mc bi"><span id="4cbc" class="md kp ht lu b be me mf l mg mh">api.Post("/wallet/balance/:address", controllers.GetWalletUSDCBalance)</span></pre><p id="aabb" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">添加控制器方法</strong></p><p id="0af7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在<code class="eh lr ls lt lu b">wallet_controller</code>添加</p><pre class="lv lw lx ly fq lz lu ma bn mb mc bi"><span id="e52a" class="md kp ht lu b be me mf l mg mh">func GetWalletUSDCBalance(c *fiber.Ctx) error {  <br/>  conn := blockchain.CurrentConnection  <br/>  walletAddress := c.Params("address")  <br/>  <br/>   blockchain.WalletAddress = walletAddress  <br/>  <br/>   balance, err := conn.GetUSDCBalance()  <br/>  <br/>   if err != nil {  <br/>      return c.Status(fiber.StatusUnauthorized).JSON(fiber.Map{  <br/>         "status":  "error",  <br/>         "message": err,  <br/>         "data":    nil,  <br/>      })  <br/>   }  <br/>  <br/>  <br/>   return c.Status(fiber.StatusOK).JSON(fiber.Map{  <br/>      "status": "success",  <br/>      "data":   balance,  <br/>   })  <br/>}</span></pre><p id="fc08" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在在区块链包的<code class="eh lr ls lt lu b">wallet.go</code>中添加<code class="eh lr ls lt lu b">GetUSDCBalance</code>方法。</p><pre class="lv lw lx ly fq lz lu ma bn mb mc bi"><span id="d891" class="md kp ht lu b be me mf l mg mh">func (clientCon ClientConnection) GetUSDCBalance() (*big.Int, error) {<br/><br/>	balance, err := getWalletLogic().GetTotalBalance(clientCon.callOpts)<br/><br/>	if err != nil {<br/>		log.Printf("Cannot open order : %v", err)<br/><br/>		return new(big.Int), err<br/>	}<br/><br/>	return balance, nil<br/>}</span></pre><p id="5c48" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">使用Postman向<a class="ae ki" href="http://127.0.0.1:3000/api/v1/wallet/balance/0xC1F07Db647Aa3002c12BbaF8D598F0ef19c4ddd3" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:3000/API/v1/wallet/balance/0x C1 f 07 db 647 aa 3002 c 12 BBA F8 d 598 f 0 ef 19 C4 DDD 3</a>发出POST请求。钱包余额被返回。</p><p id="74e4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">恭喜你！！🎉🎉</p><p id="cfed" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">谢谢你一直关注我，如果你喜欢这篇文章，你可以为这篇文章鼓掌并订阅我的youtube频道来支持我。</p><blockquote class="mo"><p id="aa4e" class="mp mq ht bd mr ms mt mu mv mw mx jy ek translated">交易新手？尝试<a class="ae ki" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae ki" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>