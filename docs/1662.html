<html>
<head>
<title>Learn Solidity lesson 14. Arrays.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习第14课坚固性。数组。</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/learn-solidity-lesson-14-arrays-64111b18fa07?source=collection_archive---------4-----------------------#2022-08-03">https://medium.com/coinmonks/learn-solidity-lesson-14-arrays-64111b18fa07?source=collection_archive---------4-----------------------#2022-08-03</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/fb22de177e23ed74e640f0bdeb2e3810.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_Dos8u_roASE7ViWFRuuTg.jpeg"/></div></div></figure><p id="e1f7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">数组</strong>是编程语言中广泛使用的数据结构。它是价值观的集合，在坚固性上是同类型价值观的集合。</p><p id="9368" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">例如，整数数组是整数值的集合。字符串数组是字符串类型的值的集合。集合是有序的，因此每个值都放在数组中的某个位置(我们称之为索引)。</p><p id="06a9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">solidity中有两种类型的数组:静态数组和动态数组。在静态数组中，存储值的数量在数组声明时定义。至于动态数组，没有定义值的总数，可以动态添加新值。</p><p id="fa83" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们首先创建一个uint类型的数组，如下面的代码所示。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="7308" class="ki kj ht ke b fv kk kl l km kn">uint[5] staticArray;</span></pre><p id="03e0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">上面创建的数组是一个静态数组，我们定义它将存储5个类型为<em class="ko"> uint </em>的值。要创建一个动态数组，不要包括数组的大小，如下面的语句所示。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="6861" class="ki kj ht ke b fv kk kl l km kn">uint[] dynamicArray;</span></pre><p id="0a52" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">静态数组在声明时被初始化。变量<code class="eh kp kq kr ke b">staticArray</code>包含5个类型为<em class="ko"> uint </em>的值，这5个值用默认值<code class="eh kp kq kr ke b">0</code>初始化。</p><p id="65a7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果未初始化，动态数组假定初始大小为0项。动态数组中的每个新项在被添加到数组中时都会被初始化。</p><h1 id="eb95" class="ks kj ht bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo dt translated">初始化数组</h1><p id="39e5" class="pw-post-body-paragraph jb jc ht jd b je lp jg jh ji lq jk jl jm lr jo jp jq ls js jt ju lt jw jx jy hm dt translated">可以在声明数组值的同时初始化数组。下面的声明用5个值初始化静态数组。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="b7e7" class="ki kj ht ke b fv kk kl l km kn">uint[5] staticArray = [10, 20, 30, 40, 50];</span></pre><p id="6b83" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">动态数组也是如此。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="d061" class="ki kj ht ke b fv kk kl l km kn">uint[] dynamicArray = [10, 20, 30, 40, 50];</span></pre><p id="cfcb" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">两个数组现在都存储了5个项目，但是我们可以向动态数组添加新项目，而静态数组不接收新项目。我们能做的就是改变它的值。</p><p id="c424" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">还有另一种初始化数组的方法，使用<strong class="jd hu">新的</strong>构造函数。让我们在下面的声明中看到这一点。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="149b" class="ki kj ht ke b fv kk kl l km kn">uint[] dynamicArray = new uint[](5);</span></pre><p id="4775" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">因此，数组中的前五项被初始化为它们的默认值。不可能对静态数组使用<em class="ko"> new </em>构造函数，也没有意义，因为它们的项在声明时已经初始化了。</p><h1 id="4539" class="ks kj ht bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo dt translated">内存中的数组</h1><p id="9aea" class="pw-post-body-paragraph jb jc ht jd b je lp jg jh ji lq jk jl jm lr jo jp jq ls js jt ju lt jw jx jy hm dt translated">内存中的数组与存储中的数组行为不同。一旦定义了它们在内存中将要占据的空间，这个空间就不能被拉伸。也就是说，不可能在内存中创建动态数组。</p><p id="8a90" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">下面的代码，在函数内部，是有效的，但是无害的。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="742b" class="ki kj ht ke b fv kk kl l km kn">uint[] memory newArray;</span></pre><p id="cca8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在内存中创建了一个动态数组，但是由于它没有初始化，所以它的大小为0。由于不能放大，它的大小将始终为0。</p><p id="30c8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">要在内存中创建新数组，必须用构造函数将其声明为静态数组或动态数组。下面的代码显示了这两种方式。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="034b" class="ki kj ht ke b fv kk kl l km kn">uint[3] memory staticArrayMemory;<br/>uint[] memory dynamicArrayMemory = new uint[](3);</span></pre><h1 id="48c4" class="ks kj ht bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo dt translated">管理阵列</h1><p id="2210" class="pw-post-body-paragraph jb jc ht jd b je lp jg jh ji lq jk jl jm lr jo jp jq ls js jt ju lt jw jx jy hm dt translated">可以使用文字来改变数组。正如我们已经看到的，文字是类型的表示。数组文字是一组用方括号括起来的值，用逗号分隔。在下面的代码中，我们使用文字来改变数组。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="0015" class="ki kj ht ke b fv kk kl l km kn">dynamicArray = [1, 2, 3, 4, 5, 6, 7];</span></pre><p id="201b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">变量<code class="eh kp kq kr ke b">dynamicArray </code>是存储中的一个数组，我们用5个条目对其进行了初始化。现在我们改变这个变量来存储一个7项的数组。因为它是一个动态数组，所以没有问题。如果是静态数组，编译器会抛出一个错误。</p><p id="5f75" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">更常见的是更改数组中的单个值。为了访问数组中的一个项目，我们使用方括号，如下所示。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="3b25" class="ki kj ht ke b fv kk kl l km kn">dynamicArray[3] // access to the fourth item in the array</span></pre><p id="2db3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当数组的索引在<code class="eh kp kq kr ke b">0</code>开始计数时，索引<code class="eh kp kq kr ke b">3</code>对应于第四项。要改变与索引相对应的数组的值，只需像其他变量一样赋值即可。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="cb71" class="ki kj ht ke b fv kk kl l km kn">dynamicArray[3] = newValue;</span></pre><p id="40b7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">动态数组有两种操作方法。<strong class="jd hu"> push() </strong>方法在数组的最后一项后添加一个新元素，如下所示。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="3509" class="ki kj ht ke b fv kk kl l km kn">dynamicArray.push(6) // includes a new item of value 6 at the end of the array</span></pre><p id="0615" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">方法从数组中移除最后一项。push()和pop()都会改变数组的大小。也可以使用<strong class="jd hu"> delete </strong>操作符将给定的数组索引更改为默认值，如下所示。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="13a0" class="ki kj ht ke b fv kk kl l km kn">delete dynamicArray[3] // makes the value of index 3 return to its default value</span></pre><p id="febf" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">注意，delete操作符并不删除该项，它只是改变它的值。上述操作的结果与将值<code class="eh kp kq kr ke b">0</code>赋给<code class="eh kp kq kr ke b">dynamicArray[3]</code>相同。</p><p id="e968" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">数组具有长度属性，该属性返回数组的大小。</p><h1 id="80b6" class="ks kj ht bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo dt translated">特殊数组</h1><p id="b196" class="pw-post-body-paragraph jb jc ht jd b je lp jg jh ji lq jk jl jm lr jo jp jq ls js jt ju lt jw jx jy hm dt translated">坚固性有两种类型，基本上是特殊的数组:字符串和字节。数组是引用类型，所以字符串和字节也是引用类型。</p><p id="36a7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们可以认为字符串是一个字符数组，但它实际上是一个字节数组。它的行为与动态数组不同。例如，我们不能将<em class="ko"> push </em>和<em class="ko"> pop </em>操作符应用于字符串，并且<em class="ko"> length </em>属性甚至不存在于字符串中。</p><p id="ce5b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">Solidity中的字符串操作不像大多数其他编程语言那样简单，但有外部库可以帮助我们完成这项工作。</p><p id="2464" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">类型<strong class="jd hu">字节</strong>也是一种特殊类型的数组，一个字节数组。它与数组<em class="ko"> bytes1[] </em>有相似之处，后者显式地是1字节类型的数组，但是字节类型占用的内存更少。</p><p id="a1c6" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在下面的代码中，我将展示bytes类型的用法，正如我将展示string类型是一个字节数组一样。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="6d3a" class="ki kj ht ke b fv kk kl l km kn">function stringToBytes() public view returns(bytes memory) {<br/>   string memory name = unicode"João";<br/>   bytes memory nameToBytes = bytes(name);<br/>   return nameToBytes;<br/>}</span></pre><p id="51fc" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在函数内部，我首先在内存中创建一个字符串。我需要使用前缀<em class="ko"> unicode </em>，以便Solidity接受字母<code class="eh kp kq kr ke b"> ‘a’</code>的重音。然后我创建一个bytes类型的变量，它将接收string类型的变量的字节。为此，我们需要将变量从字符串类型转换为字节类型。下图可以看到函数返回。</p><figure class="jz ka kb kc fq iu fe ff paragraph-image"><div class="fe ff lu"><img src="../Images/b46b2fdabf38dabbda2d07187475910b.png" data-original-src="https://miro.medium.com/v2/resize:fit:736/format:webp/1*ADqpJx6c_OjtaugiVHqsQA.png"/></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">Converting strings to bytes.</figcaption></figure><p id="bb6a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这是什么回报？它是用UTF-8编码的字符串“joo ”,这是Solidity使用的标准。有几个网站，你可以很容易地编码/解码字符串到UTF 8。在下图中，我以其中一个网站为例。</p><figure class="jz ka kb kc fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff lz"><img src="../Images/bafc9611abc2edeb9d69199cc680318a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*D4I8xwi0HStmlY8mnArfVA.png"/></div></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">Strings is an array of bytes with UTF-8 encoding.</figcaption></figure><p id="19d5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">字节类型比字符串类型更具延展性，因为它接受使用像<em class="ko"> push </em>和<em class="ko"> pop </em>这样的方法。让我们看看下面的代码。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="c185" class="ki kj ht ke b fv kk kl l km kn">bytes public name = unicode"Joã";</span><span id="95f3" class="ki kj ht ke b fv ma kl l km kn">function bytesAsStrings() public {<br/>   bytes1 letter = 0x6f;<br/>   name.push(letter);<br/>}</span></pre><p id="10a9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">bytes类型接受字符串作为赋值，Solidity自动将字符串转换为UTF-8格式。注意，该函数向数组中添加了一个新字节，相当于字母<code class="eh kp kq kr ke b">‘o’</code>。使用字符串类型不可能做到这一点。</p><p id="36ef" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">随着课程的进展，我们将更多地使用数组。</p><p id="a3f1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">感谢阅读！</strong></p><p id="f5bd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎对本文提出意见和建议。</p><p id="df95" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎任何投稿。<a class="ae mb" href="http://www.buymeacoffee.com/jpmorais" rel="noopener ugc nofollow" target="_blank">www.buymeacoffee.com/jpmorais</a></p><blockquote class="mc"><p id="580f" class="md me ht bd mf mg mh mi mj mk ml jy ek translated">交易新手？尝试<a class="ae mb" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae mb" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>