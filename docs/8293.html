<html>
<head>
<title>OpenZeppelins ERC20.sol Contract deep dive</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">OpenZeppelins ERC20.sol合同深潜</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/openzeppelins-erc20-sol-contract-deep-dive-8294d15ea403?source=collection_archive---------17-----------------------#2022-12-30">https://medium.com/coinmonks/openzeppelins-erc20-sol-contract-deep-dive-8294d15ea403?source=collection_archive---------17-----------------------#2022-12-30</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><h1 id="f964" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">ERC20标准</h1><p id="0642" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">ERC20标准是一组规则，定义了令牌在以太坊区块链上的行为方式。它指定了令牌协定必须实现的一组功能和事件，以便被视为ERC20令牌。开发该标准是为了确保不同的令牌可以互换，并且可以以类似的方式使用，而不管契约的具体实现如何。</p><h1 id="ceb0" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">OpenZeppelins ERC20合同</h1><p id="f613" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">OpenZeppelin的ERC20契约是由OpenZeppelin库提供的ERC20标准的开源实现。这是一份可靠的合同，可以作为构建您自己的ERC20令牌的起点。该契约包括ERC20标准中定义的所有必需的功能和事件，以及一些标准不要求但在ERC20令牌中常用的附加功能。</p><h1 id="c6b6" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">open zeppelin er C20合同的使用案例</h1><p id="c9f9" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">OpenZeppelin的ERC20合同的用例包括构建和部署您自己的ERC20令牌，使用该合同作为参考实现来了解ERC20令牌的工作方式，并在该合同的基础上为您的令牌添加附加功能。</p><h1 id="791c" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">ERC20标准和OpenZeppelin实现的区别</h1><p id="c6f2" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">普通ERC20标准和OpenZeppelin实现之间的主要区别在于，后者包含了超出标准最低要求的附加特性和功能。这些附加功能包括铸造和刻录令牌的功能，以及各种访问控制功能，这些功能允许您设置谁可以传输和管理令牌的限制。</p><h1 id="6e9b" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">使用OpenZeppelin的ERC20合同的优势</h1><p id="e576" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">使用OpenZeppelin的ERC20合同的一些优势包括:它是ERC20标准的一个经过充分测试和广泛使用的实现，它包括超出标准最低要求的附加特性和功能，并且它是开源的，可以自由使用和修改。此外，OpenZeppelin提供了一系列其他合同和工具，可以与ERC20合同结合使用，以构建更复杂、功能更丰富的令牌系统。</p><h1 id="0fc8" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">合同的预演</h1><pre class="km kn ko kp fq kq kr ks bn kt ku bi"><span id="83f9" class="kv ir ht kr b be kw kx l ky kz">// SPDX-License-Identifier: MIT</span></pre><p id="49fb" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated">行<code class="eh lf lg lh kr b"><strong class="jq hu">// SPDX-License-Identifier: MIT</strong></code>是一个注释，指的是MIT许可证的SPDX许可证标识符。</p><pre class="km kn ko kp fq kq kr ks bn kt ku bi"><span id="6f0a" class="kv ir ht kr b be kw kx l ky kz">pragma solidity ^0.4.24;</span></pre><p id="63f2" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated">在Solidity中，<code class="eh lf lg lh kr b"><strong class="jq hu">pragma</strong></code>是一个指令，它指定了用来编写合同的Solidity版本。<code class="eh lf lg lh kr b"><strong class="jq hu">pragma</strong></code>指令通常放在Solidity文件的顶部，指示编译合同所需的Solidity的最低版本。</p><pre class="km kn ko kp fq kq kr ks bn kt ku bi"><span id="db0c" class="kv ir ht kr b be kw kx l ky kz">import "./IERC20.sol";<br/>import "../../math/SafeMath.sol";</span></pre><p id="5a16" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">import</strong></code>指令用于将另一个实体文件中的代码包含在当前文件中。这通常用于包含外部库或在契约之间重用代码。</p><p id="2e14" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated">在OpenZeppelin ERC20契约中，<code class="eh lf lg lh kr b"><strong class="jq hu">import</strong></code>指令用于包含<code class="eh lf lg lh kr b"><strong class="jq hu">IERC20.sol</strong></code>和<code class="eh lf lg lh kr b"><strong class="jq hu">SafeMath.sol</strong></code>文件。</p><ul class=""><li id="acf2" class="li lj ht jq b jr la jv lb jz lk kd ll kh lm kl ln lo lp lq dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">IERC20.sol</strong></code>文件定义了ERC20令牌标准的接口，其中包括ERC20令牌必须实现的必需和可选功能。OpenZeppelin ERC20契约实现了这个接口，这允许它被其他契约和应用程序识别为ERC20令牌。</li><li id="85b8" class="li lj ht jq b jr lr jv ls jz lt kd lu kh lv kl ln lo lp lq dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">SafeMath.sol</strong></code>文件定义了一组数学函数，用于防止在处理大整数值时发生整数溢出和下溢。OpenZeppelin ERC20契约使用这些函数来确保对<code class="eh lf lg lh kr b"><strong class="jq hu">uint256</strong></code>值执行算术运算是安全的。</li></ul><pre class="km kn ko kp fq kq kr ks bn kt ku bi"><span id="a466" class="kv ir ht kr b be kw kx l ky kz">contract ERC20 is IERC20 {</span></pre><p id="734d" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated">在Solidity中，<code class="eh lf lg lh kr b"><strong class="jq hu">contract</strong></code>关键字用于定义一个新的合同。</p><p id="b923" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated">声明的<code class="eh lf lg lh kr b"><strong class="jq hu">is IERC20</strong></code>部分表示<code class="eh lf lg lh kr b"><strong class="jq hu">ERC20</strong></code>契约实现了<code class="eh lf lg lh kr b"><strong class="jq hu">IERC20</strong></code>接口。</p><p id="0b75" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated">Solidity中的接口是一个契约，它定义了一组函数及其签名，但不提供这些函数的实现。接口通常用于指定其他契约必须遵循的一组通用规则或行为。</p><p id="9db4" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated">在这种情况下，<code class="eh lf lg lh kr b"><strong class="jq hu">IERC20</strong></code>接口定义了ERC20令牌必须实现的必需和可选功能。通过声明<code class="eh lf lg lh kr b"><strong class="jq hu">ERC20</strong></code>契约实现了<code class="eh lf lg lh kr b"><strong class="jq hu">IERC20</strong></code>接口，该契约表明它将为<code class="eh lf lg lh kr b"><strong class="jq hu">IERC20</strong></code>接口中定义的所有功能提供一个实现。</p><pre class="km kn ko kp fq kq kr ks bn kt ku bi"><span id="8c56" class="kv ir ht kr b be kw kx l ky kz">using SafeMath for uint256;</span></pre><p id="165f" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated">在Solidity中，<code class="eh lf lg lh kr b"><strong class="jq hu">uint256</strong></code>是一个无符号整数类型，可以保存从0到2^256 - 1的值。<code class="eh lf lg lh kr b"><strong class="jq hu">SafeMath</strong></code>库是一个数学函数集合，旨在防止在对<code class="eh lf lg lh kr b"><strong class="jq hu">uint256</strong></code>值执行算术运算时发生整数溢出和下溢。</p><p id="162f" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated">为<code class="eh lf lg lh kr b"><strong class="jq hu">uint256</strong></code>使用<code class="eh lf lg lh kr b"><strong class="jq hu">SafeMath</strong></code>库意味着你正在使用库提供的算术函数的安全版本，而不是内置的可靠性函数。例如，您可以使用<code class="eh lf lg lh kr b"><strong class="jq hu">SafeMath</strong></code>库中的<code class="eh lf lg lh kr b"><strong class="jq hu">add</strong></code>函数，而不是使用内置的<code class="eh lf lg lh kr b"><strong class="jq hu">+</strong></code>运算符将两个<code class="eh lf lg lh kr b"><strong class="jq hu">uint256</strong></code>值相加。</p><p id="de58" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated">使用<code class="eh lf lg lh kr b"><strong class="jq hu">SafeMath</strong></code>函数可以帮助保护您的契约免受因整数溢出或下溢而导致的漏洞的影响。在Solidity中处理大整数值时，使用<code class="eh lf lg lh kr b"><strong class="jq hu">SafeMath</strong></code>库是一个很好的实践。</p><pre class="km kn ko kp fq kq kr ks bn kt ku bi"><span id="f23d" class="kv ir ht kr b be kw kx l ky kz">mapping (address =&gt; uint256) private _balances;<br/><br/>mapping (address =&gt; mapping (address =&gt; uint256)) private _allowed;<br/><br/>uint256 private _totalSupply;</span></pre><p id="90d7" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated">OpenZeppelin ERC20契约中的<code class="eh lf lg lh kr b"><strong class="jq hu">_balances</strong></code>映射是一个私有变量，用于存储每个用户的余额。该映射由用户的以太坊地址决定，其值是用户在令牌中的余额。</p><p id="c7ca" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">_allowed</strong></code>映射是一个私有变量，用于存储每个用户代表另一个用户传输令牌的权限。该映射由正在存储其许可的用户的以太坊地址键控，并且该值是由被授权代表第一用户传送令牌的用户的以太坊地址键控的另一个映射。这个内部映射的值是允许第二用户代表第一用户传送令牌。</p><p id="5b99" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">_totalSupply</strong></code>变量是一个私有变量，用于存储已经创建的令牌总数。</p><p id="e040" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated">这些变量用于跟踪用户的余额和限额以及已创建的令牌总数。它们是私有变量，这意味着只能从协定内部或从它的继承协定中访问它们。</p><pre class="km kn ko kp fq kq kr ks bn kt ku bi"><span id="7993" class="kv ir ht kr b be kw kx l ky kz">function totalSupply() public view returns (uint256) {<br/>    return _totalSupply;<br/>  }</span></pre><p id="410c" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">totalSupply</strong></code>功能是一个公共查看功能，允许用户查看代币的总供应量。该函数不接受任何参数。</p><p id="f80f" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated">该函数只是返回令牌的总供应量。</p><p id="08ca" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated">它是一个公共视图函数，这意味着它可以被任何契约或外部参与者调用，并且不修改契约的状态。视图函数通常用于从合同中读取数据，而不会产生完整事务的开销。</p><pre class="km kn ko kp fq kq kr ks bn kt ku bi"><span id="e2f7" class="kv ir ht kr b be kw kx l ky kz">function balanceOf(address owner) public view returns (uint256) {<br/>    return _balances[owner];<br/>  }</span></pre><p id="126e" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">balanceOf</strong></code>功能是一个公共查看功能，允许一个用户查看另一个用户的余额。该函数有一个参数:</p><ol class=""><li id="786f" class="li lj ht jq b jr la jv lb jz lk kd ll kh lm kl lw lo lp lq dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">owner</strong></code>:您要查看其余额的用户的以太坊地址。</li></ol><p id="bc1b" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated">该函数只是返回<code class="eh lf lg lh kr b"><strong class="jq hu">owner</strong></code>地址的余额。</p><pre class="km kn ko kp fq kq kr ks bn kt ku bi"><span id="6bc4" class="kv ir ht kr b be kw kx l ky kz">function allowance(<br/>    address owner,<br/>    address spender<br/>   )<br/>    public<br/>    view<br/>    returns (uint256)<br/>  {<br/>    return _allowed[owner][spender];<br/>  }</span></pre><p id="ea65" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">allowance</strong></code>功能是一个公共查看功能，允许一个用户查看另一个用户代表他们转移代币的许可。该函数有两个参数:</p><ol class=""><li id="dc29" class="li lj ht jq b jr la jv lb jz lk kd ll kh lm kl lw lo lp lq dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">owner</strong></code>:主人的以太坊地址。</li><li id="686b" class="li lj ht jq b jr lr jv ls jz lt kd lu kh lv kl lw lo lp lq dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">spender</strong></code>:挥霍者的以太坊地址。</li></ol><p id="51de" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated">该函数简单地返回允许<code class="eh lf lg lh kr b"><strong class="jq hu">spender</strong></code>地址代表<code class="eh lf lg lh kr b"><strong class="jq hu">owner</strong></code>地址传输令牌。</p><pre class="km kn ko kp fq kq kr ks bn kt ku bi"><span id="6e41" class="kv ir ht kr b be kw kx l ky kz">function transfer(address to, uint256 value) public returns (bool) {<br/>    require(value &lt;= _balances[msg.sender]);<br/>    require(to != address(0));<br/><br/>    _balances[msg.sender] = _balances[msg.sender].sub(value);<br/>    _balances[to] = _balances[to].add(value);<br/>    emit Transfer(msg.sender, to, value);<br/>    return true;<br/>  }</span></pre><p id="e6bc" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">transfer</strong></code>功能是一个公共功能，允许用户将指定数量的代币从自己的余额转移到另一个用户的余额。该函数有两个参数:</p><ol class=""><li id="4f61" class="li lj ht jq b jr la jv lb jz lk kd ll kh lm kl lw lo lp lq dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">to</strong></code>:要增加余额的用户的以太坊地址。</li><li id="830f" class="li lj ht jq b jr lr jv ls jz lt kd lu kh lv kl lw lo lp lq dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">value</strong></code>:您要转移的代币数量。</li></ol><p id="91d0" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated">该功能首先检查<code class="eh lf lg lh kr b"><strong class="jq hu">value</strong></code>参数是否小于或等于调用者的余额(<code class="eh lf lg lh kr b"><strong class="jq hu">msg.sender</strong></code>)以及<code class="eh lf lg lh kr b"><strong class="jq hu">to</strong></code>地址是否不是零地址(<code class="eh lf lg lh kr b"><strong class="jq hu">0x0</strong></code>)。如果这些检查中的任何一个失败，该函数将抛出一个错误并退出。</p><p id="04e4" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated">如果检查通过，该函数将调用者的余额减少指定的<code class="eh lf lg lh kr b"><strong class="jq hu">value</strong></code>，并将<code class="eh lf lg lh kr b"><strong class="jq hu">to</strong></code>地址的余额增加相同的数量。然后，它发出一个<code class="eh lf lg lh kr b"><strong class="jq hu">Transfer</strong></code>事件来表明传输已经发生。</p><p id="e872" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">transfer</strong></code>功能是在用户之间转移代币的主要功能，用于将代币从一个用户的余额直接转移到另一个用户的余额。</p><pre class="km kn ko kp fq kq kr ks bn kt ku bi"><span id="351f" class="kv ir ht kr b be kw kx l ky kz">/**<br/>   * Beware that changing an allowance with this method brings the risk that someone may use both the old<br/>   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this<br/>   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:<br/>   */<br/>  function approve(address spender, uint256 value) public returns (bool) {<br/>    require(spender != address(0));<br/><br/>    _allowed[msg.sender][spender] = value;<br/>    emit Approval(msg.sender, spender, value);<br/>    return true;<br/>  }</span></pre><p id="2c39" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">approve</strong></code>功能是一个公共功能，允许一个用户授权另一个用户代表他们转移指定数量的令牌。该函数有两个参数:</p><ol class=""><li id="b91c" class="li lj ht jq b jr la jv lb jz lk kd ll kh lm kl lw lo lp lq dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">spender</strong></code>:您要授权代表您转移代币的用户的以太坊地址。</li><li id="0a9a" class="li lj ht jq b jr lr jv ls jz lt kd lu kh lv kl lw lo lp lq dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">value</strong></code>:您要授权<code class="eh lf lg lh kr b"><strong class="jq hu">spender</strong></code>转移的令牌数量。</li></ol><p id="41ae" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated">该功能首先检查<code class="eh lf lg lh kr b"><strong class="jq hu">spender</strong></code>地址不是零地址(<code class="eh lf lg lh kr b"><strong class="jq hu">0x0</strong></code>)。如果检查失败，该函数将抛出一个错误并退出。</p><p id="baf1" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated">如果检查通过，该函数设置<code class="eh lf lg lh kr b"><strong class="jq hu">spender</strong></code>地址的允许值，以代表调用者(<code class="eh lf lg lh kr b"><strong class="jq hu">msg.sender</strong></code>)向指定的<code class="eh lf lg lh kr b"><strong class="jq hu">value</strong></code>传送令牌。然后，它会发出一个<code class="eh lf lg lh kr b"><strong class="jq hu">Approval</strong></code>事件，表示津贴已经更新。</p><p id="3011" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">approve</strong></code>功能通常与<code class="eh lf lg lh kr b"><strong class="jq hu">transferFrom</strong></code>功能结合使用，以允许用户授权其他地址代表他们传输令牌。</p><pre class="km kn ko kp fq kq kr ks bn kt ku bi"><span id="fc78" class="kv ir ht kr b be kw kx l ky kz">function transferFrom(<br/>    address from,<br/>    address to,<br/>    uint256 value<br/>  )<br/>    public<br/>    returns (bool)<br/>  {<br/>    require(value &lt;= _balances[from]);<br/>    require(value &lt;= _allowed[from][msg.sender]);<br/>    require(to != address(0));<br/><br/>    _balances[from] = _balances[from].sub(value);<br/>    _balances[to] = _balances[to].add(value);<br/>    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);<br/>    emit Transfer(from, to, value);<br/>    return true;<br/>  }</span></pre><p id="28da" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">transferFrom</strong></code>功能是一个公共功能，允许用户将指定数量的代币从另一个用户的余额转移到第三个用户的余额。该函数有三个参数:</p><ol class=""><li id="968c" class="li lj ht jq b jr la jv lb jz lk kd ll kh lm kl lw lo lp lq dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">from</strong></code>:您要减少余额的用户的以太坊地址。</li><li id="e4ba" class="li lj ht jq b jr lr jv ls jz lt kd lu kh lv kl lw lo lp lq dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">to</strong></code>:要增加余额的用户的以太坊地址。</li><li id="c62b" class="li lj ht jq b jr lr jv ls jz lt kd lu kh lv kl lw lo lp lq dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">value</strong></code>:您要转移的代币数量。</li></ol><p id="6d21" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated">该功能首先检查<code class="eh lf lg lh kr b"><strong class="jq hu">value</strong></code>参数是否小于或等于<code class="eh lf lg lh kr b"><strong class="jq hu">from</strong></code>地址的余额，以及是否小于或等于调用者(<code class="eh lf lg lh kr b"><strong class="jq hu">msg.sender</strong></code>)代表<code class="eh lf lg lh kr b"><strong class="jq hu">from</strong></code>地址传送令牌的许可。它还检查<code class="eh lf lg lh kr b"><strong class="jq hu">spender</strong></code>地址不是零地址(<code class="eh lf lg lh kr b"><strong class="jq hu">0x0</strong></code>)。如果这些检查中的任何一项失败，该函数将抛出一个错误并退出。</p><p id="b5ac" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated">如果检查通过，该功能将按指定的<code class="eh lf lg lh kr b"><strong class="jq hu">value</strong></code>减少<code class="eh lf lg lh kr b"><strong class="jq hu">from</strong></code>地址的余额，并按相同的量增加<code class="eh lf lg lh kr b"><strong class="jq hu">to</strong></code>地址的余额。它还减少了调用者通过<code class="eh lf lg lh kr b"><strong class="jq hu">value</strong></code>代表<code class="eh lf lg lh kr b"><strong class="jq hu">from</strong></code>地址传输令牌的许可。最后，它发出一个<code class="eh lf lg lh kr b"><strong class="jq hu">Transfer</strong></code>事件来指示传输已经发生。</p><p id="410e" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">transferFrom</strong></code>功能通常与<code class="eh lf lg lh kr b"><strong class="jq hu">approve</strong></code>功能结合使用，以允许用户授权其他地址代表他们传输令牌。</p><pre class="km kn ko kp fq kq kr ks bn kt ku bi"><span id="9e6d" class="kv ir ht kr b be kw kx l ky kz">function increaseAllowance(<br/>    address spender,<br/>    uint256 addedValue<br/>  )<br/>    public<br/>    returns (bool)<br/>  {<br/>    require(spender != address(0));<br/><br/>    _allowed[msg.sender][spender] = (<br/>      _allowed[msg.sender][spender].add(addedValue));<br/>    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);<br/>    return true;<br/>  }</span></pre><p id="b463" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">increaseAllowance</strong></code>功能是一个公共功能，允许一个用户增加另一个用户代表他们转移代币的许可。该函数有两个参数:</p><ol class=""><li id="73ca" class="li lj ht jq b jr la jv lb jz lk kd ll kh lm kl lw lo lp lq dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">spender</strong></code>:您要增加其权限的用户的以太坊地址。</li><li id="2518" class="li lj ht jq b jr lr jv ls jz lt kd lu kh lv kl lw lo lp lq dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">addedValue</strong></code>:您想要增加津贴的数量。</li></ol><p id="bcd1" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated">该功能首先检查<code class="eh lf lg lh kr b"><strong class="jq hu">spender</strong></code>地址不是零地址(<code class="eh lf lg lh kr b"><strong class="jq hu">0x0</strong></code>)。如果检查失败，该函数将抛出一个错误并退出。</p><p id="6cfa" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated">如果检查通过，该函数增加指定的<code class="eh lf lg lh kr b"><strong class="jq hu">addedValue</strong></code>代表调用者<code class="eh lf lg lh kr b"><strong class="jq hu">msg.sender</strong></code>传送令牌的<code class="eh lf lg lh kr b"><strong class="jq hu">spender</strong></code>地址的许可。然后，它发出一个<code class="eh lf lg lh kr b"><strong class="jq hu">Approval</strong></code>事件，表明津贴已经更新。</p><p id="f936" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">increaseAllowance</strong></code>功能通常与<code class="eh lf lg lh kr b"><strong class="jq hu">decreaseAllowance</strong></code>功能结合使用，以允许用户调整另一个用户代表他们转移代币的许可。</p><pre class="km kn ko kp fq kq kr ks bn kt ku bi"><span id="a092" class="kv ir ht kr b be kw kx l ky kz">function decreaseAllowance(<br/>    address spender,<br/>    uint256 subtractedValue<br/>  )<br/>    public<br/>    returns (bool)<br/>  {<br/>    require(spender != address(0));<br/><br/>    _allowed[msg.sender][spender] = (<br/>      _allowed[msg.sender][spender].sub(subtractedValue));<br/>    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);<br/>    return true;<br/>  }</span></pre><p id="06f3" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">decreaseAllowance</strong></code>功能是一个公共功能，允许一个用户减少另一个用户代表他们转移代币的许可。该函数有两个参数:</p><ol class=""><li id="d83f" class="li lj ht jq b jr la jv lb jz lk kd ll kh lm kl lw lo lp lq dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">spender</strong></code>:您要减少其津贴的用户的以太坊地址。</li><li id="e0a5" class="li lj ht jq b jr lr jv ls jz lt kd lu kh lv kl lw lo lp lq dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">subtractedValue</strong></code>:您希望减少津贴的数量。</li></ol><p id="a459" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated">该功能首先检查<code class="eh lf lg lh kr b"><strong class="jq hu">spender</strong></code>地址不是零地址(<code class="eh lf lg lh kr b"><strong class="jq hu">0x0</strong></code>)。如果检查失败，该函数将抛出一个错误并退出。</p><p id="ebd0" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated">如果检查通过，该函数将减少指定的<code class="eh lf lg lh kr b"><strong class="jq hu">subtractedValue</strong></code>代表调用者<code class="eh lf lg lh kr b"><strong class="jq hu">msg.sender</strong></code>传送令牌的<code class="eh lf lg lh kr b"><strong class="jq hu">spender</strong></code>地址的允许值。然后，它会发出一个<code class="eh lf lg lh kr b"><strong class="jq hu">Approval</strong></code>事件，表明津贴已经更新。</p><p id="f897" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">decreaseAllowance</strong></code>功能通常与<code class="eh lf lg lh kr b"><strong class="jq hu">increaseAllowance</strong></code>功能结合使用，以允许用户调整另一个用户代表他们转移代币的许可。</p><pre class="km kn ko kp fq kq kr ks bn kt ku bi"><span id="d3e6" class="kv ir ht kr b be kw kx l ky kz">function _mint(address account, uint256 amount) internal {<br/>    require(account != 0);<br/>    _totalSupply = _totalSupply.add(amount);<br/>    _balances[account] = _balances[account].add(amount);<br/>    emit Transfer(address(0), account, amount);<br/>  }</span></pre><p id="fca1" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">_mint</strong></code>功能是一个内部功能，允许用户创建指定数量的新代币并将它们添加到自己的余额中。该函数有两个参数:</p><ol class=""><li id="fdff" class="li lj ht jq b jr la jv lb jz lk kd ll kh lm kl lw lo lp lq dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">account</strong></code>:要增加余额的用户的以太坊地址。</li><li id="b44a" class="li lj ht jq b jr lr jv ls jz lt kd lu kh lv kl lw lo lp lq dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">amount</strong></code>:您想要创建的令牌数量。</li></ol><p id="aeef" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated">该功能首先检查<code class="eh lf lg lh kr b"><strong class="jq hu">account</strong></code>地址不是零地址(<code class="eh lf lg lh kr b"><strong class="jq hu">0x0</strong></code>)。如果检查失败，该函数将抛出一个错误并退出。</p><p id="4eb1" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated">如果检查通过，该功能将令牌的总供应量增加指定的<code class="eh lf lg lh kr b"><strong class="jq hu">amount</strong></code>，并将<code class="eh lf lg lh kr b"><strong class="jq hu">account</strong></code>地址的余额增加相同的数量。然后，它发出一个<code class="eh lf lg lh kr b"><strong class="jq hu">Transfer</strong></code>事件来指示传输已经发生。</p><p id="10ce" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">_mint</strong></code>功能通常用于创建新代币，并将它们添加到用户的余额中。它被标记为<code class="eh lf lg lh kr b"><strong class="jq hu">internal</strong></code>，这意味着它只能从契约内部或者从它继承的契约中被调用。</p><pre class="km kn ko kp fq kq kr ks bn kt ku bi"><span id="b328" class="kv ir ht kr b be kw kx l ky kz">function _burn(address account, uint256 amount) internal {<br/>    require(account != 0);<br/>    require(amount &lt;= _balances[account]);<br/><br/>    _totalSupply = _totalSupply.sub(amount);<br/>    _balances[account] = _balances[account].sub(amount);<br/>    emit Transfer(account, address(0), amount);<br/>  }</span></pre><p id="c5cb" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">_burn</strong></code>功能是一种内部功能，允许用户从自己的余额中烧掉指定数量的代币。该函数有两个参数:</p><ol class=""><li id="9602" class="li lj ht jq b jr la jv lb jz lk kd ll kh lm kl lw lo lp lq dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">account</strong></code>:您要减少余额的用户的以太坊地址。</li><li id="9b94" class="li lj ht jq b jr lr jv ls jz lt kd lu kh lv kl lw lo lp lq dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">amount</strong></code>:你要销毁的代币数量。</li></ol><p id="7eaa" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated">该功能首先检查<code class="eh lf lg lh kr b"><strong class="jq hu">account</strong></code>地址不是零地址(<code class="eh lf lg lh kr b"><strong class="jq hu">0x0</strong></code>)并且<code class="eh lf lg lh kr b"><strong class="jq hu">amount</strong></code>参数小于或等于<code class="eh lf lg lh kr b"><strong class="jq hu">account</strong></code>地址的余额。如果这些检查中的任何一个失败，该函数将抛出一个错误并退出。</p><p id="9608" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated">如果检查通过，该功能将按指定的<code class="eh lf lg lh kr b"><strong class="jq hu">amount</strong></code>减少令牌的总供应量，并按相同的数量减少<code class="eh lf lg lh kr b"><strong class="jq hu">account</strong></code>地址的余额。然后，它发出一个<code class="eh lf lg lh kr b"><strong class="jq hu">Transfer</strong></code>事件来指示传输已经发生。</p><p id="4cf1" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">_burn</strong></code>函数通常用于销毁不再需要或被错误铸造的令牌。它被标记为<code class="eh lf lg lh kr b"><strong class="jq hu">internal</strong></code>，这意味着它只能从契约内部或者从它继承的契约中被调用。</p><pre class="km kn ko kp fq kq kr ks bn kt ku bi"><span id="b280" class="kv ir ht kr b be kw kx l ky kz">function _burnFrom(address account, uint256 amount) internal {<br/>    require(amount &lt;= _allowed[account][msg.sender]);<br/><br/>    // Should &lt;https://github.com/OpenZeppelin/zeppelin-solidity/issues/707&gt; be accepted,<br/>    // this function needs to emit an event with the updated approval.<br/>    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(<br/>      amount);<br/>    _burn(account, amount);<br/>  }<br/>}</span></pre><p id="749e" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">_burnFrom</strong></code>功能是一种内部功能，允许用户从另一个用户的余额中销毁指定数量的代币。该函数有两个参数:</p><ol class=""><li id="9c8d" class="li lj ht jq b jr la jv lb jz lk kd ll kh lm kl lw lo lp lq dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">account</strong></code>:您要减少余额的用户的以太坊地址。</li><li id="0f8c" class="li lj ht jq b jr lr jv ls jz lt kd lu kh lv kl lw lo lp lq dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">amount</strong></code>:你想要销毁的代币数量。</li></ol><p id="be22" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated">该函数首先检查<code class="eh lf lg lh kr b"><strong class="jq hu">amount</strong></code>参数是否小于或等于调用者(<code class="eh lf lg lh kr b"><strong class="jq hu">msg.sender</strong></code>)代表<code class="eh lf lg lh kr b"><strong class="jq hu">account</strong></code>地址传输令牌的允许值。如果检查失败，该函数将抛出一个错误并退出。</p><p id="21b4" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated">如果检查通过，该函数将减少调用者根据指定的<code class="eh lf lg lh kr b"><strong class="jq hu">amount</strong></code>代表<code class="eh lf lg lh kr b"><strong class="jq hu">account</strong></code>地址传输令牌的许可。然后它调用<code class="eh lf lg lh kr b"><strong class="jq hu">_burn</strong></code>函数从<code class="eh lf lg lh kr b"><strong class="jq hu">account</strong></code>地址的余额中销毁指定数量的令牌。</p><p id="ac73" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated"><code class="eh lf lg lh kr b"><strong class="jq hu">_burnFrom</strong></code>功能通常与<code class="eh lf lg lh kr b"><strong class="jq hu">approve</strong></code>和<code class="eh lf lg lh kr b"><strong class="jq hu">transferFrom</strong></code>功能结合使用，允许用户授权其他地址代表他们传输和销毁一定数量的令牌。该函数被标记为<code class="eh lf lg lh kr b"><strong class="jq hu">internal</strong></code>，这意味着它只能从契约内部或从它继承的契约中调用。</p><h1 id="373e" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">参考</h1><p id="0a88" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated"><a class="ae lx" href="https://docs.openzeppelin.com/contracts/4.x/erc20" rel="noopener ugc nofollow" target="_blank"> ERC20 — OpenZeppelin文档</a></p><p id="1936" class="pw-post-body-paragraph jo jp ht jq b jr la jt ju jv lb jx jy jz lc kb kc kd ld kf kg kh le kj kk kl hm dt translated"><a class="ae lx" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol" rel="noopener ugc nofollow" target="_blank">open zeppelin-contracts/ERC 20 . sol在主open zeppelin/open zeppelin-contracts</a></p><blockquote class="ly"><p id="f875" class="lz ma ht bd mb mc md me mf mg mh kl ek translated">交易新手？在<a class="ae lx" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳密码交易所</a>上尝试<a class="ae lx" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a>或<a class="ae lx" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>