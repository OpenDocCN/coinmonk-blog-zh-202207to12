<html>
<head>
<title>Digesting the Solidity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">消化固体</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/digesting-the-solidity-911f96445394?source=collection_archive---------29-----------------------#2022-07-24">https://medium.com/coinmonks/digesting-the-solidity-911f96445394?source=collection_archive---------29-----------------------#2022-07-24</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="5d23" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">还记得我们在上一篇文章中提到的地方吗？<br/> <strong class="is hu"> <em class="jo">合同支付{ <br/>函数支付者()公共应付{ <br/> }} </em> </strong></p><p id="fe4c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">上面的代码片段是发送一些加密支付到一个特定的地址，但它似乎是一种外来的语言。没有吗？为了更好地理解这一点，让我们再深入了解一下关于坚固的一切。但是在此之前，我认为我们可以用迄今为止所获得的任何信息来描述和理解下面编写的基本代码。</p><p id="da32" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">合同标识{ <br/>字符串名称；<br/>单位年龄；<br/>constructor()public {<br/>name = ' Ravi '；<br/>年龄= 17；<br/> } <br/>函数getName()查看公共返回(字符串内存){ <br/>返回名称；<br/> } <br/>函数getAge()查看公共返回(uint){ <br/>返回年龄；<br/> }</p><p id="8328" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">函数setAge()public {<br/>age = age+1；<br/> } <br/> }</p><p id="76e6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在上面的代码片段中，我们试图用solidity编写一个程序，其中我们编写了一个身份对象，用键值对作为姓名和年龄。我们将进一步从上面声明的接口中获取姓名和年龄，并在需要设置年龄值时将它增加1。</p><p id="41bd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> Getter和Setter </strong></p><p id="00ba" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在上面的代码片段中，我们遇到了getter和setter术语。这些只是表达方法的术语。Getter是用来表示我们试图从程序中得到一些东西的术语，而setter是用来表示我们将要用一些新的数据编辑任何先前的变量，并用一组新的变化来交换它的存在。<br/>比如，这里——</p><p id="7ba4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">构造局部{ <br/>单元年龄= 10；</p><p id="0e2d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">函数getter()public view returns(unit){<br/>return age；<br/> }</p><p id="2a21" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">函数setter()public {<br/>age = age+1；<br/> }</p><p id="c248" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">////或////</p><p id="4280" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">函数setter(unit new age)public {<br/>age = new age；<br/> }</p><p id="5b36" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">伙计们，等一下…这里刚刚发生了什么？老实说，稳健是我们的主人，因此稳健必须满足我们的好奇心。不要评判我们，我们只需要相信可靠。<br/>所以，在上面的代码中，首先，我们声明了年龄变量，其值为10。后来，通过“getter”函数，我们得到了年龄的值。<br/>接下来，使用‘setter’函数，我们首先用固定值1来设置年龄变量的值，然后用用户输入的任意值来设置。<br/>现在你一定在想，我为什么要用(或)？这是因为我们不能在定义多个函数时使用同一个函数名。当然，我们可以为第二个getter函数使用其他名称，比如getter_two或abra_ka_dabra。<br/>还有，这里需要注意的一点是，在创建界面的时候，我们写了<strong class="is hu"><em class="jo">unit age = 10；</em> </strong>必须理解的是，如果我们把<strong class="is hu"> <em class="jo">写成单位公龄= 10；</em> </strong>那么我们甚至不需要做任何的getter函数或者就这样来获取age的值。这是因为我们已经初始化了关键字“public ”,这将默认显示变量age的值。<br/>现在让我们看看getter和setter函数的一些特征</p><ul class=""><li id="023f" class="jp jq ht is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx dt translated">调用setter函数会创建一个需要挖掘的事务，因为它会改变区块链，而getter函数则不会这样，</li><li id="385d" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx dt translated">当我们声明公共状态变量时，会自动创建一个getter函数，</li><li id="0308" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx dt translated">默认情况下，变量可见性是私有的。</li></ul><h2 id="c293" class="kd ke ht bd kf kg kh ki kj kk kl km kn jb ko kp kq jf kr ks kt jj ku kv kw kx dt translated">观点与纯粹</h2><p id="4b28" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hm dt translated">到目前为止，在大多数编程函数中，我们在声明任何函数时都会看到“视图”和“纯”这样的词。<br/>让我们更多地了解他们-</p><ul class=""><li id="f5e9" class="jp jq ht is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx dt translated">“视图”和“纯”用于我们不进行任何更新/写入的地方，</li><li id="e246" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx dt translated">“纯”用于不需要从状态变量中读取的情况，</li><li id="9dd8" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx dt translated">当需要从状态变量中读取时，使用“视图”。</li></ul><h2 id="2ab3" class="kd ke ht bd kf kg kh ki kj kk kl km kn jb ko kp kq jf kr ks kt jj ku kv kw kx dt translated">存储与内存</h2><p id="f562" class="pw-post-body-paragraph iq ir ht is b it ky iv iw ix kz iz ja jb la jd je jf lb jh ji jj lc jl jm jn hm dt translated">我们能遇到的下一个最重要的概念是固体的储存和记忆方面。<br/> <strong class="is hu">存储</strong></p><ul class=""><li id="729d" class="jp jq ht is b it iu ix iy jb jr jf js jj jt jn ju jv jw jx dt translated">保存状态变量，</li><li id="569a" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx dt translated">它在整个程序中是持久的，</li><li id="45f2" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx dt translated">它需要油费，</li><li id="1271" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx dt translated">它或多或少有点像电脑硬盘</li></ul><h2 id="5164" class="kd ke ht bd kf kg kh ki kj kk kl km kn jb ko kp kq jf kr ks kt jj ku kv kw kx dt translated"><strong class="ak">记忆</strong></h2><ul class=""><li id="fa45" class="jp jq ht is b it ky ix kz jb ld jf le jj lf jn ju jv jw jx dt translated">如果局部变量是引用类型，则在函数中保存局部变量，</li><li id="3678" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx dt translated">不执着，</li><li id="5fbc" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx dt translated">不需要汽油费，</li><li id="97bc" class="jp jq ht is b it jy ix jz jb ka jf kb jj kc jn ju jv jw jx dt translated">它就像一个电脑内存</li></ul><p id="578d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">坚实度中的全局变量</strong></p><p id="db94" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这些是用于vpurpose目的的内置变量，如知道时间戳、块创建者等。<br/>使用全局变量的例子- <br/>构造demo{ <br/>函数get()public view returns(unit block _ no . uint timestamp，address，msgSender){ <br/> return (block。编号，块。时间戳。发件人)；<br/> } <br/> }</p><p id="ff70" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，看完了各种各样的Solidity代码片段，让我们回到我们开始的地方——<br/>我们的payable函数——(未完待续)。这个恶棍还没有落入我们的圈套。我将在我们的下一篇文章中解释清楚，直到那时让我们继续链接这些块。</p><p id="04a6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">谢谢你们的时间，伙计们！</p><blockquote class="lg"><p id="0194" class="lh li ht bd lj lk ll lm ln lo lp jn ek translated">交易新手？试试<a class="ae lq" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或者<a class="ae lq" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>