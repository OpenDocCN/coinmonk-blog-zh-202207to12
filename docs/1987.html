<html>
<head>
<title>Learn Solidity lesson 20. Address type methods.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习第20课固体。地址类型方法。</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/learn-solidity-lesson-20-address-type-methods-65cd2b4daa6f?source=collection_archive---------5-----------------------#2022-08-10">https://medium.com/coinmonks/learn-solidity-lesson-20-address-type-methods-65cd2b4daa6f?source=collection_archive---------5-----------------------#2022-08-10</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/bbf5fe0024fd93b19de947215a3728f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9UwOemZkyxrPwlFN_ySGRw.jpeg"/></div></div></figure><p id="68a1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">地址类型是Solidity中最常用的类型之一，因为它表示区块链上的帐户。</p><p id="9937" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">每个帐户都有一个基础硬币余额。在以太网的情况下，一个账户在以太网中有余额。在其他EVM兼容的区块链上，比如Polygon，平衡是在网络的一些本地令牌中，比如MATIC代表Polygon。</p><p id="5391" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在Solidity中，可以从合同中检索帐户的硬币/代币余额信息。这是使用address类型变量的<em class="jz"> balance </em>属性完成的，如下所示。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="7c46" class="kj kk ht kf b fv kl km l kn ko">address myAddress = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;<br/>myAddress.balance; // returns uint256</span></pre><p id="161d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我用的是Remix创建的账户地址。值<em class="jz"> myAddress.balance </em>属于类型<em class="jz"> uint256 </em>。我们还可以使用地址文字表达式来访问balance属性，如下所示。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="d48b" class="kj kk ht kf b fv kl km l kn ko">0x5B38Da6a701c568545dCfcB03FcB875f56beddC4.balance;</span></pre><p id="3a02" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">帐户余额返回其全部值，包括所有小数位。在以太坊的情况下，该值以Wei为单位返回。</p><p id="6758" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">一个非常常见的用途是查看合同本身的帐户余额。在Solidity中，有一个对象<strong class="jd hu"> this </strong>，表示当前的契约实例。我们可以使用<em class="jz">这个</em>来检索合同地址，通过<em class="jz">地址(这个)</em>。这样我们就可以收回合同的余额。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="91cf" class="kj kk ht kf b fv kl km l kn ko">address(this).balance;  // returns uint256</span></pre><p id="0222" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">还可以使用<em class="jz"> code </em>属性检索契约字节码，如下所示。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="e729" class="kj kk ht kf b fv kl km l kn ko">address(this).code;    // returns bytes</span></pre><p id="f61d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">合同的代码是一个类型为<em class="jz">字节</em>的变量。我们可以通过地址检索任何契约的字节码。</p><h1 id="7661" class="kp kk ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">发送以太网</h1><p id="b644" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">我们可以将以太(或区块链的基础硬币/代币)从合同内发送到网络上的任何账户。有不止一种方法可以做到这一点，我们将看到它们之间的区别。</p><p id="3c97" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">从合同内部发送以太网的帐户是合同本身的帐户，因此以太网中必须有正余额才能发送以太网。</p><p id="90ba" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">需要注意的是，只有<em class="jz">应付</em>地址有这样的方法。试图调用<em class="jz">(地址)。例如，对于不属于类型<em class="jz">应付款</em>的地址，transfer </em>方法将抛出一个错误。</p><p id="5bfa" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果地址是不可支付的，可以转换变量，如下所示。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="af31" class="kj kk ht kf b fv kl km l kn ko">payable(address).(...);</span></pre><h1 id="e1fb" class="kp kk ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">转移</h1><p id="627c" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">方法<strong class="jd hu">传送</strong>发送以太到给定的地址。如果在发送以太网时发生错误，整个事务将被恢复。让我们用这种方法写一个送乙醚的合同。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="1c5c" class="kj kk ht kf b fv kl km l kn ko">contract Addresses {</span><span id="7a74" class="kj kk ht kf b fv lr km l kn ko">   constructor() payable {}</span><span id="da5f" class="kj kk ht kf b fv lr km l kn ko">   function sendEther(address payable _address) public {<br/>      _address.transfer(10 ether);<br/>   }    <br/>}</span></pre><p id="8f6c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们首先在部署时向契约发送以太网。为此你需要在构造函数中使用<em class="jz">应付款</em>修饰符。为了能够在被调用时接收值，函数的类型必须是payable。构造函数是在部署时调用的函数。</p><p id="0c56" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">10个醚的数量将被发送到一个帐户，该帐户的地址是函数<code class="eh ls lt lu kf b">sendEther</code>的一个参数。注意，函数参数是类型<em class="jz">地址应付</em>，而不仅仅是<em class="jz">地址</em>。这是使用方法<em class="jz">转移</em>所必需的。</p><p id="5283" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">坚实度有三个值单位:<strong class="jd hu">卫</strong>、<strong class="jd hu">鬼卫</strong>和<strong class="jd hu">以太</strong>。在上面的例子中，我们使用单元<em class="jz">乙醚</em>。</p><p id="74ad" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">可能导致方法<em class="jz">转移</em>恢复的一种情况是合同账户没有足够的余额。另一种可能性是尝试将乙醚发送到不具有可支付功能的合同账户。</p><figure class="ka kb kc kd fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff lv"><img src="../Images/e53a72bedff11a427534e32071823e8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mvOx9e9nnmUkwWm9xxud4Q.png"/></div></div><figcaption class="lw lx fg fe ff ly lz bd b be z ek">The transfer method will revert if it encounters any errors.</figcaption></figure><h1 id="e0e2" class="kp kk ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">派遣</h1><p id="d0b6" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">另一种可能是用<strong class="jd hu">发送</strong>的方法将乙醚发送到账户。让我们在下面的声明中看到这一点。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="a09f" class="kj kk ht kf b fv kl km l kn ko">_address.send(10 ether);</span></pre><p id="2c31" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><em class="jz">传输</em>和<em class="jz">发送</em>的区别在于<em class="jz">发送</em>方法不会在出错时恢复。如果发送成功/失败，返回<em class="jz">真</em> / <em class="jz">假</em>。</p><p id="f6ab" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">测试<em class="jz">发送</em>方法的返回是可能的(而且几乎总是可取的)，如下所示。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="75f7" class="kj kk ht kf b fv kl km l kn ko">bool success = _address.send(10 ether);<br/>if (!success) {<br/>   revert();<br/>}</span></pre><p id="fc75" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们没有研究上面代码的所有成分，但是让我们试着理解它。方法<em class="jz"> send </em>返回true或false，这取决于发送Ether是否成功。在上面的例子中，返回被分配给变量<code class="eh ls lt lu kf b">success</code>。</p><p id="edfc" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">然后我们检查变量<code class="eh ls lt lu kf b">success</code>在表达式<code class="eh ls lt lu kf b">if (!success)</code>中的值是否为假(读为“如果不成功”)。如果不成功，我们执行方法<code class="eh ls lt lu kf b">revert()</code>，该方法恢复事务。</p><h1 id="5a0e" class="kp kk ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">呼叫</h1><p id="f3b3" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">方法<strong class="jd hu"> call </strong>不仅用于向某个账户发送以太，还可以与某个合约账户进行交互，能够调用函数。但是，可以使用此方法仅发送以太网，因为这是向任何帐户(外部或合同)发送交易时的一个选项。</p><p id="0bcb" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在另一课中，我们会有更多关于方法<em class="jz">调用</em>的内容。暂且就让我们来看看怎么用它发以太吧。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="bbb2" class="kj kk ht kf b fv kl km l kn ko">_address.call{value: 10 ether}("");</span></pre><p id="b0a9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">由于方法<em class="jz">调用</em>可以调用一个契约函数，它必须返回两个值:一个泛型值，它是被执行函数的返回，以及事务是否成功的信息。</p><p id="e8c3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这意味着call方法返回一对值。第一个返回参数是<em class="jz">布尔值</em>，而第二个是类型<em class="jz">字节</em>。由于我们只对发送以太网的成功或失败感兴趣，我们可以使用下面的代码。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="85f3" class="kj kk ht kf b fv kl km l kn ko">(bool success, ) = _address.call{value: 10 ether}("");</span></pre><p id="0212" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们只获取发送成功与否的信息，而忽略其他参数。</p><h1 id="1ea5" class="kp kk ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">我应该使用转接、发送还是呼叫？</h1><p id="ec57" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">我们需要知道使用<em class="jz">转接</em>、<em class="jz">发送</em>和<em class="jz">呼叫</em>的区别。前两种方法仅将2300单位的气体转移到目标帐户，这仅够执行乙醚转移。<em class="jz">调用</em>方法将所有可用的gas转发到目标帐户。</p><p id="3eff" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我解释一下。<em class="jz">调用</em>方法的目的比仅仅发送以太要广泛得多。它将调用另一个契约中的函数，并且不可能知道这个函数将需要多少气体。因此，所有可用的气体都被输送。</p><p id="eff4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">从其他契约调用函数时必须小心。他们可以使用转发的gas来执行恶意操作，包括入侵发送呼叫的合同。这不仅可以像在被称为可重入性的利用中那样完成。</p><p id="9ff3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">直到最近，还推荐使用<em class="jz">转移</em>方法转移乙醚。<em class="jz">转账</em>方法只转发2300单位的气，是为了防止收款账号利用可用气进行某种恶意的态度。</p><p id="acfc" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">但是，目前推荐的方法是使用<em class="jz">调用</em>。想法是以太坊气表是灵活的，可能是将来运以太要2300单位以上的气。这可能会破坏版本之间的兼容性。</p><p id="4ada" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">无论如何，你需要了解这三种方法之间的区别，并知道每一种方法的工作原理。</p><h1 id="4731" class="kp kk ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">Call、delegatecall和staticcall。</h1><p id="c43d" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">方法<em class="jz"> call </em>用于调用其他契约中的函数，但不是唯一的选项。可以通过其接口以更简单的方式与其他协定进行交互，而无需使用本课中描述的任何方法。</p><p id="8dce" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">call方法以及方法<em class="jz"> delegatecall </em>和<em class="jz"> staticcall </em>都是底层的，需要显式编码函数和将要发送的参数。</p><p id="5e88" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">方法<em class="jz">调用</em>和<em class="jz">静态调用</em>有很多相似之处，然而<em class="jz">委托调用</em>引入了一些不同之处。它主要用于调用充当库的契约中的函数。</p><p id="499a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这种方法的使用是一个更高级的主题，将在以后的课程中更详细地研究。</p><p id="3e9c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">感谢阅读！</strong></p><p id="52ab" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎对本文提出意见和建议。</p><p id="f7e1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎任何投稿。<a class="ae ma" href="http://www.buymeacoffee.com/jpmorais" rel="noopener ugc nofollow" target="_blank">www.buymeacoffee.com/jpmorais</a></p><blockquote class="mb"><p id="c190" class="mc md ht bd me mf mg mh mi mj mk jy ek translated">加入Coinmonks <a class="ae ma" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae ma" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>了解加密交易和投资</p></blockquote><h1 id="d02c" class="kp kk ht bd kq kr ks kt ku kv kw kx ky kz ml lb lc ld mm lf lg lh mn lj lk ll dt translated">另外，阅读</h1><ul class=""><li id="e64e" class="mo mp ht jd b je lm ji ln jm mq jq mr ju ms jy mt mu mv mw dt translated"><a class="ae ma" href="https://coincodecap.com/bookmap-review-2021-best-trading-software" rel="noopener ugc nofollow" target="_blank"> Bookmap点评</a> | <a class="ae ma" href="https://coincodecap.com/crypto-exchange-usa" rel="noopener ugc nofollow" target="_blank">美国5大最佳加密交易所</a></li><li id="8e15" class="mo mp ht jd b je mx ji my jm mz jq na ju nb jy mt mu mv mw dt translated"><a class="ae ma" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a> | <a class="ae ma" href="https://coincodecap.com/coingate-review" rel="noopener ugc nofollow" target="_blank">硬币门评论</a></li><li id="9513" class="mo mp ht jd b je mx ji my jm mz jq na ju nb jy mt mu mv mw dt translated">最佳加密<a class="ae ma" rel="noopener" href="/coinmonks/hardware-wallets-dfa1211730c6">硬件钱包</a> | <a class="ae ma" rel="noopener" href="/coinmonks/bitbns-review-38256a07e161"> Bitbns评论</a></li><li id="3458" class="mo mp ht jd b je mx ji my jm mz jq na ju nb jy mt mu mv mw dt translated"><a class="ae ma" href="https://coincodecap.com/crypto-exchange-in-singapore" rel="noopener ugc nofollow" target="_blank">新加坡十大最佳加密交易所</a> | <a class="ae ma" href="https://coincodecap.com/buy-axs-token" rel="noopener ugc nofollow" target="_blank">购买AXS </a></li><li id="f9e4" class="mo mp ht jd b je mx ji my jm mz jq na ju nb jy mt mu mv mw dt translated"><a class="ae ma" href="https://coincodecap.com/red-dog-casino-review" rel="noopener ugc nofollow" target="_blank">红狗赌场评论</a> | <a class="ae ma" href="https://coincodecap.com/swyftx-review" rel="noopener ugc nofollow" target="_blank"> Swyftx评论</a></li></ul></div></div>    
</body>
</html>