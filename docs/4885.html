<html>
<head>
<title>How to use Yul Verbatim with Solidity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何一字不差地使用Yul和Solidity</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/how-to-write-any-function-in-pure-opcodes-and-add-it-to-your-solidity-function-yul-verbatim-c1ce2760f7a5?source=collection_archive---------8-----------------------#2022-10-12">https://medium.com/coinmonks/how-to-write-any-function-in-pure-opcodes-and-add-it-to-your-solidity-function-yul-verbatim-c1ce2760f7a5?source=collection_archive---------8-----------------------#2022-10-12</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="ecc1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">solidity编译器不是很有效。通常对于基本运算，Solidity编译器会添加大量不必要的操作码。编译器这样做是因为如果开发人员没有搞砸，它会增加许多检查，如果他们搞砸了，编译器会在造成任何损害之前恢复。</p><p id="bf7c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当你从扎实开始，只想写点有用的东西时，这是很棒的。<strong class="is hu">但是由于以太坊上的天然气会变得非常昂贵</strong>，有时我们需要尽可能地优化合同。</p><p id="28db" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">你可以使用内嵌汇编</strong>，但是solidity编译器仍然增加了许多检查和不必要的操作码，这只会耗费更多的时间。</p><p id="e3df" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">还可以使用类似<a class="ae jo" href="https://huff.sh/" rel="noopener ugc nofollow" target="_blank"> <strong class="is hu">哈夫</strong> </a>这样的语言，非常优秀。它允许您访问堆栈，您可以进行任何想要的优化。但是在Huff中编写一个复杂的契约是一种折磨，因为你必须一个操作码接一个操作码。</p><p id="72b6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">最好的选择，在我看来，也是本文的主题，</strong>是用solidity编写契约，省去需要更多优化的函数，稍后只需用<a class="ae jo" href="https://docs.soliditylang.org/en/v0.8.17/yul.html#verbatim" rel="noopener ugc nofollow" target="_blank">逐字添加字节码</a>。</p><h2 id="a64d" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj dt translated">什么是一字不差？</h2><p id="0bba" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hm dt translated">根据坚固性文件:</p><blockquote class="kp kq kr"><p id="3fb5" class="iq ir ks is b it iu iv iw ix iy iz ja kt jc jd je ku jg jh ji kv jk jl jm jn hm dt translated">一组逐字的…内置函数允许您为Yul编译器不知道的操作码创建字节码。它还允许您创建不会被优化器修改的字节码序列。</p></blockquote><p id="8520" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">简而言之，它允许我们将自己的字节码添加到已经编译好的契约中。但是有一个小问题。<strong class="is hu">逐字在solidity </strong>中不起作用，所以我们必须首先<strong class="is hu">将我们的合同向下编译到YUL </strong>，然后用逐字添加字节码。</p><h2 id="b03d" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj dt translated">如何生成优化后的字节码？</h2><p id="689d" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hm dt translated">一些工具可以让你做到这一点，但是它们相当复杂，所以我写了一个简单的编译器来为你生成字节码。</p><ol class=""><li id="151a" class="kw kx ht is b it iu ix iy jb ky jf kz jj la jn lb lc ld le dt translated"><strong class="is hu">转到这个</strong> <a class="ae jo" href="https://github.com/Kuly14/mnemonic" rel="noopener ugc nofollow" target="_blank"> <strong class="is hu">回购</strong> </a> <strong class="is hu">克隆到你的机器上</strong></li></ol><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="09e4" class="jp jq ht lk b fv lo lp l lq lr">git clone<a class="ae jo" href="https://github.com/Kuly14/mnemonic.git" rel="noopener ugc nofollow" target="_blank"> https://github.com/Kuly14/mnemonic.git</a></span></pre><p id="e1d4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> 2。光盘放入文件夹</strong></p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="1c43" class="jp jq ht lk b fv lo lp l lq lr">cd mnemonic</span></pre><p id="1302" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> 3。创建您的。像这样的mn文件</strong></p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="ca01" class="jp jq ht lk b fv lo lp l lq lr">touch yourName.mn</span></pre><p id="7ef5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> 4。用纯操作码编写函数</strong></p><p id="2e91" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">通常，如果你用纯操作码来写，它应该是这样的:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="8b9c" class="jp jq ht lk b fv lo lp l lq lr">push1 0x04 calldataload<br/>push1 0x00 mstore<br/>push1 0x20<br/>push1 0x00<br/>return</span></pre><p id="56e8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这既烦人又费时。所以我把它添加到编译器中，当你使用0x:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="a1f2" class="jp jq ht lk b fv lo lp l lq lr">0x04 calldataload<br/>0x00 mstore<br/>0x20 0x00<br/>return</span></pre><p id="32eb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">所以如果你尝试使用push操作码，它不会编译。只需用0x写你想压入栈的字节。</p><p id="ad1c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> 5。编译。用编译器编译mn文件</strong></p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="dcde" class="jp jq ht lk b fv lo lp l lq lr">cargo run -- /path/to/your/file/nameOfYourFile.mn</span></pre><p id="19b7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这将编译契约并将字节码保存到bytecode.txt</p><p id="ea39" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果您希望编译器将字节码打印到终端，请使用如下的<code class="eh ls lt lu lk b">-p</code>标志:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="9426" class="jp jq ht lk b fv lo lp l lq lr">cargo run -- /path/to/your/file/nameOfYourFile.mn -p</span></pre><p id="6eea" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> 6。创建你的实体契约，把你想写的函数的操作码留空</strong></p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="9cbc" class="jp jq ht lk b fv lo lp l lq lr">function show() public view returns(uint) {}</span></pre><p id="fa78" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> 7。用solc </strong>将你的solidity文件编译到YUL</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="b3a6" class="jp jq ht lk b fv lo lp l lq lr">solc nameOfYourContract.sol --ir &gt; nameOfYourNewYulFile.yul</span></pre><p id="c64e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这将把合同编译到YUL，并以nameOfYourNewYulFile.yul的名称保存</p><p id="d694" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> 8。用你最喜欢的编辑器打开YUL文件，删除第一行</strong></p><p id="4c97" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">第一次打开文件时，第一行应该是这样的</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="cd16" class="jp jq ht lk b fv lo lp l lq lr">IR:</span></pre><p id="b7bb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">删除这一行。</p><p id="33d6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> 9。找到你留空的功能</strong></p><p id="7034" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">只需ctrl+F，编写整个函数</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="1d0b" class="jp jq ht lk b fv lo lp l lq lr">ctrl F — function show() public view returns(uint)</span></pre><p id="2961" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">你应该会看到这样的东西</p><figure class="lf lg lh li fq lw fe ff paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="fe ff lv"><img src="../Images/c565f26afc1cf7665f7606c385144d11.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*kJbzBRHP0MtcE3nl"/></div></div></figure><p id="99fc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> 10。从bytecode.txt文件中复制字节码，并将其添加到YUL文件中，如下所示:</strong></p><figure class="lf lg lh li fq lw fe ff paragraph-image"><div role="button" tabindex="0" class="lx ly di lz bf ma"><div class="fe ff lv"><img src="../Images/8bb68049c818523fb3a6994c74f40a1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*pVyLZt8NZwTZhL7b"/></div></div></figure><p id="bf28" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果你看逐字后面的逐字语句，<strong class="is hu">有_0i_0o </strong>。这意味着我们将把堆栈的0个项目放入逐字记录中，并从逐字记录中返回0个项目到堆栈中。</p><p id="095d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果你只需要优化一个函数的一部分，并且你想把项目从堆栈中取出来，这就很方便了。</p><p id="f813" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">但是那会很快变得非常复杂。你必须用调试器来运行这个函数，并找出在那个特定时刻堆栈里有什么。</p><p id="e4d2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果你不知道如何使用remix调试器，我写了一篇文章，你可以在这里查阅:<a class="ae jo" rel="noopener" href="/@kulman.david/how-to-use-remix-debugger-to-learn-solidity-assembly-5a745a22bb07">https://medium . com/@ kulman . David/how-to-use-remix-debugger-to-learn-solidity-assembly-5a 745 a 22 bb 07</a></p><p id="e751" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">11。将YUL合同编译成字节码</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="20fe" class="jp jq ht lk b fv lo lp l lq lr">solc --strict-assembly nameOfYourYulFile.yul --bin</span></pre><p id="4d77" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这将输出整个契约的字节码。抄下来，继续下一步。</p><p id="8ac2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">12。部署字节码</p><p id="a538" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们已经有了字节码，我们可以部署契约了。</p><p id="ef87" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最好的方法是用安全帽。转到这个回购:<a class="ae jo" href="https://github.com/Kuly14/deploy-bytecode" rel="noopener ugc nofollow" target="_blank">https://github.com/Kuly14/deploy-bytecode</a>并克隆到你的机器上:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="afba" class="jp jq ht lk b fv lo lp l lq lr">git clone<a class="ae jo" href="https://github.com/Kuly14/deploy-bytecode.git" rel="noopener ugc nofollow" target="_blank"> https://github.com/Kuly14/deploy-bytecode.git</a></span></pre><p id="980e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> 12.1安装依赖项:</strong></p><p id="249c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">安装部署合同所需的所有必要依赖项:</p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="d5e5" class="jp jq ht lk b fv lo lp l lq lr">yarn</span></pre><p id="e63c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">将你的合同添加到src文件夹，这很重要，这样hardhat就可以生成ABI。</p><p id="8630" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> 12.2编制合同:</strong></p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="f3f5" class="jp jq ht lk b fv lo lp l lq lr">yarn hardhat compile</span></pre><p id="dd84" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">该命令将在工件文件夹中生成ABI。</p><p id="4d2a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在转到“测试/单元/部署2.test.ts”</p><p id="dee2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> 12.3导入ABI </strong></p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="5f59" class="jp jq ht lk b fv lo lp l lq lr">import * as abi from ../../artifacts/path/to/your/abi.json</span></pre><p id="9904" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">另外，将<strong class="is hu"> `const字节码= " 0x 6000……``</strong>更改为您的字节码。</p><p id="82ef" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">不要忘记在字节码的开头加上“0x ”,否则它将不起作用。</p><p id="1b0d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在在“it”块中，编写你自己的测试，正如你在这里看到的:<a class="ae jo" href="https://github.com/Kuly14/deploy-bytecode/blob/main/test/unit/Deploy2.test.ts" rel="noopener ugc nofollow" target="_blank">https://github . com/kuly 14/deploy-bytecode/blob/main/test/unit/deploy 2 . test . ts</a></p><p id="7d6b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> 12.4运行您的测试:</strong></p><pre class="lf lg lh li fq lj lk ll lm aw ln dt"><span id="bd22" class="jp jq ht lk b fv lo lp l lq lr">yarn hardhat test test/unit/Deploy2.test.ts</span></pre><p id="ff93" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">恭喜恭喜！！！</strong></p><p id="b5b3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">以下是我们在本文中使用的两个回购的链接:</p><div class="md me fm fo mf mg"><a href="https://github.com/Kuly14/mnemonic" rel="noopener  ugc nofollow" target="_blank"><div class="mh ab ej"><div class="mi ab mj cl cj mk"><h2 class="bd hu fv z el ml eo ep mm er et hs dt translated">GitHub-kuly 14/助记符:EVM操作码的编译器</h2><div class="mn l"><h3 class="bd b fv z el ml eo ep mm er et ek translated">可靠性编译器不是很有效。通常对于基本运算，Solidity编译器会增加大量的…</h3></div><div class="mo l"><p class="bd b gc z el ml eo ep mm er et ek translated">github.com</p></div></div><div class="mp l"><div class="mq l mr ms mt mp mu mb mg"/></div></div></a></div><div class="md me fm fo mf mg"><a href="https://github.com/Kuly14/deploy-bytecode" rel="noopener  ugc nofollow" target="_blank"><div class="mh ab ej"><div class="mi ab mj cl cj mk"><h2 class="bd hu fv z el ml eo ep mm er et hs dt translated">GitHub - Kuly14/deploy-bytecode:用hardhat部署纯字节码。</h2><div class="mn l"><h3 class="bd b fv z el ml eo ep mm er et ek translated">此时您不能执行该操作。您已使用另一个标签页或窗口登录。您已在另一个选项卡中注销，或者…</h3></div><div class="mo l"><p class="bd b gc z el ml eo ep mm er et ek translated">github.com</p></div></div><div class="mp l"><div class="mv l mr ms mt mp mu mb mg"/></div></div></a></div><p id="ee75" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果你迷路了，不要犹豫提出问题，或者在这篇文章里留下评论。<strong class="is hu">感谢阅读！</strong></p><h2 id="f4bd" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj dt translated">警告</h2><p id="9ec9" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hm dt translated">做这件事风险很大。我们正在手动处理堆栈，这会创建许多攻击媒介，并使合同<strong class="is hu">易受攻击</strong>。这只是为了好玩。除非绝对必要，否则我绝不会在实际的main-net代码中使用它。</p></div></div>    
</body>
</html>