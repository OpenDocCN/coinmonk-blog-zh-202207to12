<html>
<head>
<title>Difficulty adjustment in blockchain</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">区块链的难度调整</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/difficulty-adjustment-in-blockchain-d52c8bef0b3f?source=collection_archive---------20-----------------------#2022-12-16">https://medium.com/coinmonks/difficulty-adjustment-in-blockchain-d52c8bef0b3f?source=collection_archive---------20-----------------------#2022-12-16</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><h2 id="08ac" class="hr hs ht bd b gc hu hv hw hx hy hz ek ia translated" aria-label="kicker paragraph">区块链</h2><div class=""/><figure class="fi fk ja jb jc jd fe ff paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="fe ff iz"><img src="../Images/788715654fbe54836eefcb80231170bc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*adkN4LRKZWu9fT5N.jpeg"/></div></div></figure><p id="6fe4" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">我们在上一篇文章中看到了工作验证算法<a class="ae ki" href="https://www.thearmchaircritic.org/mansplainings/how-proof-of-work-is-used-to-establish-consensus-in-blockchain" rel="noopener ugc nofollow" target="_blank">，在本文中，我们将看看如何根据难度值调整目标散列以保持事务时间不变。</a></p><p id="9a53" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">首先，我们根据难度值计算目标散列。我们调整这个难度值，以保持产生一个事务所需的时间不变。让我们看看如何调整这个难度值。</p><p id="a007" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">比特币每2016年交易调整一次难度值(实际上是区块，我们后面会讨论区块)。比特币预计每笔交易(区块)需要大约10分钟的时间<a class="ae ki" href="https://www.investopedia.com/terms/b/block-time-cryptocurrency.asp" rel="noopener ugc nofollow" target="_blank"/>。所以实际上，比特币每20160分钟调整一次难度值，等于两周。为了确保事务平均花费10分钟，我们需要测量每个事务花费的时间。</p><p id="56bd" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">所以，我们给每笔交易都打上时间戳。时间戳是自Unix纪元(1970年1月00:00:00 01)以来经过的毫秒数。我们可以找到当前批次中第2016个块的时间戳与上一批次的第2016个块的时间戳之差，从而得出完成这2016个事务所用的总时间。</p><blockquote class="kj"><p id="8ba2" class="kk kl ht bd km kn ko kp kq kr ks kh ek translated">交易新手？在<a class="ae ki" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易</a>上尝试<a class="ae ki" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae ki" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote><h1 id="34ff" class="kt ku ht bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">计算难度</h1><p id="4833" class="pw-post-body-paragraph jk jl ht jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh hm dt translated">一旦我们有了这个值，我们就可以将它与期望值(20160分钟)进行比较，用期望值除以实际值。如果两个值相同，我们将得到值1。如果交易发生得更快，那么结果将大于1。类似地，如果事务花费的时间更长，我们将得到小于1的值。</p><figure class="lx ly lz ma fq jd fe ff paragraph-image"><div class="fe ff lw"><img src="../Images/043c3d04c19277f2371a92369d71d475.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*arjCG9Y9H-BPBrgzHXkjxw.png"/></div></figure><p id="8308" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">然后我们可以用这个值来计算难度。如果交易更快，那么这意味着我们应该增加难度。我们已经看到，如果交易更快，通过将期望值除以实际值，我们会得到大于1的值。因此，如果我们将这个值乘以现有的难度，我们将得到一个更高的难度值。</p><figure class="lx ly lz ma fq jd fe ff paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="fe ff mb"><img src="../Images/ae8e0b02ed7cf1611eb68e694efd6efd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*J6G_pACqCAcXNw9ZTn8r8g.png"/></div></div></figure><p id="c235" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">现在，让我们看几个例子。假设实际值是30，000，难度值是100，让我们看看新的难度值是多少。</p><figure class="lx ly lz ma fq jd fe ff paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="fe ff mc"><img src="../Images/b4aec29a1dcddb73c8a53d778c4bbf04.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CeLXyAoKJrqbbrZ42cTzHw.png"/></div></div></figure><p id="5268" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">正如你所看到的，难度值已经下降了，因为交易时间变长了。</p><p id="db90" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">再举一个实际值为15000，难度值为100的例子:</p><figure class="lx ly lz ma fq jd fe ff paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="fe ff md"><img src="../Images/b528abc599e43066429037b58affd120.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EsrqDJJ4FxxLTVFagAm5Eg.png"/></div></div></figure><p id="51f1" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">由于交易速度加快，难度值上升了。</p><h1 id="1e62" class="kt ku ht bd kv kw kx ky kz la lb lc ld le me lg lh li mf lk ll lm mg lo lp lq dt translated">基于难度计算目标哈希</h1><p id="2b25" class="pw-post-body-paragraph jk jl ht jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh hm dt translated">现在让我们看看如何根据难度值计算目标散列。我们已经看到理论上的最大哈希值是2 255。但实际上，最大哈希值被设置为:</p><p id="09f0" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">0x 000000000 ffff 0000000000000000000000000000000000000000000000000000000000</p><p id="0f63" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">我们通过将这个最大散列值除以难度值来获得目标散列值。</p><figure class="lx ly lz ma fq jd fe ff paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="fe ff md"><img src="../Images/25ad07c00cd67948e8d57070781f7783.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tKC4dxs8uISAD-BJQ6GdOg.png"/></div></div></figure><p id="2cfb" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">当区块链网络被接受时，目标散列将是最大散列值。因此，难度值将为1。因此，难度值永远不会低于1，因为较低的难度值意味着目标散列将高于最大散列值。</p><p id="50b9" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">随着越来越多的计算机加入网络，或者随着现有计算机处理能力的提高，目标哈希变得越来越小。这增加了解谜的难度，并因此确保了解谜所花费的时间保持在10分钟。</p><h1 id="258b" class="kt ku ht bd kv kw kx ky kz la lb lc ld le me lg lh li mf lk ll lm mg lo lp lq dt translated">存储目标哈希</h1><p id="cf51" class="pw-post-body-paragraph jk jl ht jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh hm dt translated">然而，我们并没有将目标散列作为256位散列存储在块中(我们将在后面学习块。目前，将块视为与事务相同。).为了节省空间，我们将其存储为一个32位(4字节)的整数值。比如最大可能哈希定义为<em class="mh"> 486604799 </em>，十六进制格式为<em class="mh">0x 100 ffff</em>。这个整数叫做比特。</p><p id="f2e7" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">让我们看看这些位是如何被转换回散列格式的。首先，将位的值转换为十六进制格式，即<em class="mh"> 0x1d00ffff </em>。如上所述，这是一个4字节的数字。这个(<em class="mh"> 0x1d </em>)的最高有效字节称为索引。其中的3个最低有效字节(<em class="mh"> 0x00ffff </em>)称为系数。现在，我们可以使用下面的公式找出目标哈希值。</p><figure class="lx ly lz ma fq jd fe ff paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="fe ff mi"><img src="../Images/9fb530684c0e6a5dbe470c6e712bae0e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KX5xLD4mlOPgasdT3sa3ew.png"/></div></div></figure><p id="53fe" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">让我们尝试将系数和索引插入到这个公式中，以获得目标散列。</p><figure class="lx ly lz ma fq jd fe ff paragraph-image"><div role="button" tabindex="0" class="je jf di jg bf jh"><div class="fe ff mj"><img src="../Images/91cacb940a46939c644f047477ef4fad.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RQcMJAHphhkzbtMf3XQ7fQ.png"/></div></div></figure><p id="b18f" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">这将产生以下输出</p><p id="5f35" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">0x fffeffd 1 a3 a 429 BF BCB 8 a 4188 e 09 da 06491 a 6841 f 00000000000000</p><p id="ca85" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">我们可以把这个四舍五入到</p><p id="8ec2" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">0x ffff 000000000000000000000000000000000000000000000000000</p><p id="a552" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">请注意，它只有224位。为了使它成为256位，我们可以在前面加零。</p><p id="8c41" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">0x 000000000 ffff 0000000000000000000000000000000000000000000000000000000000</p><p id="a6bb" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">这是计算出的目标哈希。</p><h1 id="c671" class="kt ku ht bd kv kw kx ky kz la lb lc ld le me lg lh li mf lk ll lm mg lo lp lq dt translated">计算目标散列的另一种方法</h1><p id="8dbe" class="pw-post-body-paragraph jk jl ht jm b jn lr jp jq jr ls jt ju jv lt jx jy jz lu kb kc kd lv kf kg kh hm dt translated">然而，有一个更简单的方法来计算这个。将索引视为字节数，将系数视为前缀。在我们的例子中，索引是<em class="mh"> 0x1d </em>，转换成十进制是29。因此，计算出的值应该有29个字节。前缀<em class="mh"> 0x00ffff </em>只有3个字节。因此，在前缀后添加52个零，以获得剩余的26个字节。然后在这个值前面加零，得到一个256位的散列。</p><p id="ab8e" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">还应该记住，最大散列值<em class="mh">0x 000000000 ffff 00000000000000000000000000000000000000000</em>不适用于池挖掘者(我们将在后面详细讨论池挖掘)。池挖掘器使用最大哈希值<em class="mh">0x 000000000 fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</em>。</p><p id="0138" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">所以，由矿工计算的难度值会和其他人计算的不同。由池矿工计算的难度值称为pdiff，而由其他人计算的难度值称为bdiff。</p><p id="e847" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated">现在我们已经了解了如何调整目标哈希值，让我们在下一篇文章中看看如何从事务中创建块。</p></div><div class="ab cl mk ml hb mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="hm hn ho hp hq"><p id="333f" class="pw-post-body-paragraph jk jl ht jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hm dt translated"><em class="mh">原载于2022年12月16日</em><a class="ae ki" href="https://www.thearmchaircritic.org/mansplainings/difficulty-adjustment-in-blockchain" rel="noopener ugc nofollow" target="_blank"><em class="mh"/></a><em class="mh">。</em></p></div></div>    
</body>
</html>