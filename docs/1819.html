<html>
<head>
<title>Ciphershashtra — Shilpkaar Puzzle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">cipher shashtra-Shilpkaar难题</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/ciphershashtra-shilpkaar-puzzle-7a3b2846fb58?source=collection_archive---------6-----------------------#2022-08-06">https://medium.com/coinmonks/ciphershashtra-shilpkaar-puzzle-7a3b2846fb58?source=collection_archive---------6-----------------------#2022-08-06</a></blockquote><div><div class="eg hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fn fp hv hw ff fg paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="ff fg hs"><img src="../Images/7537276fa100d13aeb8733c30a540f21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h9rae3rIMBMvvQt0Qf3-OQ.png"/></div></div><figcaption class="id ie fh ff fg if ig bd b be z el">ChipherShastra Challenge</figcaption></figure><div class=""/><figure class="fj fl jh ji jj hw ff fg paragraph-image"><div class="ff fg jg"><img src="../Images/16bf1280892851ab93387dbd386f5173.png" data-original-src="https://miro.medium.com/v2/resize:fit:512/format:webp/1*_8ouudNXA0l9vaZ4pfOEgA.png"/></div></figure><p id="d997" class="pw-post-body-paragraph jk jl ij jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">你可以在这里找到挑战:<a class="ae ki" href="https://ciphershastra.com/shilpkaar.html" rel="noopener ugc nofollow" target="_blank">https://ciphershastra.com/shilpkaar.html</a></p><p id="de0f" class="pw-post-body-paragraph jk jl ij jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">与差异，其中一个最恼人的难题。从维基百科来看，<a class="ae ki" href="https://en.wikipedia.org/wiki/Shilpkar" rel="noopener ugc nofollow" target="_blank"> Shilpkar </a>是<em class="kj">一个工匠社区，主要与凹版技术和绘画</em>有关。这确实是一个提示，告诉我们要解决这个难题必须做些什么。特别是，为了解决这个难题，我们需要精心制作一组数据，使我们能够通过挑战契约中的多重复杂检查。</p><p id="95d3" class="pw-post-body-paragraph jk jl ij jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">但首先我们需要找到第一把锁的钥匙，它藏在显眼的地方。</p><h1 id="708b" class="kk kl ij bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">开启</h1><p id="f561" class="pw-post-body-paragraph jk jl ij jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh hn dt translated">查看这些函数，我们可以看到,<code class="ei ln lo lp lq b">roulette()</code>函数首先受到被调用函数在<code class="ei ln lo lp lq b">shilpkaar</code>映射中的要求的保护。看着合同，似乎实现这一点的唯一可能的方法是首先调用<code class="ei ln lo lp lq b">unlock()</code>函数并通过所有检查。</p><p id="b422" class="pw-post-body-paragraph jk jl ij jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">然而，解锁功能第一次检查似乎锁定我们调用它！第一次检查需要将状态变量<code class="ei ln lo lp lq b">gate1Unlocked</code>和<code class="ei ln lo lp lq b">gate2Unlocked</code>设置为<code class="ei ln lo lp lq b">true</code>。这两个变量是统一的(意味着它们都是假的)，并且它们没有在任何地方设置。</p><p id="d060" class="pw-post-body-paragraph jk jl ij jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">通常，当遇到这样的难题时，要么有一个数组下溢可以利用，要么有一个更微妙的问题，即在本地声明复杂数据类型，而不指定其数据位置。这是什么意思？回到Solidity 0.4，你可以声明一个局部复杂变量(比如一个结构)而不用指定它的数据位置。如果您没有指定它，那么默认情况下，它将指向一个存储位置。特别是约定存储器的槽0。这是可以的，只要你不写它，只是用它来指向正确的位置。但是，如果您在将它指向有效位置之前对其进行写入，它将直接覆盖从槽0开始的约定存储的内容。</p><p id="98b7" class="pw-post-body-paragraph jk jl ij jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">这正是在<code class="ei ln lo lp lq b">unlock</code>功能中发生的事情:</p><pre class="lr ls lt lu fr lv lq lw lx aw ly dt"><span id="630e" class="lz kl ij lq b fw ma mb l mc md">function unlock(bytes32 _name, bytes32 _password) external { regInfo regRecord; regRecord.name = _name; regRecord.password = _password;</span></pre><p id="89e6" class="pw-post-body-paragraph jk jl ij jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated"><code class="ei ln lo lp lq b">regRecord</code>被声明但没有指向有效的位置，然后它的成员被设置为<code class="ei ln lo lp lq b">_name</code>和<code class="ei ln lo lp lq b">_password</code>。因为<code class="ei ln lo lp lq b">regRecord.name</code>和<code class="ei ln lo lp lq b">regRecord.password</code>是<code class="ei ln lo lp lq b">bytes32</code>变量，实际上是指向契约存储的槽0和槽1(每个槽长32字节)。</p><p id="8bda" class="pw-post-body-paragraph jk jl ij jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">这使我们能够控制合同存储的前两个插槽。</p><p id="ed86" class="pw-post-body-paragraph jk jl ij jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">这部分难题的第二部分是认识到有不止一个变量映射到槽0，槽1也是如此。特别是:</p><pre class="lr ls lt lu fr lv lq lw lx aw ly dt"><span id="07d2" class="lz kl ij lq b fw ma mb l mc md">// Slot 0</span><span id="e77d" class="lz kl ij lq b fw me mb l mc md">address private garbageAddress;  //         160 bits</span><span id="bd1a" class="lz kl ij lq b fw me mb l mc md">bool private gate1Unlocked;      //         8 bits</span><span id="a5b6" class="lz kl ij lq b fw me mb l mc md">uint16 private gateKey1;         //         16 bits</span><span id="ecb2" class="lz kl ij lq b fw me mb l mc md">uint72 public rouletteStartTime; //         72 bits</span><span id="8be0" class="lz kl ij lq b fw me mb l mc md">// TOTAL   256 bits = 32 bytes = 1 slot<br/></span><span id="a539" class="lz kl ij lq b fw me mb l mc md">// Slot 1</span><span id="af5a" class="lz kl ij lq b fw me mb l mc md">uint64 private gateKey2;         //         64 bits</span><span id="1301" class="lz kl ij lq b fw me mb l mc md">uint64 private gateKey3;         //         64 bits</span><span id="9889" class="lz kl ij lq b fw me mb l mc md">bool private gate2Unlocked;      //         8 bits</span><span id="2227" class="lz kl ij lq b fw me mb l mc md">uint64 private gateKey4;         //         64 bits</span><span id="462e" class="lz kl ij lq b fw me mb l mc md">uint56 private gateKey5;         //         56 bits</span><span id="151c" class="lz kl ij lq b fw me mb l mc md">// TOTAL   256 bits = 32 bytes = 1 slot</span></pre><p id="e1c7" class="pw-post-body-paragraph jk jl ij jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">有了这些信息，我们可以制作一组数据，让我们通过挑战合同中的多项检查。</p><h1 id="d650" class="kk kl ij bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">前两次检查</h1><p id="41bc" class="pw-post-body-paragraph jk jl ij jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh hn dt translated"><code class="ei ln lo lp lq b">gate1Unlocked</code>和<code class="ei ln lo lp lq b">gate2Unlocked</code>的值被设置为<code class="ei ln lo lp lq b">true</code>以通过第一次检查。然后，第二次检查要求我们在<code class="ei ln lo lp lq b">garbageAddress</code>变量中填入一个满足以下期望的值:</p><pre class="lr ls lt lu fr lv lq lw lx aw ly dt"><span id="77fe" class="lz kl ij lq b fw ma mb l mc md">require( uint256(garbageAddress) &gt; 2**153 + garbageNonce &amp;&amp; uint256(garbageAddress) &lt;= 2**160 - ((garbageDivisor - 1) - garbageNonce), "Problem With garbageAddress" );</span></pre><p id="527a" class="pw-post-body-paragraph jk jl ij jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">考虑到条件，我们可以将<code class="ei ln lo lp lq b">garbageAddress</code>设置为:</p><pre class="lr ls lt lu fr lv lq lw lx aw ly dt"><span id="f29f" class="lz kl ij lq b fw ma mb l mc md">garbageAddress = address(uint160(2**153 + garbageNonce + 1));</span></pre><p id="2f47" class="pw-post-body-paragraph jk jl ij jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">并通过两项测试。因为<code class="ei ln lo lp lq b">garbageNonce</code>是公共的，我们可以读取它并在公式中使用它。</p><h1 id="fb55" class="kk kl ij bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated"><strong class="ak">素数之谜和万能钥匙</strong></h1><p id="f7a7" class="pw-post-body-paragraph jk jl ij jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh hn dt translated">这部分是最难按照<code class="ei ln lo lp lq b">masterKey</code>值制作的。下一张支票看起来像这样:</p><pre class="lr ls lt lu fr lv lq lw lx aw ly dt"><span id="92f5" class="lz kl ij lq b fw ma mb l mc md">require( gateKey3 &lt; (uint256(uint64(-1)) * 49) / 100 &amp;&amp; gateKey4 &lt; (uint256(uint64(-1)) * 51) / 100 &amp;&amp; probablyPrime(gateKey3) &amp;&amp; probablyPrime(gateKey4), "Problem with gateKeys" );</span></pre><p id="ec96" class="pw-post-body-paragraph jk jl ij jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">基本上就是说<code class="ei ln lo lp lq b">gateKey3</code>必须小于<code class="ei ln lo lp lq b">uint64</code>最大值的49%<code class="ei ln lo lp lq b">gateKey4</code>必须小于<code class="ei ln lo lp lq b">uint64</code>最大值的51%。哦，两者都可能是质数！</p><p id="bb3d" class="pw-post-body-paragraph jk jl ij jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">因为我需要这个密钥加起来达到某个值才能使<code class="ei ln lo lp lq b">masterKey</code>有效，所以我精心制作了一个值来加上和减去<code class="ei ln lo lp lq b">gateKey3</code>和<code class="ei ln lo lp lq b">gateKey4</code>。这样，通过将<code class="ei ln lo lp lq b">gateKey3</code>和<code class="ei ln lo lp lq b">gateKey4</code>相加，额外的值增加和减少相互抵消，但是允许我们将<code class="ei ln lo lp lq b">gateKey3</code>和<code class="ei ln lo lp lq b">gateKey4</code>的值带到期望的范围:</p><pre class="lr ls lt lu fr lv lq lw lx aw ly dt"><span id="8794" class="lz kl ij lq b fw ma mb l mc md">uint64 gateKeysCompensation = uint64(2**63 - ((uint256(type(uint64).max) * 49) / 100));</span></pre><p id="6d28" class="pw-post-body-paragraph jk jl ij jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">现在我们可以将<code class="ei ln lo lp lq b">gateKey3</code>和<code class="ei ln lo lp lq b">gateKey4</code>值定义为:</p><pre class="lr ls lt lu fr lv lq lw lx aw ly dt"><span id="bedb" class="lz kl ij lq b fw ma mb l mc md">uint64 gateKey3 = 2**63 - gateKeysCompensation; uint64 gateKey4 = 2**63 + gateKeysCompensation;</span></pre><p id="28e2" class="pw-post-body-paragraph jk jl ij jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">这使得两个值都在范围内，但它们仍然不是质数。为了找到最接近期望值的质数，我使用了这个<a class="ae ki" href="https://www.numberempire.com/primenumbers.php" rel="noopener ugc nofollow" target="_blank">网站</a>来计算与给定质数接近的质数(下一个或上一个)。通过传递<code class="ei ln lo lp lq b">gateKey3</code>和<code class="ei ln lo lp lq b">gatekey4</code>的值，我们可以选通它们各自之前的质数，并调整公式以达到目标:</p><pre class="lr ls lt lu fr lv lq lw lx aw ly dt"><span id="0bb8" class="lz kl ij lq b fw ma mb l mc md">uint64 gateKey3 = 2**63 - 44 - gateKeysCompensation; uint64 gateKey4 = 2**63 - 92 + gateKeysCompensation;</span></pre><p id="dc33" class="pw-post-body-paragraph jk jl ij jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated"><code class="ei ln lo lp lq b">masterKey</code>是这样计算的:</p><pre class="lr ls lt lu fr lv lq lw lx aw ly dt"><span id="7b42" class="lz kl ij lq b fw ma mb l mc md">uint256 masterKey = uint256(gateKey1) + uint256(gateKey2) + uint256(gateKey3) + uint256(gateKey4) + uint256(gateKey5);</span></pre><p id="52ec" class="pw-post-body-paragraph jk jl ij jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">我们需要<code class="ei ln lo lp lq b">masterKey</code>满足以下检查:</p><pre class="lr ls lt lu fr lv lq lw lx aw ly dt"><span id="6c9e" class="lz kl ij lq b fw ma mb l mc md">require( masterKey &gt; (2**65 + 2**56) + masterNonce &amp;&amp; masterKey &lt; (2**65 + 2**56 + 2**16) - ((masterDivisor - 1) - masterNonce), "Problem with masterkey" );</span></pre><p id="9248" class="pw-post-body-paragraph jk jl ij jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">如果我们把组成<code class="ei ln lo lp lq b">masterKey</code>的所有值加起来，我们可以看到我们少了<code class="ei ln lo lp lq b">masterNonce</code>和额外的139。这很好，因为我们有一个可用的自由变量<code class="ei ln lo lp lq b">gateKey1</code>。我们可以使用这个变量将缺少的值添加到<code class="ei ln lo lp lq b">masterKey</code>中。它是一个<code class="ei ln lo lp lq b">uint16</code>，但足以保持所需的偏移:</p><pre class="lr ls lt lu fr lv lq lw lx aw ly dt"><span id="9ec1" class="lz kl ij lq b fw ma mb l mc md">uint16 gateKey1 = 139 + uint16(masterNonce);</span></pre><h1 id="6aa8" class="kk kl ij bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated"><strong class="ak">轮盘开始时间</strong></h1><p id="af1c" class="pw-post-body-paragraph jk jl ij jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh hn dt translated">我们需要设置的最后一个值是<code class="ei ln lo lp lq b">rouletteStartTime</code>。这将用于<code class="ei ln lo lp lq b">roulette</code>功能检查的时间:</p><pre class="lr ls lt lu fr lv lq lw lx aw ly dt"><span id="c8af" class="lz kl ij lq b fw ma mb l mc md">require(block.timestamp &gt;= timeToRoll[msg.sender], "Problem with timeToRoll");</span></pre><p id="9683" class="pw-post-body-paragraph jk jl ij jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">最简单的就是设置为0，这样我们就可以随时调用<code class="ei ln lo lp lq b">roulette</code>了。</p><h1 id="8c44" class="kk kl ij bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated"><strong class="ak">最终破解</strong></h1><p id="ecd7" class="pw-post-body-paragraph jk jl ij jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh hn dt translated">现在有了所有这些值，我们可以为<code class="ei ln lo lp lq b">name</code>和<code class="ei ln lo lp lq b">password</code>设计值:</p><pre class="lr ls lt lu fr lv lq lw lx aw ly dt"><span id="f0f4" class="lz kl ij lq b fw ma mb l mc md">bytes32 name = bytes32(abi.encodePacked(rouletteStartTime, gateKey1, gate1Unlocked, garbageAddress)); bytes32 password = bytes32(abi.encodePacked(gateKey5, gateKey4, gate2Unlocked, gateKey3, gateKey2));</span></pre><p id="6af8" class="pw-post-body-paragraph jk jl ij jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">我们可以用这个值调用<code class="ei ln lo lp lq b">unlock</code>，然后调用<code class="ei ln lo lp lq b">roulette</code>来赢得挑战</p><h1 id="650e" class="kk kl ij bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">Github回购</h1><p id="f67f" class="pw-post-body-paragraph jk jl ij jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh hn dt translated">你可以在我的Github repo:<a class="ae ki" href="https://github.com/robercano/ciphershastra" rel="noopener ugc nofollow" target="_blank">https://github.com/robercano/ciphershastra</a>中找到这个解决方案以及其他的密码破解挑战</p><h1 id="637d" class="kk kl ij bd km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh dt translated">关于我</h1><p id="617f" class="pw-post-body-paragraph jk jl ij jm b jn li jp jq jr lj jt ju jv lk jx jy jz ll kb kc kd lm kf kg kh hn dt translated">我叫罗伯特·卡诺，你可以在https://thesolidchain.com找到我</p><blockquote class="mf"><p id="c993" class="mg mh ij bd mi mj mk ml mm mn mo kh el translated">加入Coinmonks <a class="ae ki" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae ki" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>了解加密交易和投资</p></blockquote><h1 id="3c20" class="kk kl ij bd km kn ko kp kq kr ks kt ku kv mp kx ky kz mq lb lc ld mr lf lg lh dt translated">另外，阅读</h1><ul class=""><li id="bee1" class="ms mt ij jm b jn li jr lj jv mu jz mv kd mw kh mx my mz na dt translated"><a class="ae ki" href="https://coincodecap.com/wazirx-nft-review" rel="noopener ugc nofollow" target="_blank">瓦济里克斯NFT评论</a> | <a class="ae ki" href="https://coincodecap.com/bitsgap-vs-pionex" rel="noopener ugc nofollow" target="_blank">比茨盖普vs皮奥克斯</a> | <a class="ae ki" href="https://coincodecap.com/tangem-wallet-review" rel="noopener ugc nofollow" target="_blank">坦吉姆评论</a></li><li id="b72f" class="ms mt ij jm b jn nb jr nc jv nd jz ne kd nf kh mx my mz na dt translated"><a class="ae ki" href="https://coincodecap.com/create-a-dapp-on-ethereum-using-solidity" rel="noopener ugc nofollow" target="_blank">如何使用Solidity在以太坊上创建DApp？</a></li><li id="0641" class="ms mt ij jm b jn nb jr nc jv nd jz ne kd nf kh mx my mz na dt translated"><a class="ae ki" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a> | <a class="ae ki" href="https://coincodecap.com/okex-vs-binance" rel="noopener ugc nofollow" target="_blank"> OKEx vs币安</a></li><li id="5643" class="ms mt ij jm b jn nb jr nc jv nd jz ne kd nf kh mx my mz na dt translated"><a class="ae ki" href="https://coincodecap.com/binance-vs-ftx" rel="noopener ugc nofollow" target="_blank">币安vs FTX </a> | <a class="ae ki" href="https://coincodecap.com/solana-wallets" rel="noopener ugc nofollow" target="_blank">最佳(SOL)索拉纳钱包</a></li><li id="9930" class="ms mt ij jm b jn nb jr nc jv nd jz ne kd nf kh mx my mz na dt translated"><a class="ae ki" href="https://coincodecap.com/swap-crypto-on-uniswap" rel="noopener ugc nofollow" target="_blank">如何在Uniswap上交换加密？</a> | <a class="ae ki" href="https://coincodecap.com/a-ads-review" rel="noopener ugc nofollow" target="_blank"> A-Ads审查</a></li></ul></div></div>    
</body>
</html>