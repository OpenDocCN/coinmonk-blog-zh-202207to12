<html>
<head>
<title>Creating a P2P tic-tac-toe gambling smart contract on Aleph Zero using Rust ink!; understanding the psp22 standard</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Rust ink在Aleph Zero上创建P2P井字游戏智能合约！；了解psp22标准</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/creating-a-p2p-tic-tac-toe-gambling-smart-contract-on-aleph-zero-using-ink-9702f7714f55?source=collection_archive---------3-----------------------#2022-11-17">https://medium.com/coinmonks/creating-a-p2p-tic-tac-toe-gambling-smart-contract-on-aleph-zero-using-ink-9702f7714f55?source=collection_archive---------3-----------------------#2022-11-17</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="18ec" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt jo translated">这是新的一天，也是学习新事物的好时机；我来帮助您实现这一目标:)。本文旨在指导您使用Rust(带墨水)创建一个井字游戏P2P游戏(带有赌博功能！).</p><p id="d0f2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在经历了这么长时间的阅读后(也是实践性的)，你应该能够与像Aleph Zero这样的衬底链上的<a class="ae jx" rel="noopener" href="/supercolony/psp22-the-first-smart-contract-standard-on-the-polkadot-ecosystem-fef3f6c27d88"> PSP22标准令牌</a>进行交互(这是我们的主要关注点)。</p><p id="dcec" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我将在本文中一直演示<strong class="is hu"><em class="jy">PSP 22::balance of()</em></strong>，<strong class="is hu"><em class="jy">PSP 22::allow ance()</em></strong>，<strong class="is hu"><em class="jy">PSP 22::transfer()</em></strong>和<strong class="is hu"><em class="jy">PSP 22::transfer from()</em></strong>PSP 22方法。</p><blockquote class="jz ka kb"><p id="d576" class="iq ir jy is b it iu iv iw ix iy iz ja kc jc jd je kd jg jh ji ke jk jl jm jn hm dt translated">有趣的事实:我把坚硬变成了生锈的墨水！反之亦然，JSYK😎</p></blockquote><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div class="ab fr cl kk"><img src="../Images/80360265f13993ddb768ba399a5ad5b3.png" data-original-src="https://miro.medium.com/v2/0*wQKxAZc8-GZ6mT5i"/></div><figcaption class="kn ko fg fe ff kp kq bd b be z ek">Image credits: <a class="ae jx" href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fwww.istockphoto.com%2Fillustrations%2Ftic-tac-toe&amp;psig=AOvVaw17JY8cHT26Zy_RLBTxFugD&amp;ust=1668722492879000&amp;source=images&amp;cd=vfe&amp;ved=0CBEQjhxqFwoTCKig1Kfbs_sCFQAAAAAdAAAAABAD" rel="noopener ugc nofollow" target="_blank">https://istockphoto.com</a></figcaption></figure><p id="a1e4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">显然，五分之二的人知道“井字游戏”，尽管根据人们的判断力、取向、地点或选择，它可能有不同的名称。</p><blockquote class="jz ka kb"><p id="96c7" class="iq ir jy is b it iu iv iw ix iy iz ja kc jc jd je kd jg jh ji ke jk jl jm jn hm dt translated"><strong class="is hu">请注意，本文中的源代码没有经过任何审核，容易受到漏洞的影响；这完全是为了教育目的，没有别的。</strong></p></blockquote><p id="9a5e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果你从来没有听说过井字游戏，这是一种棋盘游戏，有一个3×3单元的正方形网格(根据玩家的喜好可能会有更大的数量，例如，5×5，9×9等；通常在由奇数乘奇数组成的格子中)，每个玩家使用两个字符，通常是“X”和“O”。</p><p id="a470" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">每个玩家通过将他们相关的角色插入(画)到一个空的格子中来移动，目的是创建一个水平、对角或垂直的图案，同时防止他们的对手做同样的事情，以及智胜他们，以便无障碍地实现他们的完整线。对于每一轮，如果没有赢家(即所有的位置都被填满，没有任何玩家制作有效的图案)，游戏被标记为平局，新一轮开始。</p><p id="39b7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">从下图可以看出，被分配了“X”符号的玩家在所有三轮中都是赢家(忽略“O”没有被打满所有回合的事实；二号玩家是个呆子)。</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="fe ff kr"><img src="../Images/59527fc8b6765d05bd36c7000f48659c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yzhhcly76tRL6Jn8wWgwHg.png"/></div></div><figcaption class="kn ko fg fe ff kp kq bd b be z ek">Image credits: <a class="ae jx" href="https://en.wikipedia.org" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org</a></figcaption></figure><p id="171b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这个例子中，两个玩家都将下注一定数量来玩游戏。胜者拿走所有代币，游戏结束，但如果是平局，代币退还给双方，游戏结束。每轮游戏结束后，棋盘也会重置。</p><p id="dd35" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">既然您已经知道了这个游戏是如何玩的，那么让我们深入到Rust的实际实现中😎。很酷吧: )</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="fe ff kw"><img src="../Images/c1be77ede2016350bb005f9b3f24fbc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*IiAe56b5TvFIcDC3.gif"/></div></div><figcaption class="kn ko fg fe ff kp kq bd b be z ek">Image credits: <a class="ae jx" href="https://tenor.com" rel="noopener ugc nofollow" target="_blank">https://tenor.com</a></figcaption></figure><p id="8cbf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">请点击<a class="ae jx" href="https://github.com/paritytech/cargo-contract" rel="noopener ugc nofollow" target="_blank">此链接</a>开始安装Rust智能合同开发的“货物合同”。</p><h1 id="e98b" class="kx ky ht bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">项目设置</h1><p id="0d2d" class="pw-post-body-paragraph iq ir ht is b it lv iv iw ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn hm dt translated">在我们开始之前，项目文件夹必须有一个已定义的结构，我们将创建两个用于构建契约的文件。</p><ul class=""><li id="db23" class="ma mb ht is b it iu ix iy jb mc jf md jj me jn mf mg mh mi dt translated">cargo.toml</li><li id="76c5" class="ma mb ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi dt translated">图书馆</li></ul><p id="5dfa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">“cargo.toml”更像是NPM著名的“package . JSON ”( node . js ),它帮助我们定义与项目相关的属性、依赖关系和信息，而我们将使用“lib.rs”作为我们的入口文件(所有的重要工作都将在这里完成)。</p><p id="e496" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这是将在这个项目中使用的两个文件。</p><p id="8a61" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">使用<a class="ae jx" href="https://github.com/EdinyangaOttoho/ink-tic-tac-toe/blob/master/Cargo.toml" rel="noopener ugc nofollow" target="_blank">这个文件</a>的内容组成你的“cargo.toml”文件。</p><p id="c7cb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">你基本上需要在文件<strong class="is hu">的第4行</strong>的“作者”键中修改名字和电子邮件，以匹配你的名字。</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="fe ff mo"><img src="../Images/8b89a068d5204fef1c70d325970ad7e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b1nBCaAEQYwNFPZE4lqQwA.png"/></div></div><figcaption class="kn ko fg fe ff kp kq bd b be z ek">Update the authors’ array to contain your name and email.</figcaption></figure><p id="8fe8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">该文件将如下所示:</p><pre class="kf kg kh ki fq mp mq mr bn ms mt bi"><span id="38c6" class="mu ky ht mq b be mv mw l mx my">[package]<br/>name = "tic_tac_toe"<br/>version = "0.9.6"<br/>authors = ["Edinyanga Ottoho &lt;elzucky@gmail.com&gt;"]<br/>edition = "2021"<br/>overflow-checks = false<br/><br/>[dependencies]<br/><br/>ink = { git = "https://github.com/paritytech/ink", rev = "4655a8b4413cb50cbc38d1b7c173ad426ab06cde", default-features = false}<br/>scale = { package = "parity-scale-codec", version = "3", default-features = false, features = ["derive"] }<br/>scale-info = { version = "2", default-features = false, features = ["derive"], optional = true }<br/><br/>openbrush = { git = "https://github.com/727-Ventures/openbrush-contracts", branch="main", default-features = false, features = ["psp22"] }<br/><br/>[lib]<br/>overflow-checks = false<br/>name = "tic_tac_toe"<br/>path = "lib.rs"<br/>crate-type = [<br/>    # Used for normal contract Wasm blobs.<br/>    "cdylib"<br/>]<br/>[profile.release]<br/>overflow-checks = false<br/><br/>[features]<br/>default = ["std"]<br/>std = [<br/>    "ink/std",<br/>    "scale/std",<br/>    "scale-info/std",<br/>    "openbrush/std"<br/>]<br/>psp22 = ["openbrush/psp22"]<br/>ink-as-dependency = []</span></pre><h1 id="6385" class="kx ky ht bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">定义导入和存储结构</h1><p id="ebfc" class="pw-post-body-paragraph iq ir ht is b it lv iv iw ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn hm dt translated">首先，我们需要创建模块并导入所有必要的依赖项，以适应智能合约的功能，以及构造函数初始化代码和将在整个源代码中使用的存储键的结构。</p><pre class="kf kg kh ki fq mp mq mr bn ms mt bi"><span id="1300" class="mu ky ht mq b be mv mw l mx my">#![cfg_attr(not(feature = "std"), no_std)]<br/><br/>#[cfg(not(feature = "ink-as-dependency"))]<br/><br/>#[ink::contract]<br/>pub mod tic_tac_toe {<br/><br/>    use ink::prelude::vec;<br/>    use ink::prelude::vec::Vec;<br/>    <br/>    use openbrush::contracts::traits::psp22::PSP22Ref;<br/><br/>    use ink::env::CallFlags;<br/><br/>    use openbrush::traits::Storage;<br/><br/>    #[ink(storage)]<br/>    #[derive(Default, Storage)]<br/><br/>    pub struct TicTacToe {<br/>        board: Vec&lt;u64&gt;, //0 to 8 cells<br/>        turn: AccountId,<br/>        symbols: ink::storage::Mapping&lt;AccountId, u64&gt;,<br/>        player_one: AccountId,<br/>        player_two: AccountId,<br/>        staking_token: AccountId,<br/>        stake_amount: Balance,<br/>        stakes: ink::storage::Mapping&lt;AccountId, Balance&gt;,<br/>        last_winner: AccountId,<br/>    }<br/>}</span></pre><p id="1370" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">存储结构“TicTacToe”中定义的键将在本文中继续讨论；不要慌:)。</p><h1 id="ebee" class="kx ky ht bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">构造函数</h1><p id="6158" class="pw-post-body-paragraph iq ir ht is b it lv iv iw ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn hm dt translated">我们要做的下一件事是在“tic_tac_toe”模块的实现中定义构造函数，紧接在“TicTacToe”结构之后，该结构将在部署我们的智能合约时被调用，以便初始化一些我们希望默认注册到其中的值。</p><p id="dac4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们想要定义玩家的地址、游戏中使用的PSP22令牌、他们的符号以及给定游戏的赌注金额。</p><p id="22bf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这些可以作为参数提供给构造函数，因此:</p><pre class="kf kg kh ki fq mp mq mr bn ms mt bi"><span id="a99d" class="mu ky ht mq b be mv mw l mx my">impl TicTacToe {<br/>    /// Creates a new instance of this contract.<br/>    #[ink(constructor)]<br/>    pub fn new(player_one:AccountId, player_two:AccountId, player_one_symbol:u64, player_two_symbol:u64, staking_token: AccountId, stake_amount: Balance) -&gt; Self {<br/>        //Do something here...<br/>    }<br/>}</span></pre><p id="0aba" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在“new()”方法中，我们必须存储这些值并进行一些例行检查，这样在游戏过程中就不会出现异常的契约行为。</p><pre class="kf kg kh ki fq mp mq mr bn ms mt bi"><span id="b164" class="mu ky ht mq b be mv mw l mx my">let mut contract = Self::default();<br/><br/>let board = vec![0; 9]; //empty array<br/><br/>contract.board = board; //set board to empty state<br/><br/>contract.staking_token = staking_token; //set staking token<br/><br/>contract.stake_amount = stake_amount; //set stake amount<br/><br/>assert!(player_one != player_two); //addresses must not be the same<br/><br/>assert!(player_one_symbol != player_two_symbol); //symbols must be distinct<br/><br/>assert!(<br/>    (player_one_symbol == 1 || player_one_symbol == 2)<br/>        &amp;&amp; (player_two_symbol == 1 || player_two_symbol == 2)<br/>); //symbols must be either 1 or 2<br/><br/>contract.player_one = player_one; //set player one address<br/><br/>contract.player_two = player_two; //set player two address<br/><br/>contract.symbols.insert(player_one, &amp;player_one_symbol); //set player one symbol<br/><br/>contract.symbols.insert(player_two, &amp;player_two_symbol); //set player two symbol<br/><br/>contract.turn = player_one; //initialize turn to player one<br/><br/>contract</span></pre><p id="e8ba" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在本例中，我们将0作为空单元格，1作为X，2作为O。我们还将使用0到8来表示棋盘的单元格，从左上到右下依次排列，这意味着左上的单元格是0，右下的单元格是8，中间的单元格是5。</p><p id="da1d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">从上到下分析上面的代码，我们看到创建了一个空数组，我们循环遍历它，将0插入到从0到8的每个索引中，这意味着开始是一个空的棋盘。</p><p id="330b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们还从其参数中设置了赌注标记以及赌注金额。</p><p id="2f6a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们要确保一号玩家没有使用和二号玩家相同的地址，也没有给他们分配相同的符号(仅限于1和2)。我们用提供的参数设置了一号玩家和二号玩家的地址。</p><p id="e95e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后，我们还将两个玩家选择的符号插入到一个映射中，将它们的地址作为关键字，将选择的符号作为<strong class="is hu"> u64 </strong> type中的值。</p><p id="be4f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后我们最终把一号玩家设为第一个回合。</p><p id="797f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">万岁！我们完成了我们的构造函数！</p><h1 id="ca75" class="kx ky ht bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">输出方法</h1><p id="aa76" class="pw-post-body-paragraph iq ir ht is b it lv iv iw ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn hm dt translated">虽然我们很想制作一个有趣的游戏，但我们想知道在智能合约中存储和动态方面发生了什么，因此我们将创建一些方法来随意为我们提供存储值。</p><pre class="kf kg kh ki fq mp mq mr bn ms mt bi"><span id="2148" class="mu ky ht mq b be mv mw l mx my">#[ink(message)]<br/>pub fn get_stake_amount(&amp;self) -&gt; Balance {<br/>    self.stake_amount //amount to be staked in game<br/>}<br/><br/>#[ink(message)]<br/>pub fn get_last_winner(&amp;self) -&gt; AccountId {<br/>    self.last_winner //address of most recent winner<br/>}<br/><br/>#[ink(message)]<br/>pub fn get_current_turn(&amp;self) -&gt; AccountId {<br/>    self.turn //who is meant to play?<br/>}<br/><br/>#[ink(message)]<br/>pub fn get_staking_token(&amp;self) -&gt; AccountId {<br/>    self.staking_token //get address of staking token smart contract<br/>}<br/><br/>#[ink(message)]<br/>pub fn get_player_two_stake(&amp;self) -&gt; Balance {<br/>    self.stakes.get(self.player_two).unwrap_or(0) //get total amount of tokens staked by player two<br/>}<br/><br/>#[ink(message)]<br/>pub fn get_player_one_stake(&amp;self) -&gt; Balance {<br/>    self.stakes.get(self.player_one).unwrap_or(0) //get total amount of tokens staked by player one<br/>}<br/><br/>#[ink(message)]<br/>pub fn get_player_two_symbol(&amp;self) -&gt; u64 {<br/>    self.symbols.get(self.player_two).unwrap_or(0) //get player two symbol<br/>}<br/><br/>#[ink(message)]<br/>pub fn get_player_one(&amp;self) -&gt; AccountId {<br/>    self.player_one //get player one address<br/>}<br/><br/>#[ink(message)]<br/>pub fn get_player_two(&amp;self) -&gt; AccountId {<br/>    self.player_two //get player two address<br/>}<br/><br/>#[ink(message)]<br/>pub fn get_player_one_symbol(&amp;self) -&gt; u64 {<br/>    self.symbols.get(self.player_one).unwrap_or(0) //get player one symbol<br/>}<br/><br/>#[ink(message)]<br/>pub fn get_board(&amp;self) -&gt; Vec&lt;u64&gt; {<br/>    //read and return board as array<br/>    let board = &amp;self.board;<br/>    board.to_vec()<br/>}</span></pre><p id="4f84" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">上面定义的大多数方法都是不言自明的，但是我将对它们中的每一个进行简单介绍，以便清楚地理解它们打算输出什么值。</p><ul class=""><li id="2149" class="ma mb ht is b it iu ix iy jb mc jf md jj me jn mf mg mh mi dt translated"><strong class="is hu"> get_stake_amount() <br/> </strong>用于获取玩家投入游戏的金额，以供玩家进行游戏。</li><li id="3fcd" class="ma mb ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi dt translated"><strong class="is hu"> get_last_winner() <br/> </strong>用于获取最近赢得游戏的玩家的地址。</li><li id="b6bf" class="ma mb ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi dt translated"><strong class="is hu"> get_current_turn() </strong> <br/>这个用来获取该轮到的玩家。</li><li id="f824" class="ma mb ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi dt translated"><strong class="is hu">get _ staking _ token()</strong><br/>这用于获取玩家将用作赌注的赌注令牌合同的地址。</li><li id="2e27" class="ma mb ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi dt translated"><strong class="is hu">get _ player _ one _ stake()</strong><br/>用于获取玩家一下注的代币总数。</li><li id="da2b" class="ma mb ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi dt translated"><strong class="is hu">get _ player _ two _ stake()</strong><br/>用于获取玩家二下注的代币总数。</li><li id="aa56" class="ma mb ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi dt translated"><strong class="is hu"> get_player_one() </strong> <br/>这个用来获取玩家一的钱包地址。</li><li id="06a4" class="ma mb ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi dt translated"><strong class="is hu"> get_player_two() <br/> </strong>这个用来获取玩家二的钱包地址。</li><li id="a22d" class="ma mb ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi dt translated"><strong class="is hu">get _ player _ one _ symbol()</strong><br/>这个用来获取玩家一的符号。</li><li id="efe8" class="ma mb ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi dt translated"><strong class="is hu">get _ player _ two _ symbol()<br/></strong>这个用来获取玩家二的符号。</li><li id="fa5f" class="ma mb ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi dt translated"><strong class="is hu"> get_board() <br/> </strong>返回一个数组，表示棋盘上从0到8的单元格的当前游戏状态。</li></ul><h1 id="73b7" class="kx ky ht bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">内联助手方法</h1><p id="4909" class="pw-post-body-paragraph iq ir ht is b it lv iv iw ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn hm dt translated">有些方法将在内部使用，以帮助确定值以及在智能协定中执行入站操作。</p><p id="2610" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">他们是这样的:</p><pre class="kf kg kh ki fq mp mq mr bn ms mt bi"><span id="11a8" class="mu ky ht mq b be mv mw l mx my">#[inline]<br/>pub fn _has_won(&amp;self, symbol: u64) -&gt; bool {<br/>    let vertical = [[0,3,6], [1,4,7], [2,5,8]];<br/>    let horizontal = [[0,1,2], [3,4,5], [6,7,8]];<br/>    let diagonal = [[0,4,8], [2,4,6]];<br/>    <br/>    //check vertical<br/>    let mut v_win = false;<br/>    for i in 0..=2 {<br/>        let mut count = 0;<br/>        for j in 0..=2 {<br/>            if self.board[vertical[i][j]] == symbol {<br/>                count += 1;<br/>            }<br/>        }<br/>        if count == 3 {<br/>            v_win = true;<br/>            break;<br/>        }<br/>    }<br/><br/>    //check horizontal<br/>    let mut h_win = false;<br/>    for i in 0..=2 {<br/>        let mut count = 0;<br/>        for j in 0..=2 {<br/>            if self.board[horizontal[i][j]] == symbol {<br/>                count += 1;<br/>            }<br/>        }<br/>        if count == 3 {<br/>            h_win = true;<br/>            break;<br/>        }<br/>    }<br/><br/>    //check diagonal<br/>    let mut d_win = false;<br/>    for i in 0..=1 {<br/>        let mut count = 0;<br/>        for j in 0..=2 {<br/>            if self.board[diagonal[i][j]] == symbol {<br/>                count += 1;<br/>            }<br/>        }<br/>        if count == 3 {<br/>            d_win = true;<br/>            break;<br/>        }<br/>    }<br/><br/>    if v_win == true || h_win == true || d_win == true {<br/>        true<br/>    }<br/>    else {<br/>        false<br/>    }<br/><br/>}<br/><br/>#[inline]<br/>pub fn _clear_board(&amp;mut self) {<br/>    let board = vec![0; 9];<br/>    self.board = board;<br/>}<br/><br/>#[inline]<br/>pub fn _is_cell_empty(&amp;self, cell: u64) -&gt; bool {<br/>    if self.board[usize::try_from(cell).unwrap()] == 0 {<br/>        true<br/>    } else {<br/>        false<br/>    }<br/>}<br/><br/>#[inline]<br/>pub fn _is_board_filled(&amp;self) -&gt; bool {<br/>    let mut filled_cells = 0;<br/>    let board = &amp;self.board;<br/>    for cell in 0..=8 {<br/>        if board[usize::try_from(cell).unwrap()] != 0 {<br/>            filled_cells += 1;<br/>        }<br/>    }<br/>    if filled_cells == 9 {<br/>        true<br/>    } else {<br/>        false<br/>    }<br/>}<br/><br/>#[inline]<br/>pub fn _reward_winner(&amp;mut self, account: AccountId) {<br/>    let total_stakes = PSP22Ref::balance_of(&amp;self.staking_token, Self::env().account_id()); //get total stakes<br/><br/>    PSP22Ref::transfer(<br/>        &amp;self.staking_token,<br/>        account,<br/>        total_stakes,<br/>        ink_prelude::vec![],<br/>    ); //transfer everything to the winner<br/><br/>    self.stakes.insert(self.player_one, &amp;0);<br/>    <br/>    self.stakes.insert(self.player_two, &amp;0);<br/>}<br/><br/>#[inline]<br/>pub fn _refund_tokens(&amp;mut self) {<br/>    let total_stakes = PSP22Ref::balance_of(&amp;self.staking_token, Self::env().account_id()); //get total stakes<br/>    let per_player = total_stakes / 2;<br/><br/>    PSP22Ref::transfer(<br/>        &amp;self.staking_token,<br/>        self.player_one,<br/>        per_player,<br/>        ink_prelude::vec![],<br/>    ); //transfer half to player one<br/>    PSP22Ref::transfer(<br/>        &amp;self.staking_token,<br/>        self.player_two,<br/>        per_player,<br/>        ink_prelude::vec![],<br/>    ); //transfer half to player two<br/><br/>    self.stakes.insert(self.player_one, &amp;0);<br/><br/>    self.stakes.insert(self.player_two, &amp;0);<br/><br/>}</span></pre><p id="e38b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">简而言之，我将解释上面的内联助手方法是做什么的，以防你没有清楚地掌握它们。</p><ul class=""><li id="5c34" class="ma mb ht is b it iu ix iy jb mc jf md jj me jn mf mg mh mi dt translated"><strong class="is hu">_ has _ won(symbol:u64)<br/></strong>此方法用于确定给定的符号是否为获胜符号。返回一个布尔值(真或假)。用于检查每个回合的赢家。</li><li id="ec04" class="ma mb ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi dt translated"><strong class="is hu"> _clear_board() <br/> </strong>该方法用于清空板子(视情况将所有单元格置0或空)。</li><li id="ab38" class="ma mb ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi dt translated"><strong class="is hu"> _is_cell_empty() <br/> </strong>这是用来判断给定的单元格是否为空(值为0)。</li><li id="e3ad" class="ma mb ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi dt translated"><strong class="is hu"> _is_board_filled() <br/></strong></li><li id="836b" class="ma mb ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi dt translated"><strong class="is hu">_ reward _ winner(address:account id)<br/></strong>此方法将所有可用的令牌作为参数转移到提供的地址。</li><li id="1ca9" class="ma mb ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi dt translated"><strong class="is hu"> _refund_tokens() <br/> </strong>此方法用于退还所有代币(适用于主动回合出现平局的情况)。</li></ul><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div class="fe ff kw"><img src="../Images/770852db6f1d835ea0dc5412912446d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*Tl3Dpkw3wjZkks_G.gif"/></div><figcaption class="kn ko fg fe ff kp kq bd b be z ek">Image credits: https://getyarn.io</figcaption></figure><h1 id="c735" class="kx ky ht bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">游戏部分</h1><p id="8fae" class="pw-post-body-paragraph iq ir ht is b it lv iv iw ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn hm dt translated">这是这个智能合同最重要的方面，因为如果不仔细检查，它可能会导致严重的后果。</p><p id="3253" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">成功的游戏有两种方法:</p><ul class=""><li id="37a7" class="ma mb ht is b it iu ix iy jb mc jf md jj me jn mf mg mh mi dt translated">stake _ tokens()</li><li id="b213" class="ma mb ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi dt translated">播放(单元格:u64)</li></ul><p id="393c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我将从第一个开始(尽管我应该这样做:)。</p><h2 id="78d1" class="mz ky ht bd kz na nb nc ld nd ne nf lh jb ng nh ll jf ni nj lp jj nk nl lt nm dt translated">stake _ tokens()</h2><pre class="kf kg kh ki fq mp mq mr bn ms mt bi"><span id="909d" class="mu ky ht mq b be mv mw l mx my">#[ink(message)]<br/>pub fn stake_tokens(&amp;mut self) {<br/>    let player = self.env().caller(); //get caller address<br/>    let stakes = self.stakes.get(player).unwrap_or(0); //get stake if existent<br/><br/>    assert!(player == self.player_one || player == self.player_two); //Caller must be player one or two<br/><br/>    if stakes &gt; 0 {<br/>        panic!("Already staked for this round")<br/>    } //Make sure player hasn't already staked<br/><br/>    let balance = PSP22Ref::balance_of(&amp;self.staking_token, player); //get user balance of token<br/><br/>    let allowance =<br/>        PSP22Ref::allowance(&amp;self.staking_token, player, Self::env().account_id()); //get spending allowance contract has to player<br/><br/>    assert!(balance &gt; self.stake_amount); //balance must be greater than stake amount<br/><br/>    assert!(allowance &gt; self.stake_amount); //allowance must be greater than stake amount<br/><br/>    //Transfer stake amount from caller (player) to contract<br/>    PSP22Ref::transfer_from_builder(<br/>        &amp;self.staking_token,<br/>        self.env().caller(),<br/>        Self::env().account_id(),<br/>        self.stake_amount,<br/>        ink::prelude::vec![],<br/>    )<br/>    .call_flags(CallFlags::default().set_allow_reentry(true))<br/>    .fire()<br/>    .expect("Transfer failed")<br/>    .expect("Transfer failed");<br/><br/>    self.stakes.insert(player, &amp;self.stake_amount); //Add stake amount to user stake<br/>}</span></pre><p id="f6e3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">您可以从上面的代码块中推断出，该方法用于存放下一轮的赌注标记(下注)。</p><p id="4940" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">首先，它检查呼叫者是一号玩家还是二号玩家，然后检查是否已经下注。</p><p id="5e3c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们还检查他们在赌注代币中的余额，确保其达到赌注金额，并且支出津贴足以让合同从玩家的钱包中收取赌注金额。</p><p id="ca97" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们最后从他们的钱包中转移赌注代币，并将赌注添加到玩家的赌注地图中。</p><h2 id="8acc" class="mz ky ht bd kz na nb nc ld nd ne nf lh jb ng nh ll jf ni nj lp jj nk nl lt nm dt translated">播放(单元格:u64)</h2><p id="be1e" class="pw-post-body-paragraph iq ir ht is b it lv iv iw ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn hm dt translated">此方法采用u64类型的参数，指定要播放的单元格。</p><pre class="kf kg kh ki fq mp mq mr bn ms mt bi"><span id="62e6" class="mu ky ht mq b be mv mw l mx my">#[ink(message)]<br/>pub fn play(&amp;mut self, cell: u64) {<br/>    assert!(cell &lt;= 8);<br/><br/>    let player = self.env().caller(); //get caller address<br/><br/>    assert!(player == self.player_one || player == self.player_two); //caller must be player one or two<br/><br/>    assert!(self.get_player_one_stake() &gt; 0 &amp;&amp; self.get_player_two_stake() &gt; 0); //both players must have staked<br/><br/>    let is_empty = self._is_cell_empty(cell); //check if cell is empty<br/><br/>    assert!(is_empty == true); //cell must be empty<br/><br/>    assert!(self.turn == player); //must be player's turn<br/><br/>    let mut board = self.get_board();<br/><br/>    let player_one_symbol = self.get_player_one_symbol();<br/>    let player_two_symbol = self.get_player_two_symbol();<br/><br/>    let cell_index = usize::try_from(cell).unwrap(); //convert index to usize<br/><br/>    board[cell_index] = self.symbols.get(player).unwrap_or(0);<br/><br/>    self.board = board;<br/><br/>    let player_one_won = self._has_won(player_one_symbol);<br/><br/>    let player_two_won = self._has_won(player_two_symbol);<br/><br/>    let mut game_over = false;<br/><br/>    if player_one_won == true {<br/>        //player one won<br/>        self.turn = self.player_one; //set player to start next round<br/>        self._reward_winner(self.player_one);<br/>        self._clear_board(); //clear game board<br/>        self.last_winner = self.player_one; //set to last winner<br/>        game_over = true; //game is over<br/>    } else if player_two_won == true {<br/>        //player two won<br/>        self.turn = self.player_two; //set player to start next round<br/>        self._reward_winner(self.player_two);<br/>        self._clear_board(); //clear game board<br/>        self.last_winner = self.player_one; //set to last winner<br/>        game_over = true;<br/>    } else {<br/>        if self._is_board_filled() == true {<br/>            //It's a draw<br/>            self.turn = self.player_one;<br/>            self._refund_tokens(); //refund tokens because no one won<br/>            self._clear_board();<br/>            game_over = true;<br/>        }<br/>    }<br/><br/>    if game_over == false {<br/>        if self.turn == self.player_one {<br/>            self.turn = self.player_two;<br/>        } else {<br/>            self.turn = self.player_one;<br/>        }<br/>    }<br/>}</span></pre><p id="7988" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在允许玩家移动之前，我们用这种方法做了很多检查。</p><p id="479d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">首先，我们要确保呼叫者是与游戏相关联的两个玩家中的任何一个，同时确保两个玩家都已经为这一轮下注了他们的代币。</p><p id="4c2a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后，我们确认该轮到给定的玩家了，之后我们会将他们的符号写入棋盘存储数组中适当的键。</p><p id="799b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们检查赢和平的条件(对每一步棋都进行检查)。</p><p id="03ec" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果一个玩家赢了，他们会得到所有的钱，棋盘会被重置，他们会成为下一个玩家(玩下一轮)。</p><p id="c0e4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果游戏以平局结束，棋盘同样被清空，代币被退还给双方，新一轮开始。</p><p id="cca5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们完了！🔥</p><p id="96f5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">说了这么多，我应该喝杯冰镇葡萄酒。我希望你喜欢阅读和/或练习这个指南💚。</p><p id="dd0d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">下面是完整的源代码(我已经格式化了:):</p><pre class="kf kg kh ki fq mp mq mr bn ms mt bi"><span id="e021" class="mu ky ht mq b be mv mw l mx my">#![cfg_attr(not(feature = "std"), no_std)]<br/><br/>#[cfg(not(feature = "ink-as-dependency"))]<br/><br/>#[ink::contract]<br/>pub mod tic_tac_toe {<br/><br/>    use ink::prelude::vec;<br/>    use ink::prelude::vec::Vec;<br/>    <br/>    use openbrush::contracts::traits::psp22::PSP22Ref;<br/><br/>    use ink::env::CallFlags;<br/><br/>    use openbrush::traits::Storage;<br/><br/>    #[ink(storage)]<br/>    #[derive(Default, Storage)]<br/>    pub struct TicTacToe {<br/>        board: Vec&lt;u64&gt;, //0 to 8 cells<br/>        turn: AccountId,<br/>        symbols: ink::storage::Mapping&lt;AccountId, u64&gt;,<br/>        player_one: AccountId,<br/>        player_two: AccountId,<br/>        staking_token: AccountId,<br/>        stake_amount: Balance,<br/>        stakes: ink::storage::Mapping&lt;AccountId, Balance&gt;,<br/>        last_winner: AccountId,<br/>    }<br/><br/>    impl TicTacToe {<br/>        /// Creates a new instance of this contract.<br/>        #[ink(constructor)]<br/>        pub fn new(<br/>            player_one: AccountId,<br/>            player_two: AccountId,<br/>            player_one_symbol: u64,<br/>            player_two_symbol: u64,<br/>            staking_token: AccountId,<br/>            stake_amount: Balance,<br/>        ) -&gt; Self {<br/><br/>            let mut contract = Self::default();<br/><br/>            let board = vec![0; 9]; //empty array<br/><br/>            contract.board = board; //set board to empty state<br/><br/>            contract.staking_token = staking_token; //set staking token<br/><br/>            contract.stake_amount = stake_amount; //set stake amount<br/><br/>            assert!(player_one != player_two); //addresses must not be the same<br/><br/>            assert!(player_one_symbol != player_two_symbol); //symbols must be distinct<br/><br/>            assert!(<br/>                (player_one_symbol == 1 || player_one_symbol == 2)<br/>                    &amp;&amp; (player_two_symbol == 1 || player_two_symbol == 2)<br/>            ); //symbols must be either 1 or 2<br/><br/>            contract.player_one = player_one; //set player one address<br/><br/>            contract.player_two = player_two; //set player two address<br/><br/>            contract.symbols.insert(player_one, &amp;player_one_symbol); //set player one symbol<br/><br/>            contract.symbols.insert(player_two, &amp;player_two_symbol); //set player two symbol<br/><br/>            contract.turn = player_one; //initialize turn to player one<br/><br/>            contract<br/><br/>        }<br/><br/>        #[ink(message)]<br/>        pub fn get_stake_amount(&amp;self) -&gt; Balance {<br/>            self.stake_amount //amount to be staked in game<br/>        }<br/><br/>        #[ink(message)]<br/>        pub fn get_last_winner(&amp;self) -&gt; AccountId {<br/>            self.last_winner //address of most recent winner<br/>        }<br/><br/>        #[ink(message)]<br/>        pub fn get_current_turn(&amp;self) -&gt; AccountId {<br/>            self.turn //who is meant to play?<br/>        }<br/><br/>        #[ink(message)]<br/>        pub fn get_staking_token(&amp;self) -&gt; AccountId {<br/>            self.staking_token //get address of staking token smart contract<br/>        }<br/><br/>        #[ink(message)]<br/>        pub fn get_player_two_stake(&amp;self) -&gt; Balance {<br/>            self.stakes.get(self.player_two).unwrap_or(0) //get total amount of tokens staked by player two<br/>        }<br/><br/>        #[ink(message)]<br/>        pub fn get_player_one_stake(&amp;self) -&gt; Balance {<br/>            self.stakes.get(self.player_one).unwrap_or(0) //get total amount of tokens staked by player one<br/>        }<br/><br/>        #[ink(message)]<br/>        pub fn get_player_one(&amp;self) -&gt; AccountId {<br/>            self.player_one //get player one address<br/>        }<br/><br/>        #[ink(message)]<br/>        pub fn get_player_two(&amp;self) -&gt; AccountId {<br/>            self.player_two //get player two address<br/>        }<br/><br/>        #[ink(message)]<br/>        pub fn get_player_two_symbol(&amp;self) -&gt; u64 {<br/>            self.symbols.get(self.player_two).unwrap_or(0) //get player two symbol<br/>        }<br/><br/>        #[ink(message)]<br/>        pub fn get_player_one_symbol(&amp;self) -&gt; u64 {<br/>            self.symbols.get(self.player_one).unwrap_or(0) //get player one symbol<br/>        }<br/><br/>        #[ink(message)]<br/>        pub fn get_board(&amp;self) -&gt; Vec&lt;u64&gt; {<br/>            //read and return board as array<br/>            let board = &amp;self.board;<br/>            board.to_vec()<br/>        }<br/><br/>        #[ink(message)]<br/>        pub fn stake_tokens(&amp;mut self) {<br/>            let player = self.env().caller(); //get caller address<br/>            let stakes = self.stakes.get(player).unwrap_or(0); //get stake if existent<br/><br/>            assert!(player == self.player_one || player == self.player_two); //Caller must be player one or two<br/><br/>            if stakes &gt; 0 {<br/>                panic!("Already staked for this round")<br/>            } //Make sure player hasn't already staked<br/><br/>            let balance = PSP22Ref::balance_of(&amp;self.staking_token, player); //get user balance of token<br/><br/>            let allowance =<br/>                PSP22Ref::allowance(&amp;self.staking_token, player, Self::env().account_id()); //get spending allowance contract has to player<br/><br/>            assert!(balance &gt; self.stake_amount); //balance must be greater than stake amount<br/><br/>            assert!(allowance &gt; self.stake_amount); //allowance must be greater than stake amount<br/><br/>            //Transfer stake amount from caller (player) to contract<br/>            PSP22Ref::transfer_from_builder(<br/>                &amp;self.staking_token,<br/>                self.env().caller(),<br/>                Self::env().account_id(),<br/>                self.stake_amount,<br/>                ink::prelude::vec![],<br/>            )<br/>            .call_flags(CallFlags::default().set_allow_reentry(true))<br/>            .fire()<br/>            .expect("Transfer failed")<br/>            .expect("Transfer failed");<br/><br/>            self.stakes.insert(player, &amp;self.stake_amount); //Add stake amount to user stake<br/>        }<br/><br/>        #[inline]<br/>        pub fn _has_won(&amp;self, symbol: u64) -&gt; bool {<br/>            let vertical = [[0, 3, 6], [1, 4, 7], [2, 5, 8]];<br/>            let horizontal = [[0, 1, 2], [3, 4, 5], [6, 7, 8]];<br/>            let diagonal = [[0, 4, 8], [2, 4, 6]];<br/><br/>            //check vertical<br/>            let mut v_win = false;<br/>            for i in 0..=2 {<br/>                let mut count = 0;<br/>                for j in 0..=2 {<br/>                    if self.board[vertical[i][j]] == symbol {<br/>                        count += 1;<br/>                    }<br/>                }<br/>                if count == 3 {<br/>                    v_win = true;<br/>                    break;<br/>                }<br/>            }<br/><br/>            //check horizontal<br/>            let mut h_win = false;<br/>            for i in 0..=2 {<br/>                let mut count = 0;<br/>                for j in 0..=2 {<br/>                    if self.board[horizontal[i][j]] == symbol {<br/>                        count += 1;<br/>                    }<br/>                }<br/>                if count == 3 {<br/>                    h_win = true;<br/>                    break;<br/>                }<br/>            }<br/><br/>            //check diagonal<br/>            let mut d_win = false;<br/>            for i in 0..=1 {<br/>                let mut count = 0;<br/>                for j in 0..=2 {<br/>                    if self.board[diagonal[i][j]] == symbol {<br/>                        count += 1;<br/>                    }<br/>                }<br/>                if count == 3 {<br/>                    d_win = true;<br/>                    break;<br/>                }<br/>            }<br/><br/>            if v_win == true || h_win == true || d_win == true {<br/>                true<br/>            } else {<br/>                false<br/>            }<br/>        }<br/><br/>        #[inline]<br/>        pub fn _clear_board(&amp;mut self) {<br/>            let board = vec![0; 9];<br/>            self.board = board;<br/>        }<br/><br/>        #[inline]<br/>        pub fn _is_cell_empty(&amp;self, cell: u64) -&gt; bool {<br/>            if self.board[usize::try_from(cell).unwrap()] == 0 {<br/>                true<br/>            } else {<br/>                false<br/>            }<br/>        }<br/><br/>        #[inline]<br/>        pub fn _is_board_filled(&amp;self) -&gt; bool {<br/>            let mut filled_cells = 0;<br/>            let board = &amp;self.board;<br/>            for cell in 0..=8 {<br/>                if board[usize::try_from(cell).unwrap()] != 0 {<br/>                    filled_cells += 1;<br/>                }<br/>            }<br/>            if filled_cells == 9 {<br/>                true<br/>            } else {<br/>                false<br/>            }<br/>        }<br/><br/>        #[inline]<br/>        pub fn _reward_winner(&amp;mut self, account: AccountId) {<br/>            let total_stakes = PSP22Ref::balance_of(&amp;self.staking_token, Self::env().account_id()); //get total stakes<br/><br/>            PSP22Ref::transfer(<br/>                &amp;self.staking_token,<br/>                account,<br/>                total_stakes,<br/>                ink::prelude::vec![],<br/>            ); //transfer everything to the winner<br/><br/>            self.stakes.insert(self.player_one, &amp;0);<br/>            <br/>            self.stakes.insert(self.player_two, &amp;0);<br/>        }<br/><br/>        #[inline]<br/>        pub fn _refund_tokens(&amp;mut self) {<br/>            let total_stakes = PSP22Ref::balance_of(&amp;self.staking_token, Self::env().account_id()); //get total stakes<br/>            let per_player = total_stakes / 2;<br/><br/>            PSP22Ref::transfer(<br/>                &amp;self.staking_token,<br/>                self.player_one,<br/>                per_player,<br/>                ink::prelude::vec![],<br/>            ); //transfer half to player one<br/>            PSP22Ref::transfer(<br/>                &amp;self.staking_token,<br/>                self.player_two,<br/>                per_player,<br/>                ink::prelude::vec![],<br/>            ); //transfer half to player two<br/><br/>            self.stakes.insert(self.player_one, &amp;0);<br/><br/>            self.stakes.insert(self.player_two, &amp;0);<br/><br/>        }<br/><br/>        #[ink(message)]<br/>        pub fn play(&amp;mut self, cell: u64) {<br/>            assert!(cell &lt;= 8);<br/><br/>            let player = self.env().caller(); //get caller address<br/><br/>            assert!(player == self.player_one || player == self.player_two); //caller must be player one or two<br/><br/>            assert!(self.get_player_one_stake() &gt; 0 &amp;&amp; self.get_player_two_stake() &gt; 0); //both players must have staked<br/><br/>            let is_empty = self._is_cell_empty(cell); //check if cell is empty<br/><br/>            assert!(is_empty == true); //cell must be empty<br/><br/>            assert!(self.turn == player); //must be player's turn<br/><br/>            let mut board = self.get_board();<br/><br/>            let player_one_symbol = self.get_player_one_symbol();<br/>            let player_two_symbol = self.get_player_two_symbol();<br/><br/>            let cell_index = usize::try_from(cell).unwrap(); //convert index to usize<br/><br/>            board[cell_index] = self.symbols.get(player).unwrap_or(0);<br/><br/>            self.board = board;<br/><br/>            let player_one_won = self._has_won(player_one_symbol);<br/><br/>            let player_two_won = self._has_won(player_two_symbol);<br/><br/>            let mut game_over = false;<br/><br/>            if player_one_won == true {<br/>                //player one won<br/>                self.turn = self.player_one; //set player to start next round<br/>                self._reward_winner(self.player_one);<br/>                self._clear_board(); //clear game board<br/>                self.last_winner = self.player_one; //set to last winner<br/>                game_over = true; //game is over<br/>            } else if player_two_won == true {<br/>                //player two won<br/>                self.turn = self.player_two; //set player to start next round<br/>                self._reward_winner(self.player_two);<br/>                self._clear_board(); //clear game board<br/>                self.last_winner = self.player_one; //set to last winner<br/>                game_over = true;<br/>            } else {<br/>                if self._is_board_filled() == true {<br/>                    //It's a draw<br/>                    self.turn = self.player_one;<br/>                    self._refund_tokens(); //refund tokens because no one won<br/>                    self._clear_board();<br/>                    game_over = true;<br/>                }<br/>            }<br/><br/>            if game_over == false {<br/>                if self.turn == self.player_one {<br/>                    self.turn = self.player_two;<br/>                } else {<br/>                    self.turn = self.player_one;<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</span></pre><h1 id="41c4" class="kx ky ht bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">脚注</h1><p id="e121" class="pw-post-body-paragraph iq ir ht is b it lv iv iw ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn hm dt translated">如果你喜欢这篇文章和/或觉得它有帮助，请在Twitter上关注我，关注我的动向😎。要获得GitHub上的完整源代码，请访问<a class="ae jx" href="https://github.com/EdinyangaOttoho/ink-tic-tac-toe" rel="noopener ugc nofollow" target="_blank">此链接</a>。值得称赞。</p><p id="d815" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">你可以随时叉库，并给我发一份公关你喜欢的任何时候。</p><p id="7ef8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了在Aleph Zero Testnet上部署您的智能合约，使其具有有趣且流畅的用户界面，您可以点击<a class="ae jx" href="https://test.azero.dev/#/" rel="noopener ugc nofollow" target="_blank">此链接</a>。</p><p id="1c12" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果您已经阅读了本文，那么您应该得到一些$AZERO代币:)</p><p id="eb04" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我很高兴有你一直在这里。</p><blockquote class="nn"><p id="12f2" class="no np ht bd nq nr ns nt nu nv nw jn ek translated">交易新手？试试<a class="ae jx" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或者<a class="ae jx" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>