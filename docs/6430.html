<html>
<head>
<title>Creating a P2P tic-tac-toe gambling smart contract on Aleph Zero using Rust ink!; understanding the psp22 standard</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ä½¿ç”¨Rust inkåœ¨Aleph Zeroä¸Šåˆ›å»ºP2Päº•å­—æ¸¸æˆæ™ºèƒ½åˆçº¦ï¼ï¼›äº†è§£psp22æ ‡å‡†</h1>
<blockquote>åŸæ–‡ï¼š<a href="https://medium.com/coinmonks/creating-a-p2p-tic-tac-toe-gambling-smart-contract-on-aleph-zero-using-ink-9702f7714f55?source=collection_archive---------3-----------------------#2022-11-17">https://medium.com/coinmonks/creating-a-p2p-tic-tac-toe-gambling-smart-contract-on-aleph-zero-using-ink-9702f7714f55?source=collection_archive---------3-----------------------#2022-11-17</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="18ec" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt jo translated">è¿™æ˜¯æ–°çš„ä¸€å¤©ï¼Œä¹Ÿæ˜¯å­¦ä¹ æ–°äº‹ç‰©çš„å¥½æ—¶æœºï¼›æˆ‘æ¥å¸®åŠ©æ‚¨å®ç°è¿™ä¸€ç›®æ ‡:)ã€‚æœ¬æ–‡æ—¨åœ¨æŒ‡å¯¼æ‚¨ä½¿ç”¨Rust(å¸¦å¢¨æ°´)åˆ›å»ºä¸€ä¸ªäº•å­—æ¸¸æˆP2Pæ¸¸æˆ(å¸¦æœ‰èµŒåšåŠŸèƒ½ï¼).</p><p id="d0f2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">åœ¨ç»å†äº†è¿™ä¹ˆé•¿æ—¶é—´çš„é˜…è¯»å(ä¹Ÿæ˜¯å®è·µæ€§çš„)ï¼Œä½ åº”è¯¥èƒ½å¤Ÿä¸åƒAleph Zeroè¿™æ ·çš„è¡¬åº•é“¾ä¸Šçš„<a class="ae jx" rel="noopener" href="/supercolony/psp22-the-first-smart-contract-standard-on-the-polkadot-ecosystem-fef3f6c27d88"> PSP22æ ‡å‡†ä»¤ç‰Œ</a>è¿›è¡Œäº¤äº’(è¿™æ˜¯æˆ‘ä»¬çš„ä¸»è¦å…³æ³¨ç‚¹)ã€‚</p><p id="dcec" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">æˆ‘å°†åœ¨æœ¬æ–‡ä¸­ä¸€ç›´æ¼”ç¤º<strong class="is hu"><em class="jy">PSP 22::balance of()</em></strong>ï¼Œ<strong class="is hu"><em class="jy">PSP 22::allow ance()</em></strong>ï¼Œ<strong class="is hu"><em class="jy">PSP 22::transfer()</em></strong>å’Œ<strong class="is hu"><em class="jy">PSP 22::transfer from()</em></strong>PSP 22æ–¹æ³•ã€‚</p><blockquote class="jz ka kb"><p id="d576" class="iq ir jy is b it iu iv iw ix iy iz ja kc jc jd je kd jg jh ji ke jk jl jm jn hm dt translated">æœ‰è¶£çš„äº‹å®:æˆ‘æŠŠåšç¡¬å˜æˆäº†ç”Ÿé”ˆçš„å¢¨æ°´ï¼åä¹‹äº¦ç„¶ï¼ŒJSYKğŸ˜</p></blockquote><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div class="ab fr cl kk"><img src="../Images/80360265f13993ddb768ba399a5ad5b3.png" data-original-src="https://miro.medium.com/v2/0*wQKxAZc8-GZ6mT5i"/></div><figcaption class="kn ko fg fe ff kp kq bd b be z ek">Image credits: <a class="ae jx" href="https://www.google.com/url?sa=i&amp;url=https%3A%2F%2Fwww.istockphoto.com%2Fillustrations%2Ftic-tac-toe&amp;psig=AOvVaw17JY8cHT26Zy_RLBTxFugD&amp;ust=1668722492879000&amp;source=images&amp;cd=vfe&amp;ved=0CBEQjhxqFwoTCKig1Kfbs_sCFQAAAAAdAAAAABAD" rel="noopener ugc nofollow" target="_blank">https://istockphoto.com</a></figcaption></figure><p id="a1e4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">æ˜¾ç„¶ï¼Œäº”åˆ†ä¹‹äºŒçš„äººçŸ¥é“â€œäº•å­—æ¸¸æˆâ€ï¼Œå°½ç®¡æ ¹æ®äººä»¬çš„åˆ¤æ–­åŠ›ã€å–å‘ã€åœ°ç‚¹æˆ–é€‰æ‹©ï¼Œå®ƒå¯èƒ½æœ‰ä¸åŒçš„åç§°ã€‚</p><blockquote class="jz ka kb"><p id="96c7" class="iq ir jy is b it iu iv iw ix iy iz ja kc jc jd je kd jg jh ji ke jk jl jm jn hm dt translated"><strong class="is hu">è¯·æ³¨æ„ï¼Œæœ¬æ–‡ä¸­çš„æºä»£ç æ²¡æœ‰ç»è¿‡ä»»ä½•å®¡æ ¸ï¼Œå®¹æ˜“å—åˆ°æ¼æ´çš„å½±å“ï¼›è¿™å®Œå…¨æ˜¯ä¸ºäº†æ•™è‚²ç›®çš„ï¼Œæ²¡æœ‰åˆ«çš„ã€‚</strong></p></blockquote><p id="9a5e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">å¦‚æœä½ ä»æ¥æ²¡æœ‰å¬è¯´è¿‡äº•å­—æ¸¸æˆï¼Œè¿™æ˜¯ä¸€ç§æ£‹ç›˜æ¸¸æˆï¼Œæœ‰ä¸€ä¸ª3Ã—3å•å…ƒçš„æ­£æ–¹å½¢ç½‘æ ¼(æ ¹æ®ç©å®¶çš„å–œå¥½å¯èƒ½ä¼šæœ‰æ›´å¤§çš„æ•°é‡ï¼Œä¾‹å¦‚ï¼Œ5Ã—5ï¼Œ9Ã—9ç­‰ï¼›é€šå¸¸åœ¨ç”±å¥‡æ•°ä¹˜å¥‡æ•°ç»„æˆçš„æ ¼å­ä¸­)ï¼Œæ¯ä¸ªç©å®¶ä½¿ç”¨ä¸¤ä¸ªå­—ç¬¦ï¼Œé€šå¸¸æ˜¯â€œXâ€å’Œâ€œOâ€ã€‚</p><p id="a470" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">æ¯ä¸ªç©å®¶é€šè¿‡å°†ä»–ä»¬ç›¸å…³çš„è§’è‰²æ’å…¥(ç”»)åˆ°ä¸€ä¸ªç©ºçš„æ ¼å­ä¸­æ¥ç§»åŠ¨ï¼Œç›®çš„æ˜¯åˆ›å»ºä¸€ä¸ªæ°´å¹³ã€å¯¹è§’æˆ–å‚ç›´çš„å›¾æ¡ˆï¼ŒåŒæ—¶é˜²æ­¢ä»–ä»¬çš„å¯¹æ‰‹åšåŒæ ·çš„äº‹æƒ…ï¼Œä»¥åŠæ™ºèƒœä»–ä»¬ï¼Œä»¥ä¾¿æ— éšœç¢åœ°å®ç°ä»–ä»¬çš„å®Œæ•´çº¿ã€‚å¯¹äºæ¯ä¸€è½®ï¼Œå¦‚æœæ²¡æœ‰èµ¢å®¶(å³æ‰€æœ‰çš„ä½ç½®éƒ½è¢«å¡«æ»¡ï¼Œæ²¡æœ‰ä»»ä½•ç©å®¶åˆ¶ä½œæœ‰æ•ˆçš„å›¾æ¡ˆ)ï¼Œæ¸¸æˆè¢«æ ‡è®°ä¸ºå¹³å±€ï¼Œæ–°ä¸€è½®å¼€å§‹ã€‚</p><p id="39b7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">ä»ä¸‹å›¾å¯ä»¥çœ‹å‡ºï¼Œè¢«åˆ†é…äº†â€œXâ€ç¬¦å·çš„ç©å®¶åœ¨æ‰€æœ‰ä¸‰è½®ä¸­éƒ½æ˜¯èµ¢å®¶(å¿½ç•¥â€œOâ€æ²¡æœ‰è¢«æ‰“æ»¡æ‰€æœ‰å›åˆçš„äº‹å®ï¼›äºŒå·ç©å®¶æ˜¯ä¸ªå‘†å­)ã€‚</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="fe ff kr"><img src="../Images/59527fc8b6765d05bd36c7000f48659c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Yzhhcly76tRL6Jn8wWgwHg.png"/></div></div><figcaption class="kn ko fg fe ff kp kq bd b be z ek">Image credits: <a class="ae jx" href="https://en.wikipedia.org" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org</a></figcaption></figure><p id="171b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œä¸¤ä¸ªç©å®¶éƒ½å°†ä¸‹æ³¨ä¸€å®šæ•°é‡æ¥ç©æ¸¸æˆã€‚èƒœè€…æ‹¿èµ°æ‰€æœ‰ä»£å¸ï¼Œæ¸¸æˆç»“æŸï¼Œä½†å¦‚æœæ˜¯å¹³å±€ï¼Œä»£å¸é€€è¿˜ç»™åŒæ–¹ï¼Œæ¸¸æˆç»“æŸã€‚æ¯è½®æ¸¸æˆç»“æŸåï¼Œæ£‹ç›˜ä¹Ÿä¼šé‡ç½®ã€‚</p><p id="dd35" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">æ—¢ç„¶æ‚¨å·²ç»çŸ¥é“äº†è¿™ä¸ªæ¸¸æˆæ˜¯å¦‚ä½•ç©çš„ï¼Œé‚£ä¹ˆè®©æˆ‘ä»¬æ·±å…¥åˆ°Rustçš„å®é™…å®ç°ä¸­ğŸ˜ã€‚å¾ˆé…·å§: )</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="fe ff kw"><img src="../Images/c1be77ede2016350bb005f9b3f24fbc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*IiAe56b5TvFIcDC3.gif"/></div></div><figcaption class="kn ko fg fe ff kp kq bd b be z ek">Image credits: <a class="ae jx" href="https://tenor.com" rel="noopener ugc nofollow" target="_blank">https://tenor.com</a></figcaption></figure><p id="8cbf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">è¯·ç‚¹å‡»<a class="ae jx" href="https://github.com/paritytech/cargo-contract" rel="noopener ugc nofollow" target="_blank">æ­¤é“¾æ¥</a>å¼€å§‹å®‰è£…Rustæ™ºèƒ½åˆåŒå¼€å‘çš„â€œè´§ç‰©åˆåŒâ€ã€‚</p><h1 id="e98b" class="kx ky ht bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">é¡¹ç›®è®¾ç½®</h1><p id="0d2d" class="pw-post-body-paragraph iq ir ht is b it lv iv iw ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn hm dt translated">åœ¨æˆ‘ä»¬å¼€å§‹ä¹‹å‰ï¼Œé¡¹ç›®æ–‡ä»¶å¤¹å¿…é¡»æœ‰ä¸€ä¸ªå·²å®šä¹‰çš„ç»“æ„ï¼Œæˆ‘ä»¬å°†åˆ›å»ºä¸¤ä¸ªç”¨äºæ„å»ºå¥‘çº¦çš„æ–‡ä»¶ã€‚</p><ul class=""><li id="db23" class="ma mb ht is b it iu ix iy jb mc jf md jj me jn mf mg mh mi dt translated">cargo.toml</li><li id="76c5" class="ma mb ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi dt translated">å›¾ä¹¦é¦†</li></ul><p id="5dfa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">â€œcargo.tomlâ€æ›´åƒæ˜¯NPMè‘—åçš„â€œpackage . JSON â€( node . js ),å®ƒå¸®åŠ©æˆ‘ä»¬å®šä¹‰ä¸é¡¹ç›®ç›¸å…³çš„å±æ€§ã€ä¾èµ–å…³ç³»å’Œä¿¡æ¯ï¼Œè€Œæˆ‘ä»¬å°†ä½¿ç”¨â€œlib.rsâ€ä½œä¸ºæˆ‘ä»¬çš„å…¥å£æ–‡ä»¶(æ‰€æœ‰çš„é‡è¦å·¥ä½œéƒ½å°†åœ¨è¿™é‡Œå®Œæˆ)ã€‚</p><p id="e496" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">è¿™æ˜¯å°†åœ¨è¿™ä¸ªé¡¹ç›®ä¸­ä½¿ç”¨çš„ä¸¤ä¸ªæ–‡ä»¶ã€‚</p><p id="8a61" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">ä½¿ç”¨<a class="ae jx" href="https://github.com/EdinyangaOttoho/ink-tic-tac-toe/blob/master/Cargo.toml" rel="noopener ugc nofollow" target="_blank">è¿™ä¸ªæ–‡ä»¶</a>çš„å†…å®¹ç»„æˆä½ çš„â€œcargo.tomlâ€æ–‡ä»¶ã€‚</p><p id="c7cb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">ä½ åŸºæœ¬ä¸Šéœ€è¦åœ¨æ–‡ä»¶<strong class="is hu">çš„ç¬¬4è¡Œ</strong>çš„â€œä½œè€…â€é”®ä¸­ä¿®æ”¹åå­—å’Œç”µå­é‚®ä»¶ï¼Œä»¥åŒ¹é…ä½ çš„åå­—ã€‚</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="ks kt di ku bf kv"><div class="fe ff mo"><img src="../Images/8b89a068d5204fef1c70d325970ad7e2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b1nBCaAEQYwNFPZE4lqQwA.png"/></div></div><figcaption class="kn ko fg fe ff kp kq bd b be z ek">Update the authorsâ€™ array to contain your name and email.</figcaption></figure><p id="8fe8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">è¯¥æ–‡ä»¶å°†å¦‚ä¸‹æ‰€ç¤º:</p><pre class="kf kg kh ki fq mp mq mr bn ms mt bi"><span id="38c6" class="mu ky ht mq b be mv mw l mx my">[package]<br/>name = "tic_tac_toe"<br/>version = "0.9.6"<br/>authors = ["Edinyanga Ottoho &lt;elzucky@gmail.com&gt;"]<br/>edition = "2021"<br/>overflow-checks = false<br/><br/>[dependencies]<br/><br/>ink = { git = "https://github.com/paritytech/ink", rev = "4655a8b4413cb50cbc38d1b7c173ad426ab06cde", default-features = false}<br/>scale = { package = "parity-scale-codec", version = "3", default-features = false, features = ["derive"] }<br/>scale-info = { version = "2", default-features = false, features = ["derive"], optional = true }<br/><br/>openbrush = { git = "https://github.com/727-Ventures/openbrush-contracts", branch="main", default-features = false, features = ["psp22"] }<br/><br/>[lib]<br/>overflow-checks = false<br/>name = "tic_tac_toe"<br/>path = "lib.rs"<br/>crate-type = [<br/>    # Used for normal contract Wasm blobs.<br/>    "cdylib"<br/>]<br/>[profile.release]<br/>overflow-checks = false<br/><br/>[features]<br/>default = ["std"]<br/>std = [<br/>    "ink/std",<br/>    "scale/std",<br/>    "scale-info/std",<br/>    "openbrush/std"<br/>]<br/>psp22 = ["openbrush/psp22"]<br/>ink-as-dependency = []</span></pre><h1 id="6385" class="kx ky ht bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">å®šä¹‰å¯¼å…¥å’Œå­˜å‚¨ç»“æ„</h1><p id="ebfc" class="pw-post-body-paragraph iq ir ht is b it lv iv iw ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn hm dt translated">é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦åˆ›å»ºæ¨¡å—å¹¶å¯¼å…¥æ‰€æœ‰å¿…è¦çš„ä¾èµ–é¡¹ï¼Œä»¥é€‚åº”æ™ºèƒ½åˆçº¦çš„åŠŸèƒ½ï¼Œä»¥åŠæ„é€ å‡½æ•°åˆå§‹åŒ–ä»£ç å’Œå°†åœ¨æ•´ä¸ªæºä»£ç ä¸­ä½¿ç”¨çš„å­˜å‚¨é”®çš„ç»“æ„ã€‚</p><pre class="kf kg kh ki fq mp mq mr bn ms mt bi"><span id="1300" class="mu ky ht mq b be mv mw l mx my">#![cfg_attr(not(feature = "std"), no_std)]<br/><br/>#[cfg(not(feature = "ink-as-dependency"))]<br/><br/>#[ink::contract]<br/>pub mod tic_tac_toe {<br/><br/>    use ink::prelude::vec;<br/>    use ink::prelude::vec::Vec;<br/>    <br/>    use openbrush::contracts::traits::psp22::PSP22Ref;<br/><br/>    use ink::env::CallFlags;<br/><br/>    use openbrush::traits::Storage;<br/><br/>    #[ink(storage)]<br/>    #[derive(Default, Storage)]<br/><br/>    pub struct TicTacToe {<br/>        board: Vec&lt;u64&gt;, //0 to 8 cells<br/>        turn: AccountId,<br/>        symbols: ink::storage::Mapping&lt;AccountId, u64&gt;,<br/>        player_one: AccountId,<br/>        player_two: AccountId,<br/>        staking_token: AccountId,<br/>        stake_amount: Balance,<br/>        stakes: ink::storage::Mapping&lt;AccountId, Balance&gt;,<br/>        last_winner: AccountId,<br/>    }<br/>}</span></pre><p id="1370" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">å­˜å‚¨ç»“æ„â€œTicTacToeâ€ä¸­å®šä¹‰çš„é”®å°†åœ¨æœ¬æ–‡ä¸­ç»§ç»­è®¨è®ºï¼›ä¸è¦æ…Œ:)ã€‚</p><h1 id="ebee" class="kx ky ht bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">æ„é€ å‡½æ•°</h1><p id="6158" class="pw-post-body-paragraph iq ir ht is b it lv iv iw ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn hm dt translated">æˆ‘ä»¬è¦åšçš„ä¸‹ä¸€ä»¶äº‹æ˜¯åœ¨â€œtic_tac_toeâ€æ¨¡å—çš„å®ç°ä¸­å®šä¹‰æ„é€ å‡½æ•°ï¼Œç´§æ¥åœ¨â€œTicTacToeâ€ç»“æ„ä¹‹åï¼Œè¯¥ç»“æ„å°†åœ¨éƒ¨ç½²æˆ‘ä»¬çš„æ™ºèƒ½åˆçº¦æ—¶è¢«è°ƒç”¨ï¼Œä»¥ä¾¿åˆå§‹åŒ–ä¸€äº›æˆ‘ä»¬å¸Œæœ›é»˜è®¤æ³¨å†Œåˆ°å…¶ä¸­çš„å€¼ã€‚</p><p id="dac4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">æˆ‘ä»¬æƒ³è¦å®šä¹‰ç©å®¶çš„åœ°å€ã€æ¸¸æˆä¸­ä½¿ç”¨çš„PSP22ä»¤ç‰Œã€ä»–ä»¬çš„ç¬¦å·ä»¥åŠç»™å®šæ¸¸æˆçš„èµŒæ³¨é‡‘é¢ã€‚</p><p id="22bf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">è¿™äº›å¯ä»¥ä½œä¸ºå‚æ•°æä¾›ç»™æ„é€ å‡½æ•°ï¼Œå› æ­¤:</p><pre class="kf kg kh ki fq mp mq mr bn ms mt bi"><span id="a99d" class="mu ky ht mq b be mv mw l mx my">impl TicTacToe {<br/>    /// Creates a new instance of this contract.<br/>    #[ink(constructor)]<br/>    pub fn new(player_one:AccountId, player_two:AccountId, player_one_symbol:u64, player_two_symbol:u64, staking_token: AccountId, stake_amount: Balance) -&gt; Self {<br/>        //Do something here...<br/>    }<br/>}</span></pre><p id="0aba" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">åœ¨â€œnew()â€æ–¹æ³•ä¸­ï¼Œæˆ‘ä»¬å¿…é¡»å­˜å‚¨è¿™äº›å€¼å¹¶è¿›è¡Œä¸€äº›ä¾‹è¡Œæ£€æŸ¥ï¼Œè¿™æ ·åœ¨æ¸¸æˆè¿‡ç¨‹ä¸­å°±ä¸ä¼šå‡ºç°å¼‚å¸¸çš„å¥‘çº¦è¡Œä¸ºã€‚</p><pre class="kf kg kh ki fq mp mq mr bn ms mt bi"><span id="b164" class="mu ky ht mq b be mv mw l mx my">let mut contract = Self::default();<br/><br/>let board = vec![0; 9]; //empty array<br/><br/>contract.board = board; //set board to empty state<br/><br/>contract.staking_token = staking_token; //set staking token<br/><br/>contract.stake_amount = stake_amount; //set stake amount<br/><br/>assert!(player_one != player_two); //addresses must not be the same<br/><br/>assert!(player_one_symbol != player_two_symbol); //symbols must be distinct<br/><br/>assert!(<br/>    (player_one_symbol == 1 || player_one_symbol == 2)<br/>        &amp;&amp; (player_two_symbol == 1 || player_two_symbol == 2)<br/>); //symbols must be either 1 or 2<br/><br/>contract.player_one = player_one; //set player one address<br/><br/>contract.player_two = player_two; //set player two address<br/><br/>contract.symbols.insert(player_one, &amp;player_one_symbol); //set player one symbol<br/><br/>contract.symbols.insert(player_two, &amp;player_two_symbol); //set player two symbol<br/><br/>contract.turn = player_one; //initialize turn to player one<br/><br/>contract</span></pre><p id="e8ba" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">åœ¨æœ¬ä¾‹ä¸­ï¼Œæˆ‘ä»¬å°†0ä½œä¸ºç©ºå•å…ƒæ ¼ï¼Œ1ä½œä¸ºXï¼Œ2ä½œä¸ºOã€‚æˆ‘ä»¬è¿˜å°†ä½¿ç”¨0åˆ°8æ¥è¡¨ç¤ºæ£‹ç›˜çš„å•å…ƒæ ¼ï¼Œä»å·¦ä¸Šåˆ°å³ä¸‹ä¾æ¬¡æ’åˆ—ï¼Œè¿™æ„å‘³ç€å·¦ä¸Šçš„å•å…ƒæ ¼æ˜¯0ï¼Œå³ä¸‹çš„å•å…ƒæ ¼æ˜¯8ï¼Œä¸­é—´çš„å•å…ƒæ ¼æ˜¯5ã€‚</p><p id="da1d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">ä»ä¸Šåˆ°ä¸‹åˆ†æä¸Šé¢çš„ä»£ç ï¼Œæˆ‘ä»¬çœ‹åˆ°åˆ›å»ºäº†ä¸€ä¸ªç©ºæ•°ç»„ï¼Œæˆ‘ä»¬å¾ªç¯éå†å®ƒï¼Œå°†0æ’å…¥åˆ°ä»0åˆ°8çš„æ¯ä¸ªç´¢å¼•ä¸­ï¼Œè¿™æ„å‘³ç€å¼€å§‹æ˜¯ä¸€ä¸ªç©ºçš„æ£‹ç›˜ã€‚</p><p id="330b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">æˆ‘ä»¬è¿˜ä»å…¶å‚æ•°ä¸­è®¾ç½®äº†èµŒæ³¨æ ‡è®°ä»¥åŠèµŒæ³¨é‡‘é¢ã€‚</p><p id="2f6a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">æˆ‘ä»¬è¦ç¡®ä¿ä¸€å·ç©å®¶æ²¡æœ‰ä½¿ç”¨å’ŒäºŒå·ç©å®¶ç›¸åŒçš„åœ°å€ï¼Œä¹Ÿæ²¡æœ‰ç»™ä»–ä»¬åˆ†é…ç›¸åŒçš„ç¬¦å·(ä»…é™äº1å’Œ2)ã€‚æˆ‘ä»¬ç”¨æä¾›çš„å‚æ•°è®¾ç½®äº†ä¸€å·ç©å®¶å’ŒäºŒå·ç©å®¶çš„åœ°å€ã€‚</p><p id="e95e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">ç„¶åï¼Œæˆ‘ä»¬è¿˜å°†ä¸¤ä¸ªç©å®¶é€‰æ‹©çš„ç¬¦å·æ’å…¥åˆ°ä¸€ä¸ªæ˜ å°„ä¸­ï¼Œå°†å®ƒä»¬çš„åœ°å€ä½œä¸ºå…³é”®å­—ï¼Œå°†é€‰æ‹©çš„ç¬¦å·ä½œä¸º<strong class="is hu"> u64 </strong> typeä¸­çš„å€¼ã€‚</p><p id="be4f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">ç„¶åæˆ‘ä»¬æœ€ç»ˆæŠŠä¸€å·ç©å®¶è®¾ä¸ºç¬¬ä¸€ä¸ªå›åˆã€‚</p><p id="797f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">ä¸‡å²ï¼æˆ‘ä»¬å®Œæˆäº†æˆ‘ä»¬çš„æ„é€ å‡½æ•°ï¼</p><h1 id="ca75" class="kx ky ht bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">è¾“å‡ºæ–¹æ³•</h1><p id="aa76" class="pw-post-body-paragraph iq ir ht is b it lv iv iw ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn hm dt translated">è™½ç„¶æˆ‘ä»¬å¾ˆæƒ³åˆ¶ä½œä¸€ä¸ªæœ‰è¶£çš„æ¸¸æˆï¼Œä½†æˆ‘ä»¬æƒ³çŸ¥é“åœ¨æ™ºèƒ½åˆçº¦ä¸­å­˜å‚¨å’ŒåŠ¨æ€æ–¹é¢å‘ç”Ÿäº†ä»€ä¹ˆï¼Œå› æ­¤æˆ‘ä»¬å°†åˆ›å»ºä¸€äº›æ–¹æ³•æ¥éšæ„ä¸ºæˆ‘ä»¬æä¾›å­˜å‚¨å€¼ã€‚</p><pre class="kf kg kh ki fq mp mq mr bn ms mt bi"><span id="2148" class="mu ky ht mq b be mv mw l mx my">#[ink(message)]<br/>pub fn get_stake_amount(&amp;self) -&gt; Balance {<br/>    self.stake_amount //amount to be staked in game<br/>}<br/><br/>#[ink(message)]<br/>pub fn get_last_winner(&amp;self) -&gt; AccountId {<br/>    self.last_winner //address of most recent winner<br/>}<br/><br/>#[ink(message)]<br/>pub fn get_current_turn(&amp;self) -&gt; AccountId {<br/>    self.turn //who is meant to play?<br/>}<br/><br/>#[ink(message)]<br/>pub fn get_staking_token(&amp;self) -&gt; AccountId {<br/>    self.staking_token //get address of staking token smart contract<br/>}<br/><br/>#[ink(message)]<br/>pub fn get_player_two_stake(&amp;self) -&gt; Balance {<br/>    self.stakes.get(self.player_two).unwrap_or(0) //get total amount of tokens staked by player two<br/>}<br/><br/>#[ink(message)]<br/>pub fn get_player_one_stake(&amp;self) -&gt; Balance {<br/>    self.stakes.get(self.player_one).unwrap_or(0) //get total amount of tokens staked by player one<br/>}<br/><br/>#[ink(message)]<br/>pub fn get_player_two_symbol(&amp;self) -&gt; u64 {<br/>    self.symbols.get(self.player_two).unwrap_or(0) //get player two symbol<br/>}<br/><br/>#[ink(message)]<br/>pub fn get_player_one(&amp;self) -&gt; AccountId {<br/>    self.player_one //get player one address<br/>}<br/><br/>#[ink(message)]<br/>pub fn get_player_two(&amp;self) -&gt; AccountId {<br/>    self.player_two //get player two address<br/>}<br/><br/>#[ink(message)]<br/>pub fn get_player_one_symbol(&amp;self) -&gt; u64 {<br/>    self.symbols.get(self.player_one).unwrap_or(0) //get player one symbol<br/>}<br/><br/>#[ink(message)]<br/>pub fn get_board(&amp;self) -&gt; Vec&lt;u64&gt; {<br/>    //read and return board as array<br/>    let board = &amp;self.board;<br/>    board.to_vec()<br/>}</span></pre><p id="4f84" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">ä¸Šé¢å®šä¹‰çš„å¤§å¤šæ•°æ–¹æ³•éƒ½æ˜¯ä¸è¨€è‡ªæ˜çš„ï¼Œä½†æ˜¯æˆ‘å°†å¯¹å®ƒä»¬ä¸­çš„æ¯ä¸€ä¸ªè¿›è¡Œç®€å•ä»‹ç»ï¼Œä»¥ä¾¿æ¸…æ¥šåœ°ç†è§£å®ƒä»¬æ‰“ç®—è¾“å‡ºä»€ä¹ˆå€¼ã€‚</p><ul class=""><li id="2149" class="ma mb ht is b it iu ix iy jb mc jf md jj me jn mf mg mh mi dt translated"><strong class="is hu"> get_stake_amount() <br/> </strong>ç”¨äºè·å–ç©å®¶æŠ•å…¥æ¸¸æˆçš„é‡‘é¢ï¼Œä»¥ä¾›ç©å®¶è¿›è¡Œæ¸¸æˆã€‚</li><li id="3fcd" class="ma mb ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi dt translated"><strong class="is hu"> get_last_winner() <br/> </strong>ç”¨äºè·å–æœ€è¿‘èµ¢å¾—æ¸¸æˆçš„ç©å®¶çš„åœ°å€ã€‚</li><li id="b6bf" class="ma mb ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi dt translated"><strong class="is hu"> get_current_turn() </strong> <br/>è¿™ä¸ªç”¨æ¥è·å–è¯¥è½®åˆ°çš„ç©å®¶ã€‚</li><li id="f824" class="ma mb ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi dt translated"><strong class="is hu">get _ staking _ token()</strong><br/>è¿™ç”¨äºè·å–ç©å®¶å°†ç”¨ä½œèµŒæ³¨çš„èµŒæ³¨ä»¤ç‰ŒåˆåŒçš„åœ°å€ã€‚</li><li id="2e27" class="ma mb ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi dt translated"><strong class="is hu">get _ player _ one _ stake()</strong><br/>ç”¨äºè·å–ç©å®¶ä¸€ä¸‹æ³¨çš„ä»£å¸æ€»æ•°ã€‚</li><li id="da2b" class="ma mb ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi dt translated"><strong class="is hu">get _ player _ two _ stake()</strong><br/>ç”¨äºè·å–ç©å®¶äºŒä¸‹æ³¨çš„ä»£å¸æ€»æ•°ã€‚</li><li id="aa56" class="ma mb ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi dt translated"><strong class="is hu"> get_player_one() </strong> <br/>è¿™ä¸ªç”¨æ¥è·å–ç©å®¶ä¸€çš„é’±åŒ…åœ°å€ã€‚</li><li id="06a4" class="ma mb ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi dt translated"><strong class="is hu"> get_player_two() <br/> </strong>è¿™ä¸ªç”¨æ¥è·å–ç©å®¶äºŒçš„é’±åŒ…åœ°å€ã€‚</li><li id="a22d" class="ma mb ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi dt translated"><strong class="is hu">get _ player _ one _ symbol()</strong><br/>è¿™ä¸ªç”¨æ¥è·å–ç©å®¶ä¸€çš„ç¬¦å·ã€‚</li><li id="efe8" class="ma mb ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi dt translated"><strong class="is hu">get _ player _ two _ symbol()<br/></strong>è¿™ä¸ªç”¨æ¥è·å–ç©å®¶äºŒçš„ç¬¦å·ã€‚</li><li id="fa5f" class="ma mb ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi dt translated"><strong class="is hu"> get_board() <br/> </strong>è¿”å›ä¸€ä¸ªæ•°ç»„ï¼Œè¡¨ç¤ºæ£‹ç›˜ä¸Šä»0åˆ°8çš„å•å…ƒæ ¼çš„å½“å‰æ¸¸æˆçŠ¶æ€ã€‚</li></ul><h1 id="73b7" class="kx ky ht bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">å†…è”åŠ©æ‰‹æ–¹æ³•</h1><p id="4909" class="pw-post-body-paragraph iq ir ht is b it lv iv iw ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn hm dt translated">æœ‰äº›æ–¹æ³•å°†åœ¨å†…éƒ¨ä½¿ç”¨ï¼Œä»¥å¸®åŠ©ç¡®å®šå€¼ä»¥åŠåœ¨æ™ºèƒ½åå®šä¸­æ‰§è¡Œå…¥ç«™æ“ä½œã€‚</p><p id="2610" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">ä»–ä»¬æ˜¯è¿™æ ·çš„:</p><pre class="kf kg kh ki fq mp mq mr bn ms mt bi"><span id="11a8" class="mu ky ht mq b be mv mw l mx my">#[inline]<br/>pub fn _has_won(&amp;self, symbol: u64) -&gt; bool {<br/>    let vertical = [[0,3,6], [1,4,7], [2,5,8]];<br/>    let horizontal = [[0,1,2], [3,4,5], [6,7,8]];<br/>    let diagonal = [[0,4,8], [2,4,6]];<br/>    <br/>    //check vertical<br/>    let mut v_win = false;<br/>    for i in 0..=2 {<br/>        let mut count = 0;<br/>        for j in 0..=2 {<br/>            if self.board[vertical[i][j]] == symbol {<br/>                count += 1;<br/>            }<br/>        }<br/>        if count == 3 {<br/>            v_win = true;<br/>            break;<br/>        }<br/>    }<br/><br/>    //check horizontal<br/>    let mut h_win = false;<br/>    for i in 0..=2 {<br/>        let mut count = 0;<br/>        for j in 0..=2 {<br/>            if self.board[horizontal[i][j]] == symbol {<br/>                count += 1;<br/>            }<br/>        }<br/>        if count == 3 {<br/>            h_win = true;<br/>            break;<br/>        }<br/>    }<br/><br/>    //check diagonal<br/>    let mut d_win = false;<br/>    for i in 0..=1 {<br/>        let mut count = 0;<br/>        for j in 0..=2 {<br/>            if self.board[diagonal[i][j]] == symbol {<br/>                count += 1;<br/>            }<br/>        }<br/>        if count == 3 {<br/>            d_win = true;<br/>            break;<br/>        }<br/>    }<br/><br/>    if v_win == true || h_win == true || d_win == true {<br/>        true<br/>    }<br/>    else {<br/>        false<br/>    }<br/><br/>}<br/><br/>#[inline]<br/>pub fn _clear_board(&amp;mut self) {<br/>    let board = vec![0; 9];<br/>    self.board = board;<br/>}<br/><br/>#[inline]<br/>pub fn _is_cell_empty(&amp;self, cell: u64) -&gt; bool {<br/>    if self.board[usize::try_from(cell).unwrap()] == 0 {<br/>        true<br/>    } else {<br/>        false<br/>    }<br/>}<br/><br/>#[inline]<br/>pub fn _is_board_filled(&amp;self) -&gt; bool {<br/>    let mut filled_cells = 0;<br/>    let board = &amp;self.board;<br/>    for cell in 0..=8 {<br/>        if board[usize::try_from(cell).unwrap()] != 0 {<br/>            filled_cells += 1;<br/>        }<br/>    }<br/>    if filled_cells == 9 {<br/>        true<br/>    } else {<br/>        false<br/>    }<br/>}<br/><br/>#[inline]<br/>pub fn _reward_winner(&amp;mut self, account: AccountId) {<br/>    let total_stakes = PSP22Ref::balance_of(&amp;self.staking_token, Self::env().account_id()); //get total stakes<br/><br/>    PSP22Ref::transfer(<br/>        &amp;self.staking_token,<br/>        account,<br/>        total_stakes,<br/>        ink_prelude::vec![],<br/>    ); //transfer everything to the winner<br/><br/>    self.stakes.insert(self.player_one, &amp;0);<br/>    <br/>    self.stakes.insert(self.player_two, &amp;0);<br/>}<br/><br/>#[inline]<br/>pub fn _refund_tokens(&amp;mut self) {<br/>    let total_stakes = PSP22Ref::balance_of(&amp;self.staking_token, Self::env().account_id()); //get total stakes<br/>    let per_player = total_stakes / 2;<br/><br/>    PSP22Ref::transfer(<br/>        &amp;self.staking_token,<br/>        self.player_one,<br/>        per_player,<br/>        ink_prelude::vec![],<br/>    ); //transfer half to player one<br/>    PSP22Ref::transfer(<br/>        &amp;self.staking_token,<br/>        self.player_two,<br/>        per_player,<br/>        ink_prelude::vec![],<br/>    ); //transfer half to player two<br/><br/>    self.stakes.insert(self.player_one, &amp;0);<br/><br/>    self.stakes.insert(self.player_two, &amp;0);<br/><br/>}</span></pre><p id="e38b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">ç®€è€Œè¨€ä¹‹ï¼Œæˆ‘å°†è§£é‡Šä¸Šé¢çš„å†…è”åŠ©æ‰‹æ–¹æ³•æ˜¯åšä»€ä¹ˆçš„ï¼Œä»¥é˜²ä½ æ²¡æœ‰æ¸…æ¥šåœ°æŒæ¡å®ƒä»¬ã€‚</p><ul class=""><li id="5c34" class="ma mb ht is b it iu ix iy jb mc jf md jj me jn mf mg mh mi dt translated"><strong class="is hu">_ has _ won(symbol:u64)<br/></strong>æ­¤æ–¹æ³•ç”¨äºç¡®å®šç»™å®šçš„ç¬¦å·æ˜¯å¦ä¸ºè·èƒœç¬¦å·ã€‚è¿”å›ä¸€ä¸ªå¸ƒå°”å€¼(çœŸæˆ–å‡)ã€‚ç”¨äºæ£€æŸ¥æ¯ä¸ªå›åˆçš„èµ¢å®¶ã€‚</li><li id="ec04" class="ma mb ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi dt translated"><strong class="is hu"> _clear_board() <br/> </strong>è¯¥æ–¹æ³•ç”¨äºæ¸…ç©ºæ¿å­(è§†æƒ…å†µå°†æ‰€æœ‰å•å…ƒæ ¼ç½®0æˆ–ç©º)ã€‚</li><li id="ab38" class="ma mb ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi dt translated"><strong class="is hu"> _is_cell_empty() <br/> </strong>è¿™æ˜¯ç”¨æ¥åˆ¤æ–­ç»™å®šçš„å•å…ƒæ ¼æ˜¯å¦ä¸ºç©º(å€¼ä¸º0)ã€‚</li><li id="e3ad" class="ma mb ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi dt translated"><strong class="is hu"> _is_board_filled() <br/></strong></li><li id="836b" class="ma mb ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi dt translated"><strong class="is hu">_ reward _ winner(address:account id)<br/></strong>æ­¤æ–¹æ³•å°†æ‰€æœ‰å¯ç”¨çš„ä»¤ç‰Œä½œä¸ºå‚æ•°è½¬ç§»åˆ°æä¾›çš„åœ°å€ã€‚</li><li id="1ca9" class="ma mb ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi dt translated"><strong class="is hu"> _refund_tokens() <br/> </strong>æ­¤æ–¹æ³•ç”¨äºé€€è¿˜æ‰€æœ‰ä»£å¸(é€‚ç”¨äºä¸»åŠ¨å›åˆå‡ºç°å¹³å±€çš„æƒ…å†µ)ã€‚</li></ul><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div class="fe ff kw"><img src="../Images/770852db6f1d835ea0dc5412912446d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/0*Tl3Dpkw3wjZkks_G.gif"/></div><figcaption class="kn ko fg fe ff kp kq bd b be z ek">Image credits: https://getyarn.io</figcaption></figure><h1 id="c735" class="kx ky ht bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">æ¸¸æˆéƒ¨åˆ†</h1><p id="8fae" class="pw-post-body-paragraph iq ir ht is b it lv iv iw ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn hm dt translated">è¿™æ˜¯è¿™ä¸ªæ™ºèƒ½åˆåŒæœ€é‡è¦çš„æ–¹é¢ï¼Œå› ä¸ºå¦‚æœä¸ä»”ç»†æ£€æŸ¥ï¼Œå®ƒå¯èƒ½ä¼šå¯¼è‡´ä¸¥é‡çš„åæœã€‚</p><p id="3253" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">æˆåŠŸçš„æ¸¸æˆæœ‰ä¸¤ç§æ–¹æ³•:</p><ul class=""><li id="37a7" class="ma mb ht is b it iu ix iy jb mc jf md jj me jn mf mg mh mi dt translated">stake _ tokens()</li><li id="b213" class="ma mb ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi dt translated">æ’­æ”¾(å•å…ƒæ ¼:u64)</li></ul><p id="393c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">æˆ‘å°†ä»ç¬¬ä¸€ä¸ªå¼€å§‹(å°½ç®¡æˆ‘åº”è¯¥è¿™æ ·åš:)ã€‚</p><h2 id="78d1" class="mz ky ht bd kz na nb nc ld nd ne nf lh jb ng nh ll jf ni nj lp jj nk nl lt nm dt translated">stake _ tokens()</h2><pre class="kf kg kh ki fq mp mq mr bn ms mt bi"><span id="909d" class="mu ky ht mq b be mv mw l mx my">#[ink(message)]<br/>pub fn stake_tokens(&amp;mut self) {<br/>    let player = self.env().caller(); //get caller address<br/>    let stakes = self.stakes.get(player).unwrap_or(0); //get stake if existent<br/><br/>    assert!(player == self.player_one || player == self.player_two); //Caller must be player one or two<br/><br/>    if stakes &gt; 0 {<br/>        panic!("Already staked for this round")<br/>    } //Make sure player hasn't already staked<br/><br/>    let balance = PSP22Ref::balance_of(&amp;self.staking_token, player); //get user balance of token<br/><br/>    let allowance =<br/>        PSP22Ref::allowance(&amp;self.staking_token, player, Self::env().account_id()); //get spending allowance contract has to player<br/><br/>    assert!(balance &gt; self.stake_amount); //balance must be greater than stake amount<br/><br/>    assert!(allowance &gt; self.stake_amount); //allowance must be greater than stake amount<br/><br/>    //Transfer stake amount from caller (player) to contract<br/>    PSP22Ref::transfer_from_builder(<br/>        &amp;self.staking_token,<br/>        self.env().caller(),<br/>        Self::env().account_id(),<br/>        self.stake_amount,<br/>        ink::prelude::vec![],<br/>    )<br/>    .call_flags(CallFlags::default().set_allow_reentry(true))<br/>    .fire()<br/>    .expect("Transfer failed")<br/>    .expect("Transfer failed");<br/><br/>    self.stakes.insert(player, &amp;self.stake_amount); //Add stake amount to user stake<br/>}</span></pre><p id="f6e3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">æ‚¨å¯ä»¥ä»ä¸Šé¢çš„ä»£ç å—ä¸­æ¨æ–­å‡ºï¼Œè¯¥æ–¹æ³•ç”¨äºå­˜æ”¾ä¸‹ä¸€è½®çš„èµŒæ³¨æ ‡è®°(ä¸‹æ³¨)ã€‚</p><p id="4940" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">é¦–å…ˆï¼Œå®ƒæ£€æŸ¥å‘¼å«è€…æ˜¯ä¸€å·ç©å®¶è¿˜æ˜¯äºŒå·ç©å®¶ï¼Œç„¶åæ£€æŸ¥æ˜¯å¦å·²ç»ä¸‹æ³¨ã€‚</p><p id="5e3c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">æˆ‘ä»¬è¿˜æ£€æŸ¥ä»–ä»¬åœ¨èµŒæ³¨ä»£å¸ä¸­çš„ä½™é¢ï¼Œç¡®ä¿å…¶è¾¾åˆ°èµŒæ³¨é‡‘é¢ï¼Œå¹¶ä¸”æ”¯å‡ºæ´¥è´´è¶³ä»¥è®©åˆåŒä»ç©å®¶çš„é’±åŒ…ä¸­æ”¶å–èµŒæ³¨é‡‘é¢ã€‚</p><p id="ca97" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">æˆ‘ä»¬æœ€åä»ä»–ä»¬çš„é’±åŒ…ä¸­è½¬ç§»èµŒæ³¨ä»£å¸ï¼Œå¹¶å°†èµŒæ³¨æ·»åŠ åˆ°ç©å®¶çš„èµŒæ³¨åœ°å›¾ä¸­ã€‚</p><h2 id="8acc" class="mz ky ht bd kz na nb nc ld nd ne nf lh jb ng nh ll jf ni nj lp jj nk nl lt nm dt translated">æ’­æ”¾(å•å…ƒæ ¼:u64)</h2><p id="be1e" class="pw-post-body-paragraph iq ir ht is b it lv iv iw ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn hm dt translated">æ­¤æ–¹æ³•é‡‡ç”¨u64ç±»å‹çš„å‚æ•°ï¼ŒæŒ‡å®šè¦æ’­æ”¾çš„å•å…ƒæ ¼ã€‚</p><pre class="kf kg kh ki fq mp mq mr bn ms mt bi"><span id="62e6" class="mu ky ht mq b be mv mw l mx my">#[ink(message)]<br/>pub fn play(&amp;mut self, cell: u64) {<br/>    assert!(cell &lt;= 8);<br/><br/>    let player = self.env().caller(); //get caller address<br/><br/>    assert!(player == self.player_one || player == self.player_two); //caller must be player one or two<br/><br/>    assert!(self.get_player_one_stake() &gt; 0 &amp;&amp; self.get_player_two_stake() &gt; 0); //both players must have staked<br/><br/>    let is_empty = self._is_cell_empty(cell); //check if cell is empty<br/><br/>    assert!(is_empty == true); //cell must be empty<br/><br/>    assert!(self.turn == player); //must be player's turn<br/><br/>    let mut board = self.get_board();<br/><br/>    let player_one_symbol = self.get_player_one_symbol();<br/>    let player_two_symbol = self.get_player_two_symbol();<br/><br/>    let cell_index = usize::try_from(cell).unwrap(); //convert index to usize<br/><br/>    board[cell_index] = self.symbols.get(player).unwrap_or(0);<br/><br/>    self.board = board;<br/><br/>    let player_one_won = self._has_won(player_one_symbol);<br/><br/>    let player_two_won = self._has_won(player_two_symbol);<br/><br/>    let mut game_over = false;<br/><br/>    if player_one_won == true {<br/>        //player one won<br/>        self.turn = self.player_one; //set player to start next round<br/>        self._reward_winner(self.player_one);<br/>        self._clear_board(); //clear game board<br/>        self.last_winner = self.player_one; //set to last winner<br/>        game_over = true; //game is over<br/>    } else if player_two_won == true {<br/>        //player two won<br/>        self.turn = self.player_two; //set player to start next round<br/>        self._reward_winner(self.player_two);<br/>        self._clear_board(); //clear game board<br/>        self.last_winner = self.player_one; //set to last winner<br/>        game_over = true;<br/>    } else {<br/>        if self._is_board_filled() == true {<br/>            //It's a draw<br/>            self.turn = self.player_one;<br/>            self._refund_tokens(); //refund tokens because no one won<br/>            self._clear_board();<br/>            game_over = true;<br/>        }<br/>    }<br/><br/>    if game_over == false {<br/>        if self.turn == self.player_one {<br/>            self.turn = self.player_two;<br/>        } else {<br/>            self.turn = self.player_one;<br/>        }<br/>    }<br/>}</span></pre><p id="7988" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">åœ¨å…è®¸ç©å®¶ç§»åŠ¨ä¹‹å‰ï¼Œæˆ‘ä»¬ç”¨è¿™ç§æ–¹æ³•åšäº†å¾ˆå¤šæ£€æŸ¥ã€‚</p><p id="479d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">é¦–å…ˆï¼Œæˆ‘ä»¬è¦ç¡®ä¿å‘¼å«è€…æ˜¯ä¸æ¸¸æˆç›¸å…³è”çš„ä¸¤ä¸ªç©å®¶ä¸­çš„ä»»ä½•ä¸€ä¸ªï¼ŒåŒæ—¶ç¡®ä¿ä¸¤ä¸ªç©å®¶éƒ½å·²ç»ä¸ºè¿™ä¸€è½®ä¸‹æ³¨äº†ä»–ä»¬çš„ä»£å¸ã€‚</p><p id="4c2a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">ç„¶åï¼Œæˆ‘ä»¬ç¡®è®¤è¯¥è½®åˆ°ç»™å®šçš„ç©å®¶äº†ï¼Œä¹‹åæˆ‘ä»¬ä¼šå°†ä»–ä»¬çš„ç¬¦å·å†™å…¥æ£‹ç›˜å­˜å‚¨æ•°ç»„ä¸­é€‚å½“çš„é”®ã€‚</p><p id="799b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">æˆ‘ä»¬æ£€æŸ¥èµ¢å’Œå¹³çš„æ¡ä»¶(å¯¹æ¯ä¸€æ­¥æ£‹éƒ½è¿›è¡Œæ£€æŸ¥)ã€‚</p><p id="03ec" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">å¦‚æœä¸€ä¸ªç©å®¶èµ¢äº†ï¼Œä»–ä»¬ä¼šå¾—åˆ°æ‰€æœ‰çš„é’±ï¼Œæ£‹ç›˜ä¼šè¢«é‡ç½®ï¼Œä»–ä»¬ä¼šæˆä¸ºä¸‹ä¸€ä¸ªç©å®¶(ç©ä¸‹ä¸€è½®)ã€‚</p><p id="c0e4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">å¦‚æœæ¸¸æˆä»¥å¹³å±€ç»“æŸï¼Œæ£‹ç›˜åŒæ ·è¢«æ¸…ç©ºï¼Œä»£å¸è¢«é€€è¿˜ç»™åŒæ–¹ï¼Œæ–°ä¸€è½®å¼€å§‹ã€‚</p><p id="cca5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">æˆ‘ä»¬å®Œäº†ï¼ğŸ”¥</p><p id="96f5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">è¯´äº†è¿™ä¹ˆå¤šï¼Œæˆ‘åº”è¯¥å–æ¯å†°é•‡è‘¡è„é…’ã€‚æˆ‘å¸Œæœ›ä½ å–œæ¬¢é˜…è¯»å’Œ/æˆ–ç»ƒä¹ è¿™ä¸ªæŒ‡å—ğŸ’šã€‚</p><p id="dd0d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">ä¸‹é¢æ˜¯å®Œæ•´çš„æºä»£ç (æˆ‘å·²ç»æ ¼å¼åŒ–äº†:):</p><pre class="kf kg kh ki fq mp mq mr bn ms mt bi"><span id="e021" class="mu ky ht mq b be mv mw l mx my">#![cfg_attr(not(feature = "std"), no_std)]<br/><br/>#[cfg(not(feature = "ink-as-dependency"))]<br/><br/>#[ink::contract]<br/>pub mod tic_tac_toe {<br/><br/>    use ink::prelude::vec;<br/>    use ink::prelude::vec::Vec;<br/>    <br/>    use openbrush::contracts::traits::psp22::PSP22Ref;<br/><br/>    use ink::env::CallFlags;<br/><br/>    use openbrush::traits::Storage;<br/><br/>    #[ink(storage)]<br/>    #[derive(Default, Storage)]<br/>    pub struct TicTacToe {<br/>        board: Vec&lt;u64&gt;, //0 to 8 cells<br/>        turn: AccountId,<br/>        symbols: ink::storage::Mapping&lt;AccountId, u64&gt;,<br/>        player_one: AccountId,<br/>        player_two: AccountId,<br/>        staking_token: AccountId,<br/>        stake_amount: Balance,<br/>        stakes: ink::storage::Mapping&lt;AccountId, Balance&gt;,<br/>        last_winner: AccountId,<br/>    }<br/><br/>    impl TicTacToe {<br/>        /// Creates a new instance of this contract.<br/>        #[ink(constructor)]<br/>        pub fn new(<br/>            player_one: AccountId,<br/>            player_two: AccountId,<br/>            player_one_symbol: u64,<br/>            player_two_symbol: u64,<br/>            staking_token: AccountId,<br/>            stake_amount: Balance,<br/>        ) -&gt; Self {<br/><br/>            let mut contract = Self::default();<br/><br/>            let board = vec![0; 9]; //empty array<br/><br/>            contract.board = board; //set board to empty state<br/><br/>            contract.staking_token = staking_token; //set staking token<br/><br/>            contract.stake_amount = stake_amount; //set stake amount<br/><br/>            assert!(player_one != player_two); //addresses must not be the same<br/><br/>            assert!(player_one_symbol != player_two_symbol); //symbols must be distinct<br/><br/>            assert!(<br/>                (player_one_symbol == 1 || player_one_symbol == 2)<br/>                    &amp;&amp; (player_two_symbol == 1 || player_two_symbol == 2)<br/>            ); //symbols must be either 1 or 2<br/><br/>            contract.player_one = player_one; //set player one address<br/><br/>            contract.player_two = player_two; //set player two address<br/><br/>            contract.symbols.insert(player_one, &amp;player_one_symbol); //set player one symbol<br/><br/>            contract.symbols.insert(player_two, &amp;player_two_symbol); //set player two symbol<br/><br/>            contract.turn = player_one; //initialize turn to player one<br/><br/>            contract<br/><br/>        }<br/><br/>        #[ink(message)]<br/>        pub fn get_stake_amount(&amp;self) -&gt; Balance {<br/>            self.stake_amount //amount to be staked in game<br/>        }<br/><br/>        #[ink(message)]<br/>        pub fn get_last_winner(&amp;self) -&gt; AccountId {<br/>            self.last_winner //address of most recent winner<br/>        }<br/><br/>        #[ink(message)]<br/>        pub fn get_current_turn(&amp;self) -&gt; AccountId {<br/>            self.turn //who is meant to play?<br/>        }<br/><br/>        #[ink(message)]<br/>        pub fn get_staking_token(&amp;self) -&gt; AccountId {<br/>            self.staking_token //get address of staking token smart contract<br/>        }<br/><br/>        #[ink(message)]<br/>        pub fn get_player_two_stake(&amp;self) -&gt; Balance {<br/>            self.stakes.get(self.player_two).unwrap_or(0) //get total amount of tokens staked by player two<br/>        }<br/><br/>        #[ink(message)]<br/>        pub fn get_player_one_stake(&amp;self) -&gt; Balance {<br/>            self.stakes.get(self.player_one).unwrap_or(0) //get total amount of tokens staked by player one<br/>        }<br/><br/>        #[ink(message)]<br/>        pub fn get_player_one(&amp;self) -&gt; AccountId {<br/>            self.player_one //get player one address<br/>        }<br/><br/>        #[ink(message)]<br/>        pub fn get_player_two(&amp;self) -&gt; AccountId {<br/>            self.player_two //get player two address<br/>        }<br/><br/>        #[ink(message)]<br/>        pub fn get_player_two_symbol(&amp;self) -&gt; u64 {<br/>            self.symbols.get(self.player_two).unwrap_or(0) //get player two symbol<br/>        }<br/><br/>        #[ink(message)]<br/>        pub fn get_player_one_symbol(&amp;self) -&gt; u64 {<br/>            self.symbols.get(self.player_one).unwrap_or(0) //get player one symbol<br/>        }<br/><br/>        #[ink(message)]<br/>        pub fn get_board(&amp;self) -&gt; Vec&lt;u64&gt; {<br/>            //read and return board as array<br/>            let board = &amp;self.board;<br/>            board.to_vec()<br/>        }<br/><br/>        #[ink(message)]<br/>        pub fn stake_tokens(&amp;mut self) {<br/>            let player = self.env().caller(); //get caller address<br/>            let stakes = self.stakes.get(player).unwrap_or(0); //get stake if existent<br/><br/>            assert!(player == self.player_one || player == self.player_two); //Caller must be player one or two<br/><br/>            if stakes &gt; 0 {<br/>                panic!("Already staked for this round")<br/>            } //Make sure player hasn't already staked<br/><br/>            let balance = PSP22Ref::balance_of(&amp;self.staking_token, player); //get user balance of token<br/><br/>            let allowance =<br/>                PSP22Ref::allowance(&amp;self.staking_token, player, Self::env().account_id()); //get spending allowance contract has to player<br/><br/>            assert!(balance &gt; self.stake_amount); //balance must be greater than stake amount<br/><br/>            assert!(allowance &gt; self.stake_amount); //allowance must be greater than stake amount<br/><br/>            //Transfer stake amount from caller (player) to contract<br/>            PSP22Ref::transfer_from_builder(<br/>                &amp;self.staking_token,<br/>                self.env().caller(),<br/>                Self::env().account_id(),<br/>                self.stake_amount,<br/>                ink::prelude::vec![],<br/>            )<br/>            .call_flags(CallFlags::default().set_allow_reentry(true))<br/>            .fire()<br/>            .expect("Transfer failed")<br/>            .expect("Transfer failed");<br/><br/>            self.stakes.insert(player, &amp;self.stake_amount); //Add stake amount to user stake<br/>        }<br/><br/>        #[inline]<br/>        pub fn _has_won(&amp;self, symbol: u64) -&gt; bool {<br/>            let vertical = [[0, 3, 6], [1, 4, 7], [2, 5, 8]];<br/>            let horizontal = [[0, 1, 2], [3, 4, 5], [6, 7, 8]];<br/>            let diagonal = [[0, 4, 8], [2, 4, 6]];<br/><br/>            //check vertical<br/>            let mut v_win = false;<br/>            for i in 0..=2 {<br/>                let mut count = 0;<br/>                for j in 0..=2 {<br/>                    if self.board[vertical[i][j]] == symbol {<br/>                        count += 1;<br/>                    }<br/>                }<br/>                if count == 3 {<br/>                    v_win = true;<br/>                    break;<br/>                }<br/>            }<br/><br/>            //check horizontal<br/>            let mut h_win = false;<br/>            for i in 0..=2 {<br/>                let mut count = 0;<br/>                for j in 0..=2 {<br/>                    if self.board[horizontal[i][j]] == symbol {<br/>                        count += 1;<br/>                    }<br/>                }<br/>                if count == 3 {<br/>                    h_win = true;<br/>                    break;<br/>                }<br/>            }<br/><br/>            //check diagonal<br/>            let mut d_win = false;<br/>            for i in 0..=1 {<br/>                let mut count = 0;<br/>                for j in 0..=2 {<br/>                    if self.board[diagonal[i][j]] == symbol {<br/>                        count += 1;<br/>                    }<br/>                }<br/>                if count == 3 {<br/>                    d_win = true;<br/>                    break;<br/>                }<br/>            }<br/><br/>            if v_win == true || h_win == true || d_win == true {<br/>                true<br/>            } else {<br/>                false<br/>            }<br/>        }<br/><br/>        #[inline]<br/>        pub fn _clear_board(&amp;mut self) {<br/>            let board = vec![0; 9];<br/>            self.board = board;<br/>        }<br/><br/>        #[inline]<br/>        pub fn _is_cell_empty(&amp;self, cell: u64) -&gt; bool {<br/>            if self.board[usize::try_from(cell).unwrap()] == 0 {<br/>                true<br/>            } else {<br/>                false<br/>            }<br/>        }<br/><br/>        #[inline]<br/>        pub fn _is_board_filled(&amp;self) -&gt; bool {<br/>            let mut filled_cells = 0;<br/>            let board = &amp;self.board;<br/>            for cell in 0..=8 {<br/>                if board[usize::try_from(cell).unwrap()] != 0 {<br/>                    filled_cells += 1;<br/>                }<br/>            }<br/>            if filled_cells == 9 {<br/>                true<br/>            } else {<br/>                false<br/>            }<br/>        }<br/><br/>        #[inline]<br/>        pub fn _reward_winner(&amp;mut self, account: AccountId) {<br/>            let total_stakes = PSP22Ref::balance_of(&amp;self.staking_token, Self::env().account_id()); //get total stakes<br/><br/>            PSP22Ref::transfer(<br/>                &amp;self.staking_token,<br/>                account,<br/>                total_stakes,<br/>                ink::prelude::vec![],<br/>            ); //transfer everything to the winner<br/><br/>            self.stakes.insert(self.player_one, &amp;0);<br/>            <br/>            self.stakes.insert(self.player_two, &amp;0);<br/>        }<br/><br/>        #[inline]<br/>        pub fn _refund_tokens(&amp;mut self) {<br/>            let total_stakes = PSP22Ref::balance_of(&amp;self.staking_token, Self::env().account_id()); //get total stakes<br/>            let per_player = total_stakes / 2;<br/><br/>            PSP22Ref::transfer(<br/>                &amp;self.staking_token,<br/>                self.player_one,<br/>                per_player,<br/>                ink::prelude::vec![],<br/>            ); //transfer half to player one<br/>            PSP22Ref::transfer(<br/>                &amp;self.staking_token,<br/>                self.player_two,<br/>                per_player,<br/>                ink::prelude::vec![],<br/>            ); //transfer half to player two<br/><br/>            self.stakes.insert(self.player_one, &amp;0);<br/><br/>            self.stakes.insert(self.player_two, &amp;0);<br/><br/>        }<br/><br/>        #[ink(message)]<br/>        pub fn play(&amp;mut self, cell: u64) {<br/>            assert!(cell &lt;= 8);<br/><br/>            let player = self.env().caller(); //get caller address<br/><br/>            assert!(player == self.player_one || player == self.player_two); //caller must be player one or two<br/><br/>            assert!(self.get_player_one_stake() &gt; 0 &amp;&amp; self.get_player_two_stake() &gt; 0); //both players must have staked<br/><br/>            let is_empty = self._is_cell_empty(cell); //check if cell is empty<br/><br/>            assert!(is_empty == true); //cell must be empty<br/><br/>            assert!(self.turn == player); //must be player's turn<br/><br/>            let mut board = self.get_board();<br/><br/>            let player_one_symbol = self.get_player_one_symbol();<br/>            let player_two_symbol = self.get_player_two_symbol();<br/><br/>            let cell_index = usize::try_from(cell).unwrap(); //convert index to usize<br/><br/>            board[cell_index] = self.symbols.get(player).unwrap_or(0);<br/><br/>            self.board = board;<br/><br/>            let player_one_won = self._has_won(player_one_symbol);<br/><br/>            let player_two_won = self._has_won(player_two_symbol);<br/><br/>            let mut game_over = false;<br/><br/>            if player_one_won == true {<br/>                //player one won<br/>                self.turn = self.player_one; //set player to start next round<br/>                self._reward_winner(self.player_one);<br/>                self._clear_board(); //clear game board<br/>                self.last_winner = self.player_one; //set to last winner<br/>                game_over = true; //game is over<br/>            } else if player_two_won == true {<br/>                //player two won<br/>                self.turn = self.player_two; //set player to start next round<br/>                self._reward_winner(self.player_two);<br/>                self._clear_board(); //clear game board<br/>                self.last_winner = self.player_one; //set to last winner<br/>                game_over = true;<br/>            } else {<br/>                if self._is_board_filled() == true {<br/>                    //It's a draw<br/>                    self.turn = self.player_one;<br/>                    self._refund_tokens(); //refund tokens because no one won<br/>                    self._clear_board();<br/>                    game_over = true;<br/>                }<br/>            }<br/><br/>            if game_over == false {<br/>                if self.turn == self.player_one {<br/>                    self.turn = self.player_two;<br/>                } else {<br/>                    self.turn = self.player_one;<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</span></pre><h1 id="41c4" class="kx ky ht bd kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu dt translated">è„šæ³¨</h1><p id="e121" class="pw-post-body-paragraph iq ir ht is b it lv iv iw ix lw iz ja jb lx jd je jf ly jh ji jj lz jl jm jn hm dt translated">å¦‚æœä½ å–œæ¬¢è¿™ç¯‡æ–‡ç« å’Œ/æˆ–è§‰å¾—å®ƒæœ‰å¸®åŠ©ï¼Œè¯·åœ¨Twitterä¸Šå…³æ³¨æˆ‘ï¼Œå…³æ³¨æˆ‘çš„åŠ¨å‘ğŸ˜ã€‚è¦è·å¾—GitHubä¸Šçš„å®Œæ•´æºä»£ç ï¼Œè¯·è®¿é—®<a class="ae jx" href="https://github.com/EdinyangaOttoho/ink-tic-tac-toe" rel="noopener ugc nofollow" target="_blank">æ­¤é“¾æ¥</a>ã€‚å€¼å¾—ç§°èµã€‚</p><p id="d815" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">ä½ å¯ä»¥éšæ—¶å‰åº“ï¼Œå¹¶ç»™æˆ‘å‘ä¸€ä»½å…¬å…³ä½ å–œæ¬¢çš„ä»»ä½•æ—¶å€™ã€‚</p><p id="7ef8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">ä¸ºäº†åœ¨Aleph Zero Testnetä¸Šéƒ¨ç½²æ‚¨çš„æ™ºèƒ½åˆçº¦ï¼Œä½¿å…¶å…·æœ‰æœ‰è¶£ä¸”æµç•…çš„ç”¨æˆ·ç•Œé¢ï¼Œæ‚¨å¯ä»¥ç‚¹å‡»<a class="ae jx" href="https://test.azero.dev/#/" rel="noopener ugc nofollow" target="_blank">æ­¤é“¾æ¥</a>ã€‚</p><p id="1c12" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">å¦‚æœæ‚¨å·²ç»é˜…è¯»äº†æœ¬æ–‡ï¼Œé‚£ä¹ˆæ‚¨åº”è¯¥å¾—åˆ°ä¸€äº›$AZEROä»£å¸:)</p><p id="eb04" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">æˆ‘å¾ˆé«˜å…´æœ‰ä½ ä¸€ç›´åœ¨è¿™é‡Œã€‚</p><blockquote class="nn"><p id="12f2" class="no np ht bd nq nr ns nt nu nv nw jn ek translated">äº¤æ˜“æ–°æ‰‹ï¼Ÿè¯•è¯•<a class="ae jx" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">åŠ å¯†äº¤æ˜“æœºå™¨äºº</a>æˆ–è€…<a class="ae jx" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">å¤åˆ¶äº¤æ˜“</a></p></blockquote></div></div>    
</body>
</html>