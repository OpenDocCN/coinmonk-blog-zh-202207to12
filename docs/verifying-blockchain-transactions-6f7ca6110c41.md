# 验证区块链交易

> 原文：<https://medium.com/coinmonks/verifying-blockchain-transactions-6f7ca6110c41?source=collection_archive---------32----------------------->

## 区块链

![](img/f2e5145eb1111d9341dc37c51f3eebe2.png)

我们在上一篇文章的[中讨论了证明比特币的所有权。让我们在本文中详细讨论验证事务是如何工作的。](https://www.thearmchaircritic.org/mansplainings/proving-ownership-of-coins-in-blockchain)

还记得之前我们了解到，除了区块链用来验证交易的公钥散列之外，公钥脚本还有几个脚本吗？我们将使用这些脚本来验证交易。让我们看看怎么做。

但是在此之前，请注意，我们使用 pubkey 脚本来验证使用它作为输入的事务。换句话说，为了验证一个事务，我们使用其输入的 pubkey 脚本。在我们在[早期文章](https://www.thearmchaircritic.org/mansplainings/understanding-blockchain-transactions)中看到的例子中，我们的交易将由 pubkey 脚本验证，这些脚本是给我们 0.75 比特币和 0.4 比特币的交易输出的，因为我们使用它们作为输入。

# 公钥脚本

公钥脚本由以下脚本组成:

这些脚本中的每一个都在验证过程中执行特定的功能。让我们看看这个验证过程是如何工作的。

正如我们已经看到的，pubkey 脚本也包含 pubkey 散列。因此，我们可以在 pubkey 脚本中按以下顺序找到 pubkey 哈希和脚本:

> 交易新手？在[最佳加密交易](/coinmonks/crypto-exchange-dd2f9d6f3769)上尝试[加密交易机器人](/coinmonks/crypto-trading-bot-c2ffce8acb2a)或[复制交易](/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c)

# 核查进程

在验证过程的第一步中，我们将当前交易的签名脚本(包含交易的数字签名和交易者的公钥)添加到 pubkey 脚本中。因此，我们将有以下内容:

然后，我们从数字签名开始执行这个脚本，直到 OP_CHECKSIG 脚本。因为这个脚本中的第一个数字签名只是数据，所以我们将它放入堆栈中。[堆栈](https://en.wikipedia.org/wiki/Stack_(abstract_data_type))是一种数据结构，其中最先添加的项目只能最后移除。为了获得更好的直觉，可以把一个栈想象成一个 CD 栈。您首先放入的 CD 只能最后取出。

公钥也只是数据，我们将其放入堆栈，放在数字签名之上。堆栈现在看起来像这样:

现在，脚本中的第三个是 OP_DUP，这是一个脚本。该脚本复制堆栈顶部的数据。因为公钥位于堆栈的顶部，所以脚本复制了它。现在，我们的堆栈如下所示:

# 获取公钥哈希

脚本中的下一个是 OP_HASH160，它也是一个脚本。这个脚本对栈顶的数据进行两次散列，并在删除原始数据后将散列值推入栈中。因为公共密钥在顶部，所以脚本会推送它的散列。现在，堆栈看起来像这样:

脚本中的下一个是 Pubkey 散列。由于这是数据，我们将它推入堆栈，使堆栈看起来如下:

1.  公钥哈希(来自公钥脚本)
2.  公钥散列
3.  公开密钥
4.  数字签名

# 验证所有权

脚本中的下一个是 OP_EQUALVERFY，这是一个脚本。这个脚本由两个脚本组成——OP _ EQUAL 和 OP_VERFY。OP_EQUAL 首先检查堆栈顶部的两个值是否相等。顶部的两个值是公钥散列。

但是请记住，最顶层的公钥散列来自公钥脚本，我们使用交易者的签名脚本获得了第二个散列。因此，前者是交易发送到的帐户的公钥的散列，后者是当前交易者的公钥。

因此，这个 OP_EQUAL 脚本所做的是验证交易的发起者是否是从上一笔交易中收到钱的人。换句话说，它已经验证了所有权。如果两个哈希值相等，那么这个脚本弹出(删除)这两个哈希值，并将值 1 压入。如果验证失败，那么脚本弹出这两个哈希值，并将值设为 0。假设验证成功。这是堆栈现在的样子:

然后，OP_VERIFY 脚本检查堆栈顶部的值。如果为 0，则意味着比特币不属于发送方，因此脚本终止验证过程，交易验证失败。如果值为 1，那么它弹出这个值并继续剩余的过程。现在，堆栈如下所示:

# 验证签名

脚本中的下一个是 OP_CHECKSIG 脚本。这将检查数字签名的有效性。堆栈中的公钥是来自交易者签名脚本的密钥。但是 pubkey 脚本已经验证了这个公钥与使用 OP_EQUALVERIFY 脚本将前一个事务发送到的公钥相同。

因此，OP_CHECKSIG 脚本使用这个公钥来解密数字签名。如果数字签名可以被解密，那么这意味着它已经使用交易者的私钥进行了加密，这有效地验证了交易者。解密的数据是事务的散列。然后，该事务被散列两次，以查看它是否与通过解密数字签名获得的散列相匹配。如果它们相同，则证明交易数据是准确的。

现在，事务已经被验证，OP_CHECKSIG 脚本将值‘true’压入堆栈。如果签名不能被解密或者散列不匹配，那么值‘false’被推入堆栈。如果堆栈顶部的值不为“false”，则事务被视为有效。

在本文中，我们看到了交易验证是如何发生的。在下一篇文章中，我们将看到谁执行这些验证，以及如何存储经过验证的事务。

*原载于 2022 年 11 月 20 日*[*【https://www.thearmchaircritic.org】*](https://www.thearmchaircritic.org/mansplainings/verifying-blockchain-transactions)*。*