<html>
<head>
<title>Learn Solidity lesson 23. Loops and conditionals.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习第23课坚固性。循环和条件句。</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/learn-solidity-lesson-23-loops-and-conditionals-2e90489cd865?source=collection_archive---------3-----------------------#2022-08-13">https://medium.com/coinmonks/learn-solidity-lesson-23-loops-and-conditionals-2e90489cd865?source=collection_archive---------3-----------------------#2022-08-13</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/bb76b8edda27a377bff2f23574044baf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CSRH2F6aA4gebm1BUi_NKA.jpeg"/></div></div></figure><p id="cdb0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">Solidity有类似于其他编程语言的循环和条件。它的语法与C、Java和JavaScript非常相似，所以这一章对于习惯用上述语言编程的人来说应该很简单。</p><h1 id="b4ae" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">如果/否则/否则如果</h1><p id="f614" class="pw-post-body-paragraph jb jc ht jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy hm dt translated">当程序在它的流程中找到某种分支时，如果满足某个条件，它必须遵循某个路径，我们就有了一个条件。对于这种情况，我们使用关键字<strong class="jd hu"> if/else </strong>。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="d595" class="ll ka ht lh b fv lm ln l lo lp">if (condition) {<br/>   ... <br/>   code to be executed if the condition is satisfied.<br/>   ...<br/>} else {<br/>   ...     <br/>   code to be executed if the condition is not satisfied.<br/>   ...<br/>}</span></pre><p id="34dc" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">条件必须是返回true或false的表达式，如<em class="lq"> x &gt; 3 </em>或<em class="lq">(y&lt;1&amp;T35】z = = 4)</em>。请注意，Solidity不会将值<em class="lq"> 1 </em>转换为<em class="lq">真</em>，也不会将空字符串转换为<em class="lq">假</em>。</p><p id="d6a6" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">通常，与其使用<em class="lq"> if/else </em>，不如使用<em class="lq"> require </em>来检查一个条件。它们没有相同的效果，应该根据代码的目的来使用。</p><p id="58ea" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们假设，只有当事务的发送者是先前在变量<code class="eh lr ls lt lh b">owner</code>中注册的地址时，我们才希望函数被正确执行。我们可以有下面的。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="426a" class="ll ka ht lh b fv lm ln l lo lp">function onlyOwner() public {<br/>   if (msg.sender === owner) {<br/>      ... some code<br/>   }<br/>}</span></pre><p id="1ff4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果发送方不是<code class="eh lr ls lt lh b">owner</code>的地址，上面的函数没有作用，但是交易有效，不会抛出错误。这通常不是我们想要的。我们可以改进这个函数来抛出一个错误，如下所示。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="e547" class="ll ka ht lh b fv lm ln l lo lp">function onlyOwner() public {<br/>   if (msg.sender == owner) {<br/>      ... some code<br/>   } else <br/>      revert("Sender not owner"); <br/>   }<br/>}</span></pre><p id="78da" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果所有者不是事务的发送者，事务将通过<em class="lq"> revert </em>方法回滚。上述条件在其他编程语言中很常见，但是在这种情况下，使用<em class="lq"> require </em>方法更可靠。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="a472" class="ll ka ht lh b fv lm ln l lo lp">function onlyOwner() public {<br/>   require(msg.sender == owner, "Sender not owner");<br/>   ... some code<br/>}</span></pre><p id="f780" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果<em class="lq"> require </em>内的条件为假，事务将回滚。作为第二个参数，我们可以向事务的发送方发送一条错误消息。</p><p id="6031" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">Solidity还接受<strong class="jd hu"> else if </strong>表达式，这允许您链接条件，如下所示。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="a2eb" class="ll ka ht lh b fv lm ln l lo lp">if (condition) {... code ...}<br/>else if (condition) {... code ...}<br/>...<br/>else {... code ...}</span></pre><p id="5ea1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在其他编程语言中，可以使用<em class="lq">开关</em>替换上述链式条件，但Solidity中不存在这个关键字。在上面的场景中，我们必须使用多个<em class="lq"> if的</em>。</p><h1 id="1028" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">while、do while和for循环</h1><p id="32c6" class="pw-post-body-paragraph jb jc ht jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy hm dt translated">当我们希望一个代码块运行多次时，我们使用某种形式的循环。我们先来看一下<strong class="jd hu"> while </strong>的用法，它在某个条件为真的情况下执行一段代码。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="9245" class="ll ka ht lh b fv lm ln l lo lp">while (condition) {<br/>   // code to be executed<br/>}</span></pre><p id="3b8f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在一个循环中，我们可以使用两个关键字:<em class="lq"> break </em>和<em class="lq"> continue </em>。如果EVM在循环中遇到<em class="lq">中断</em>，它将退出循环并继续循环后的代码流。如果它发现一个<em class="lq"> continue </em>，它将跳过剩余的代码块，并返回到conditional，再进行一次循环迭代。我们来看例子。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="c766" class="ll ka ht lh b fv lm ln l lo lp">uint8 last;<br/>uint8 i;<br/>while(i &lt; 10) {<br/>   last = i;<br/>   i++;<br/>   if (i==5) break;<br/>} // last =&gt; 4</span></pre><p id="f6a8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">首先我们定义一个变量<code class="eh lr ls lt lh b">i</code>作为计数器。变量<code class="eh lr ls lt lh b">last</code>将在条件中存储计数器的最后一个值。对于每次迭代，我们递增计数器。</p><p id="37d9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当变量<code class="eh lr ls lt lh b">i</code>的值达到4时，在循环块中它递增到5(通过表达式i++，相当于i=i+1)。然后条件<code class="eh lr ls lt lh b"><em class="lq">(</em>i==5)<em class="lq"> </em></code>将为真，<em class="lq">中断</em>将被执行，循环终止。</p><p id="efa0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">使用<strong class="jd hu">继续</strong>关键字的示例如下所示。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="d98b" class="ll ka ht lh b fv lm ln l lo lp">uint8 total;<br/>uint8 i;<br/>while(i &lt; 10) {<br/>   i++;<br/>   if (i==5) continue;<br/>   total++;<br/>} // total =&gt; 9</span></pre><p id="b156" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">上述循环将被执行10次，因为变量<code class="eh lr ls lt lh b">i</code>将从0运行到9。然而，变量<code class="eh lr ls lt lh b">total</code>的最终值是9，而不是10。这是因为当<code class="eh lr ls lt lh b">i</code>为5时，条件<code class="eh lr ls lt lh b">(i==5)</code>将为真，并且<em class="lq">继续</em>将被执行。这样，循环将回到起点，变量<code class="eh lr ls lt lh b">total</code>的增量将不会在特定的迭代中执行。</p><p id="4aec" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu"> do while </strong>循环类似于<em class="lq"> while </em>循环，不同的是在代码块执行后检查条件，而不是在开始时。</p><p id="3e9e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在下面的示例中，即使条件显式为假，也至少会执行第一次迭代。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="8c24" class="ll ka ht lh b fv lm ln l lo lp">uint8 value;<br/>do {<br/>   value = 10;<br/>} while(false); // value =&gt; 10</span></pre><p id="7701" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在上面的例子中，需要三个基本要素:计数器、条件和递增计数器的方法。使用循环的<strong class="jd hu">很容易实现这三个要素。</strong></p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="8915" class="ll ka ht lh b fv lm ln l lo lp">for (initialize the counter; conditional; increment) {<br/>   // code to be executed<br/>}</span></pre><p id="b6e2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们写一个例子来迭代一个数组并改变它的所有条目。</p><pre class="lc ld le lf fq lg lh li lj aw lk dt"><span id="a4e0" class="ll ka ht lh b fv lm ln l lo lp">uint[] memory array = new uint[](5);</span><span id="25c6" class="ll ka ht lh b fv lu ln l lo lp">for(uint i=0; i &lt; array.length; i++) {<br/>   array[i] = i;<br/>} // array =&gt; [0,1,2,3,4]</span></pre><p id="e2f3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在Solidity中使用循环时，你必须小心一点，尤其是在添加/改变状态变量时。管理状态变量是以太坊上最消耗气体的操作之一，因此对状态变量进行多次更改的循环会消耗大量气体。</p><p id="1e9b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">感谢阅读！</strong></p><p id="f8bf" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎对本文提出意见和建议。</p><p id="4942" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎任何投稿。<a class="ae lv" href="http://www.buymeacoffee.com/jpmorais" rel="noopener ugc nofollow" target="_blank">www.buymeacoffee.com/jpmorais</a></p><blockquote class="lw"><p id="97be" class="lx ly ht bd lz ma mb mc md me mf jy ek translated">加入Coinmonks <a class="ae lv" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae lv" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>了解加密交易和投资</p></blockquote><h1 id="4012" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk mg km kn ko mh kq kr ks mi ku kv kw dt translated">另外，阅读</h1><ul class=""><li id="77d5" class="mj mk ht jd b je kx ji ky jm ml jq mm ju mn jy mo mp mq mr dt translated">最好的<a class="ae lv" rel="noopener" href="/coinmonks/best-crypto-tax-tool-for-my-money-72d4b430816b">加密税务软件</a> | <a class="ae lv" rel="noopener" href="/coinmonks/cointracking-review-a-reliable-cryptocurrency-tax-software-5114e3eb5737">硬币追踪评论</a></li><li id="4563" class="mj mk ht jd b je ms ji mt jm mu jq mv ju mw jy mo mp mq mr dt translated"><a class="ae lv" href="https://coincodecap.com/stackedinvest-review" rel="noopener ugc nofollow" target="_blank"> Stackedinvest评论</a> | <a class="ae lv" rel="noopener" href="/coinmonks/kraken-review-6165fc1056ac">北海巨妖评论</a> | <a class="ae lv" href="https://coincodecap.com/bitflyer-review" rel="noopener ugc nofollow" target="_blank"> bitFlyer评论</a></li><li id="d3f9" class="mj mk ht jd b je ms ji mt jm mu jq mv ju mw jy mo mp mq mr dt translated">最佳<a class="ae lv" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">加密借贷平台</a> | <a class="ae lv" rel="noopener" href="/coinmonks/leveraged-token-3f5257808b22">杠杆代币</a></li><li id="63ff" class="mj mk ht jd b je ms ji mt jm mu jq mv ju mw jy mo mp mq mr dt translated">最佳<a class="ae lv" rel="noopener" href="/coinmonks/what-are-the-best-charting-platforms-for-cryptocurrency-trading-85aade584d80">加密制图工具</a> | <a class="ae lv" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a></li><li id="4ea3" class="mj mk ht jd b je ms ji mt jm mu jq mv ju mw jy mo mp mq mr dt translated"><a class="ae lv" href="https://coincodecap.com/bitsler-review" rel="noopener ugc nofollow" target="_blank">比斯勒评论</a>|<a class="ae lv" href="https://coincodecap.com/wazirx-vs-coinswitch-vs-coindcx" rel="noopener ugc nofollow" target="_blank">WazirX vs coin switch vs coin dcx</a></li></ul></div></div>    
</body>
</html>