<html>
<head>
<title>Learn Solidity lesson 36. Cryptography and digital signature.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习第36课固体。密码学和数字签名。</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/learn-solidity-lesson-36-cryptography-and-digital-signature-5330e4ae600e?source=collection_archive---------1-----------------------#2022-11-27">https://medium.com/coinmonks/learn-solidity-lesson-36-cryptography-and-digital-signature-5330e4ae600e?source=collection_archive---------1-----------------------#2022-11-27</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/450d0e3783b3ef682330312adceff6c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BzxGRw5_5u-PrwSb5wjrSQ.jpeg"/></div></div></figure><p id="66de" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">以太坊虚拟机有各种与密码相关的操作码，从散列一组通用字节到验证签名的真实性。Solidity实现这样的操作码非常简单。让我们从散列函数开始。</p><h1 id="29b3" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">哈希函数</h1><p id="4259" class="pw-post-body-paragraph jb jc ht jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy hm dt translated">Solidity实现了三个加密哈希函数:keccak256、sha-256和ripemd160。以太坊网络主要使用keccak256来计算与给定公钥相关的地址。Sha-256和ripmemd160在以太坊网络上用得不多，但在比特币等其他网络协议上被广泛使用。</p><p id="c84d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">keccak256和sha-256都是从通用字节输入返回32字节值的函数。Ripemd160返回值为20个字节。</p><p id="c010" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们编写一个函数，根据给定的字符串计算keccak256和sha-256。</p><pre class="lc ld le lf fq lg lh li bn lj lk bi"><span id="d554" class="ll ka ht lh b be lm ln l lo lp">function getHash(string memory _text) public pure returns (bytes32, bytes32) {<br/>    return (keccak256(bytes(_text)), sha256(bytes(_text)));<br/>}</span></pre><p id="4fd9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">函数keccak256和sha-256接收bytes类型的值作为输入，因此我们必须将字符串转换成字节。哈希来自字符串的UTF-8编码。在下图中，我们看到了对字符串<code class="eh lq lr ls lh b">Hello World</code>执行函数<code class="eh lq lr ls lh b">getHash</code>的结果。</p><figure class="lc ld le lf fq iu fe ff paragraph-image"><div class="fe ff lt"><img src="../Images/749fb019d7d9ce525dc3e121c166dbd7.png" data-original-src="https://miro.medium.com/v2/resize:fit:762/format:webp/1*CDYQM6gu2rXGxun-07PWaA.png"/></div><figcaption class="lu lv fg fe ff lw lx bd b be z ek">Keccak and sha-256 for Hello World.</figcaption></figure><p id="af3b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">ripemd160函数的工作方式类似，不同之处在于它返回一个20字节的值。</p><h1 id="fe02" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">以太坊上的数字签名</h1><p id="7b51" class="pw-post-body-paragraph jb jc ht jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy hm dt translated">以太坊和大多数其他区块链上的数字签名都是基于椭圆曲线加密，使用标准的secp256k1曲线。我们不会深入研究椭圆曲线加密的数学，但会展示它如何在以太坊上工作。这个想法很简单，但问题出在细节上。</p><p id="00ba" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">数字签名的目的是保证消息的完整性和不可否认性。发送者使用他的私钥签署消息，生成签名。从签名和原始消息中，可以恢复签署消息的人的公钥(和地址)。签名者不可能否认他的私钥被用于签名消息。</p><p id="f8a7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">对邮件的任何微小更改都会使签名无效。数字签名保证了消息的完整性，并且只对该特定消息有效。消息签名方案如下图所示。</p><figure class="lc ld le lf fq iu fe ff paragraph-image"><div class="fe ff ly"><img src="../Images/06954ed58f6c7c98045c6bb148e350e6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1122/format:webp/1*3x-5GDn-TOi4LcrEMWZlBw.png"/></div><figcaption class="lu lv fg fe ff lw lx bd b be z ek">The signature is generated by hashing the message using the private key.</figcaption></figure><p id="091a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">由于消息的大小可以是任意的，所以通常不对消息本身进行签名，而是对消息的哈希进行签名，哈希的大小固定为32个字节。在以太坊中，keccak256用于散列消息。</p><p id="8a31" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">以太坊中的消息签名是一个65字节的值。分为三部分，分别用<strong class="jd hu"> r </strong>、<strong class="jd hu"> s </strong>和<strong class="jd hu"> v </strong>表示。<em class="lz"> r </em>和<em class="lz"> s </em>都是32字节长，而<em class="lz"> v </em>是1字节长。</p><p id="be0b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">然而，上述方案有一个潜在的安全缺陷。由于消息签名仅依赖于消息和私钥，所以理论上，同一个签名可以在多个网络中重复使用。为了解决这个问题，Ethereum在消息散列和签名之间加入了一个中间步骤。</p><p id="c3ae" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">对消息进行哈希处理后，以太坊包含一个字符串来标识该消息是为以太坊签名的。该字符串与消息散列连接在一起，并生成一个新的散列。</p><p id="65ec" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">最终的散列如下:<code class="eh lq lr ls lh b">keccak256("\x19Ethereum Signed Message:\n32" + hashMsg)</code>，其中hashMsg是原始消息的散列。字符串<code class="eh lq lr ls lh b">\x19Ethereum Signed Message:\n32</code>本身实际上是字符串<code class="eh lq lr ls lh b">\x19Ethereum Signed Message:\n</code>和消息大小(以字节为单位)的串联，消息大小是<code class="eh lq lr ls lh b">32</code>。</p><p id="d9bc" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们用Solidity写一个函数，从一个普通的文本中生成要签名的最终散列。</p><pre class="lc ld le lf fq lg lh li bn lj lk bi"><span id="e6c3" class="ll ka ht lh b be lm ln l lo lp">function getHashFinal(string memory _text) public pure returns (bytes32) {<br/><br/>  bytes32 hashMsg = keccak256(bytes(_text));<br/>    <br/>  bytes32 hashFinal = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hashMsg));<br/>    <br/>  return hashFinal;<br/><br/>}</span></pre><p id="e01f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这是必须签名的最终哈希。以太坊上的一个消息签名方案如下图所示。</p><figure class="lc ld le lf fq iu fe ff paragraph-image"><div class="fe ff ma"><img src="../Images/662e9f110a4255ebd83c5a77906d8516.png" data-original-src="https://miro.medium.com/v2/resize:fit:1342/format:webp/1*9z2o_S_9-JR7Hwhjm7yVtQ.png"/></div><figcaption class="lu lv fg fe ff lw lx bd b be z ek">The final hash includes a message indicating the Ethereum network.</figcaption></figure><h1 id="dd30" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">用元掩码签名消息</h1><p id="7b03" class="pw-post-body-paragraph jb jc ht jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy hm dt translated">为了测试消息签名，我们将使用元掩码。最快的方法是打开浏览器的控制台窗口，向MetaMask发送请求。</p><p id="18cb" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在任何打开的页面中，安装了MetaMask，在Windows中用快捷键<code class="eh lq lr ls lh b">Ctr+Shift+I</code>打开Chrome控制台，或者打开开发者工具(<code class="eh lq lr ls lh b">more tools -&gt; developer tools</code>)。要连接到元掩码，请运行以下脚本。</p><pre class="lc ld le lf fq lg lh li bn lj lk bi"><span id="ef9a" class="ll ka ht lh b be lm ln l lo lp">ethereum.request({"method":"eth_requestAccounts"})</span></pre><p id="4384" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">见下图。</p><figure class="lc ld le lf fq iu fe ff paragraph-image"><div class="fe ff mb"><img src="../Images/048c3ba21de57ddc63d9c9f3e8517275.png" data-original-src="https://miro.medium.com/v2/resize:fit:1114/format:webp/1*XfS4uc3bwBEqsIt-a8LQYQ.png"/></div><figcaption class="lu lv fg fe ff lw lx bd b be z ek">Connecting the page to MetaMask.</figcaption></figure><p id="dc12" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在让我们执行一个方法来签署消息。为此，我们必须指出要签名的消息的散列值(在与字符串" \x19Ethereum签名的消息:\n32"  } "连接之前，<strong class="jd hu">)。让我们在<code class="eh lq lr ls lh b">Hello World</code>字符串上签名。为了表明这是我们正在签名的消息，我将计算它的keccak256。如下图所示，哈希值为<br/> <code class="eh lq lr ls lh b">0x592fa743889fc7f92ac2a37bb1f5ba1daf2a5c84741ca0e0061d243a2e6707ba.</code></strong></p><figure class="lc ld le lf fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mc"><img src="../Images/10767acf78039c8f01f39b24976384e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qUGvgya2onXxMwn_5qg9qw.png"/></div></div><figcaption class="lu lv fg fe ff lw lx bd b be z ek">Keccak256 of the string Hello World.</figcaption></figure><p id="5c73" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在让我们签署这个消息。为了让你可以重现我的步骤，我将使用一个特定的私钥:<code class="eh lq lr ls lh b">0x9dee81d54c5a6189e671e6dec919e7409b02c8b8135b0394b9d25e33ac70d5bc.</code></p><p id="e6d1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">请仅使用此私钥来重现此示例。<strong class="jd hu">在任何情况下都不要将它用于其他目的。</strong>该私钥生成的地址为<code class="eh lq lr ls lh b">0x96bc35690880b790ae51973E9a973FeA98906C48.</code></p><p id="2211" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">为了给消息签名，我们使用了<code class="eh lq lr ls lh b">personal_sign</code>方法。它需要两个参数:将对消息进行签名的地址和要签名的消息的哈希。我将使用以下脚本:</p><pre class="lc ld le lf fq lg lh li bn lj lk bi"><span id="3fd9" class="ll ka ht lh b be lm ln l lo lp">ethereum.request({"method":"personal_sign", "params":<br/>["0x96bc35690880b790ae51973E9a973FeA98906C48", <br/>"0x592fa743889fc7f92ac2a37bb1f5ba1daf2a5c84741ca0e0061d243a2e6707ba"]})</span></pre><p id="d5d2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">第一个参数是上面指定的地址，hash是字符串<code class="eh lq lr ls lh b">Hello World</code>的hash。结果可以在下图中看到。</p><figure class="lc ld le lf fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff md"><img src="../Images/c75f22e3d04f1a1c84b9c9da265e602f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rOgpxud_FU9R-vMr0jCYlw.png"/></div></div><figcaption class="lu lv fg fe ff lw lx bd b be z ek">Signing a hash using MetaMask.</figcaption></figure><p id="8064" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">签名是:<br/> <code class="eh lq lr ls lh b">0x11decfe054b01923d5eb5c3210b8a9a1ae89f55fa2e5d9001aac6c4ef55475f82ea29eb1a92a385fc3c555185acbd8ee595f9f297cdb86adf2f896a3cbe0b6ea1c</code></p><h1 id="c0fb" class="jz ka ht bd kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw dt translated">ecrecover</h1><p id="344f" class="pw-post-body-paragraph jb jc ht jd b je kx jg jh ji ky jk jl jm kz jo jp jq la js jt ju lb jw jx jy hm dt translated">Solidity有一个函数可以让你检索给定消息的签名地址:<strong class="jd hu"> ecrecover </strong>。为了检索地址，我们需要最终的消息散列和消息签名。</p><p id="be23" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们已经计算了<code class="eh lq lr ls lh b">Hello World</code>消息的散列，现在让我们计算包括以太坊字符串在内的最终散列。我们可以使用在上一节中编写的getHashFinal函数来实现这一点。</p><p id="642e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">最终的消息哈希是<code class="eh lq lr ls lh b">0xdd7864675b904a6ab98e5092139baea95329b3130593ad10c3021e3368c8f5a6</code></p><p id="6944" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">签名由65个字节组成，必须分为3个部分:<em class="lz"> r </em>、<em class="lz"> s </em>和<em class="lz"> v </em>。<em class="lz"> r </em>的值是最左边的32个字节；<em class="lz"> s </em>的值是接下来的32个字节；<em class="lz"> v </em>的值是签名最右边的字节。</p><pre class="lc ld le lf fq lg lh li bn lj lk bi"><span id="81cb" class="ll ka ht lh b be lm ln l lo lp">r b94a6858265bb7a3bc9512bec90870d0013058125f9d556ce068c2230f576431<br/>s 43dfa576b68b8b7f62f3fdda227c772c23305b36085aaaf26daa55250ea0af07<br/>v 1c</span></pre><p id="fa0e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这些组件必须和消息的最终散列一起传递给<code class="eh lq lr ls lh b">ecrecover</code>函数。为了便于学习，让我们写一个函数，其中所有的值都是硬编码的。</p><pre class="lc ld le lf fq lg lh li bn lj lk bi"><span id="2b1e" class="ll ka ht lh b be lm ln l lo lp">function recover() external pure returns (address) {<br/><br/>    return ecrecover(<br/>    0xdd7864675b904a6ab98e5092139baea95329b3130593ad10c3021e3368c8f5a6, <br/>    0x1c,<br/>    0xb94a6858265bb7a3bc9512bec90870d0013058125f9d556ce068c2230f576431,<br/>    0x43dfa576b68b8b7f62f3fdda227c772c23305b36085aaaf26daa55250ea0af07);<br/>}</span></pre><p id="169c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">注意，<code class="eh lq lr ls lh b">ecrecover</code>函数有4个参数。最终的消息哈希，<em class="lz"> v </em>，<em class="lz"> r </em>，和<em class="lz"> s </em>。执行该功能的结果如下图所示。请注意，正如所料，该地址与签署消息的地址相同。</p><figure class="lc ld le lf fq iu fe ff paragraph-image"><div class="fe ff me"><img src="../Images/0b611503dc9cc32f85c18fa4dc90af86.png" data-original-src="https://miro.medium.com/v2/resize:fit:810/format:webp/1*kUHMlkpdge_bIO26yivlgg.png"/></div><figcaption class="lu lv fg fe ff lw lx bd b be z ek">Retrieving the address that signs the message.</figcaption></figure><p id="8d77" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们已经拥有了使用<code class="eh lq lr ls lh b">ecrecover</code>函数的所有要素。现在有趣的是创建一个接收消息、签名和地址的函数，如果该地址是签署消息的地址，则返回true或false。</p><p id="2791" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">具有讽刺意味的是，编写这个函数最困难的部分是将签名分解成<em class="lz"> r </em>、<em class="lz"> s </em>和<em class="lz"> v </em>组件，因为Solidity没有内置函数来完成这一任务。我们需要使用汇编。</p><p id="00e4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们写一个函数，它的唯一目的是拆分签名部分。</p><pre class="lc ld le lf fq lg lh li bn lj lk bi"><span id="32fc" class="ll ka ht lh b be lm ln l lo lp">function splitSignature(bytes memory sig) public pure returns (bytes32 r,bytes32 s,uint8 v) {<br/>        <br/>  require(sig.length == 65, "invalid signature length");<br/><br/>  assembly {<br/>    r := mload(add(sig, 32))<br/>    s := mload(add(sig, 64))<br/>    v := byte(0, mload(add(sig, 96)))<br/>  }<br/>}</span></pre><p id="c015" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在，让我们编写一个函数，它接收一条文本消息，并将其与一个签名和一个地址进行比较，以检查该地址是否是签署该消息的地址。</p><pre class="lc ld le lf fq lg lh li bn lj lk bi"><span id="77d9" class="ll ka ht lh b be lm ln l lo lp">function checkSignature(bytes memory sig, string memory text, address sender) public pure returns (bool) {<br/><br/>  bytes32 hashMsg = keccak256(bytes(text));<br/>  bytes32 hashFinal = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hashMsg));<br/><br/>  (bytes32 r, bytes32 s, uint8 v) = splitSignature(sig);<br/>  return (ecrecover(hashFinal, v, r, s) == sender);<br/><br/>}</span></pre><p id="b8a1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">一旦我们理解了所有的部分，注意检查某个地址是否签署了某个消息是相对简单的。只要正确地构造最终的散列，并将签名分成它的组成部分。<code class="eh lq lr ls lh b">ecrecover</code>函数完成了这项艰巨的工作。</p><p id="1600" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">感谢阅读！</strong></p><p id="abe9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎对本文提出意见和建议。</p><p id="aea3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎任何投稿。www.buymeacoffee.com/jpmorais<a class="ae mf" href="http://www.buymeacoffee.com/jpmorais" rel="noopener ugc nofollow" target="_blank">。</a></p><blockquote class="mg"><p id="72ba" class="mh mi ht bd mj mk ml mm mn mo mp jy ek translated">交易新手？试试<a class="ae mf" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a>或<a class="ae mf" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>