<html>
<head>
<title>CSC 101 -Constructor</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CSC 101-建造商</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/csc-101-constructor-451432c236a5?source=collection_archive---------37-----------------------#2022-08-27">https://medium.com/coinmonks/csc-101-constructor-451432c236a5?source=collection_archive---------37-----------------------#2022-08-27</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="eaa3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">构造函数是在契约中使用<strong class="is hu">构造函数</strong>关键字声明的可选函数。它包含更改和初始化状态变量的代码。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff jo"><img src="../Images/78db353f85d00a7149d8bc2b6bc3c9de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nYib8N6wIy-Papn96wyEKg.png"/></div></div></figure><h2 id="b3f8" class="ka kb ht bd kc kd ke kf kg kh ki kj kk jb kl km kn jf ko kp kq jj kr ks kt ku dt translated">构造器</h2><p id="a37e" class="pw-post-body-paragraph iq ir ht is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hm dt translated">使用不带任何函数名的<strong class="is hu">构造函数</strong>关键字来定义构造函数，后跟一个访问修饰符。这是一个可选函数，它初始化契约的状态变量。一旦契约被创建并开始在区块链中执行，t就会被自动调用。构造函数代码是创建代码的一部分，而不是运行时代码的一部分。</p><p id="cf21" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">语法:</strong></p><pre class="jp jq jr js fq la lb lc ld aw le dt"><span id="9ea9" class="ka kb ht lb b fv lf lg l lh li">constructor() &lt;Access Modifier&gt; {          <br/>}</span></pre><p id="a973" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">举例</strong>:</p><pre class="jp jq jr js fq la lb lc ld aw le dt"><span id="3dee" class="ka kb ht lb b fv lf lg l lh li">pragma solidity ^0.8.10;<br/><br/>contract MyContract{<br/>   constructor() public {}<br/>}</span></pre><p id="e533" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果基础契约有带参数的构造函数，每个派生契约都必须传递它们。</p><p id="08f1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">注意</strong>:一个合同只能有一个建造师。</p><ul class=""><li id="812d" class="lj lk ht is b it iu ix iy jb ll jf lm jj ln jn lo lp lq lr dt translated">构造函数声明是可选的</li><li id="c4bc" class="lj lk ht is b it ls ix lt jb lu jf lv jj lw jn lo lp lq lr dt translated">该协定只包含一个构造函数声明</li><li id="aede" class="lj lk ht is b it ls ix lt jb lu jf lv jj lw jn lo lp lq lr dt translated">不支持重载构造函数</li><li id="5dce" class="lj lk ht is b it ls ix lt jb lu jf lv jj lw jn lo lp lq lr dt translated">如果未定义构造函数，则使用默认构造函数。</li></ul><h2 id="9df1" class="ka kb ht bd kc kd ke kf kg kh ki kj kk jb kl km kn jf ko kp kq jj kr ks kt ku dt translated">继承中的构造函数</h2><p id="c337" class="pw-post-body-paragraph iq ir ht is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hm dt translated">有两种方法可以调用父协定的构造函数:</p><ol class=""><li id="bb30" class="lj lk ht is b it iu ix iy jb ll jf lm jj ln jn lx lp lq lr dt translated"><strong class="is hu">直接初始化:</strong>在下面的例子中，直接初始化方法用于初始化父类的构造函数。</li></ol><pre class="jp jq jr js fq la lb lc ld aw le dt"><span id="fd50" class="ka kb ht lb b fv lf lg l lh li">uint data;</span><span id="48c3" class="ka kb ht lb b fv ly lg l lh li">constructor(uint _data) public<!-- --> <!-- -->{</span><span id="3316" class="ka kb ht lb b fv ly lg l lh li">data = _data;</span><span id="f3c3" class="ka kb ht lb b fv ly lg l lh li">}</span></pre><p id="7321" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> 2。间接初始化:</strong>在下面的例子中，使用<em class="lz">Base(string(ABI . encodepacked(_info，_ info))的间接初始化是</em>完成<em class="lz">到</em>初始化基类的构造函数。</p><p id="3916" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">可以使用以下方式间接初始化基构造函数:</p><pre class="jp jq jr js fq la lb lc ld aw le dt"><span id="29fd" class="ka kb ht lb b fv lf lg l lh li">pragma solidity ^0.8.10;<br/><br/>contract Base {<br/>   uint data;<br/>   constructor(uint _data) public {<br/>      data = _data;   <br/>   }<br/>}<br/>contract Derived is Base {<br/>   constructor(uint _info) Base(_info * _info) public {}<br/>}</span></pre><p id="3b65" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">注意</strong>:不允许直接和间接初始化基础契约构造函数。</p><p id="c2c5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">构造函数在智能契约中非常有用，参数值可以在运行时定义，也可以限制方法调用。Solidity不支持构造函数重载，一次只允许一个构造函数。</p><p id="6294" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在下面的例子中，我们展示了构造函数的一个用例:</p><pre class="jp jq jr js fq la lb lc ld aw le dt"><span id="05ee" class="ka kb ht lb b fv lf lg l lh li">string str;</span><span id="b3d7" class="ka kb ht lb b fv ly lg l lh li">address private<!-- --> <!-- -->owner</span><span id="748e" class="ka kb ht lb b fv ly lg l lh li">= 0x.......;</span><span id="f371" class="ka kb ht lb b fv ly lg l lh li">constructor(string memory string) public<!-- --> <!-- -->{</span><span id="8553" class="ka kb ht lb b fv ly lg l lh li">if(msg.sender == owner){</span><span id="f590" class="ka kb ht lb b fv ly lg l lh li">str = string;</span><span id="790f" class="ka kb ht lb b fv ly lg l lh li">}}</span></pre><blockquote class="ma"><p id="84e5" class="mb mc ht bd md me mf mg mh mi mj jn ek translated">交易新手？试试<a class="ae mk" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或者<a class="ae mk" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>