<html>
<head>
<title>How to use ‘Super’ keyword in Solidity Contracts ?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在可靠性合同中使用“Super”关键字？</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/how-to-use-super-keyword-in-solidity-contracts-a729093f6976?source=collection_archive---------13-----------------------#2022-12-30">https://medium.com/coinmonks/how-to-use-super-keyword-in-solidity-contracts-a729093f6976?source=collection_archive---------13-----------------------#2022-12-30</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="c27b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在Solidity中，<code class="eh jo jp jq jr b">super</code>关键字可以在继承的契约中用来引用它所继承的契约。当您希望从继承协定中的函数内调用基础协定中的函数时，这很有用。</p><p id="677a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这里有一个例子:</p><pre class="js jt ju jv fq jw jr jx bn jy jz bi"><span id="4587" class="ka kb ht jr b be kc kd l ke kf">pragma solidity ^0.5.0;<br/><br/>// Original contract with the function that we want to call<br/>contract OriginalContract {<br/>    function sayHello() public pure returns (string memory) {<br/>        return "Hello from OriginalContract";<br/>    }<br/>}<br/><br/>// New contract that will override the sayHello function<br/>contract NewContract is OriginalContract {<br/>    // Override the sayHello function<br/>    function sayHello() public pure returns (string memory) {<br/>        // Call the sayHello function in the OriginalContract using the super keyword<br/>        string memory helloMessage = super.sayHello();<br/><br/>        // Return the message from the OriginalContract along with a message from the NewContract<br/>        return helloMessage + " and hello from NewContract";<br/>    }<br/>}</span></pre><p id="8623" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这个例子中，<code class="eh jo jp jq jr b">NewContract</code>合同中的<code class="eh jo jp jq jr b">sayHello</code>函数覆盖了<code class="eh jo jp jq jr b">OriginalContract</code>合同中的<code class="eh jo jp jq jr b">sayHello</code>函数。然而，<code class="eh jo jp jq jr b">NewContract</code>契约中的<code class="eh jo jp jq jr b">sayHello</code>函数也使用<code class="eh jo jp jq jr b">super</code>关键字调用<code class="eh jo jp jq jr b">OriginalContract</code>契约中的<code class="eh jo jp jq jr b">sayHello</code>函数。这使得<code class="eh jo jp jq jr b">NewContract</code>契约既可以覆盖<code class="eh jo jp jq jr b">sayHello</code>函数，也可以使用<code class="eh jo jp jq jr b">sayHello</code>函数的原始实现。</p><blockquote class="kg"><p id="d818" class="kh ki ht bd kj kk kl km kn ko kp jn ek translated">交易新手？在<a class="ae kq" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易</a>上尝试<a class="ae kq" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae kq" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">副本交易</a></p></blockquote><p id="b8c6" class="pw-post-body-paragraph iq ir ht is b it kr iv iw ix ks iz ja jb kt jd je jf ku jh ji jj kv jl jm jn hm dt translated">当在<code class="eh jo jp jq jr b">NewContract</code>契约的实例上调用<code class="eh jo jp jq jr b">sayHello</code>函数时，它将返回字符串“Hello from original contract and Hello from new contract”。这演示了如何使用<code class="eh jo jp jq jr b">super</code>关键字来调用基础契约中的函数，同时仍然允许在继承的契约中覆盖该函数。</p></div></div>    
</body>
</html>