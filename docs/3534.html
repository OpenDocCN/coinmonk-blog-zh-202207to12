<html>
<head>
<title>How to create an UUPS Proxy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何创建UUPS代理</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/how-to-create-an-uups-proxy-66eca257b2f9?source=collection_archive---------6-----------------------#2022-09-12">https://medium.com/coinmonks/how-to-create-an-uups-proxy-66eca257b2f9?source=collection_archive---------6-----------------------#2022-09-12</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><h1 id="5371" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">什么是UUPS代理？</h1><p id="2f81" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">UUPS代表通用可升级代理标准，最初记录在<a class="ae km" href="https://eips.ethereum.org/EIPS/eip-1822" rel="noopener ugc nofollow" target="_blank"> EIP1822 </a>中。在这个代理模式中，升级实现契约地址的责任在于实现契约本身。相反，在透明代理模式中，升级实现契约地址的责任是代理契约和代理管理契约的责任。关于透明代理模式的更详细的解释，请查看<a class="ae km" rel="noopener" href="/@HashHaran/essential-guide-to-smart-contract-upgradeability-a257dac36525">这篇</a>文章。</p><p id="7de1" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">当我们尝试升级使用UUPS代理模式部署的智能契约时，代理契约会调用实现契约。它检查升级的用户是否有权限升级实现，然后继续将实现合同地址更改为新的地址。</p><p id="db27" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">与透明代理模式相比，推荐使用UUPS代理模式，因为它消除了透明代理模式中所需的代理管理契约，从而节省了初始部署期间的开销。使用UUPS代理模式时，有一点需要注意。如果您使用非UUPS兼容的实现来升级您的代理，您将永远无法升级它。这样的错误可能是致命的，因为你已经失去了可升级性，这是我们修复这种错误的后门。</p><p id="36f9" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">让我们开始使用UUPS代理模式部署一个智能契约。</p><p id="a5d1" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">这个<a class="ae km" href="https://github.com/HashHaran/hardhat-upgrades" rel="noopener ugc nofollow" target="_blank"> Github仓库</a>有这篇文章的代码，可以随意保存以备将来使用。如果您不想从头开始进行设置，可以克隆它。</p><h1 id="3323" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">项目设置</h1><p id="49f0" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">我们将使用<a class="ae km" href="https://hardhat.org/" rel="noopener ugc nofollow" target="_blank">安全帽</a>用于我们的以太坊开发工作流程。在本演练中，我在windows机器上使用WSL2。如果使用不同的设置，您可以稍微调整这些步骤。我们开始吧！</p><p id="9e4f" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">运行以下命令创建一个目录，并将其初始化为节点项目。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="7245" class="lb ir ht kx b fv lc ld l le lf"><strong class="kx hu">mkdir hardhat-upgrades &amp;&amp; cd hardhat-upgradesnpm init -y</strong></span></pre><p id="bce6" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">在这个目录中安装hardhat。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="8fe6" class="lb ir ht kx b fv lc ld l le lf"><strong class="kx hu">npm i --save-dev hardhat</strong></span></pre><p id="55c8" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">在目录中初始化一个hardhat类型的脚本项目。运行下面的命令并选择“<em class="lg">创建一个TypeScript项目”</em>选项。对于其余的提示，请使用默认参数。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="fb2e" class="lb ir ht kx b fv lc ld l le lf"><strong class="kx hu">npx hardhat</strong></span></pre><p id="0d71" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">安装开放的zeppelin hardhat升级插件，我们将使用它来轻松部署我们的代理。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="39c2" class="lb ir ht kx b fv lc ld l le lf"><strong class="kx hu">npm i --save-dev @openzeppelin/hardhat-upgrades</strong></span></pre><p id="abd3" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">还要安装来自Open zeppelin的可升级合同，它是Open zeppelin合同的可升级对应物。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="7373" class="lb ir ht kx b fv lc ld l le lf"><strong class="kx hu">npm i --save-dev @openzeppelin/contracts-upgradeable</strong></span></pre><p id="7a54" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">将以下内容复制并粘贴到hardhat.config.ts文件中。这将做这个项目所需的基本安全帽设置。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="3ec1" class="lb ir ht kx b fv lc ld l le lf">import { HardhatUserConfig } from "hardhat/config";</span><span id="c03e" class="lb ir ht kx b fv lh ld l le lf">import "@nomicfoundation/hardhat-toolbox";</span><span id="079e" class="lb ir ht kx b fv lh ld l le lf">import "@openzeppelin/hardhat-upgrades";</span><span id="6653" class="lb ir ht kx b fv lh ld l le lf">import "@typechain/hardhat";</span><span id="205b" class="lb ir ht kx b fv lh ld l le lf">const config: HardhatUserConfig = {</span><span id="6403" class="lb ir ht kx b fv lh ld l le lf">solidity: {</span><span id="1640" class="lb ir ht kx b fv lh ld l le lf">version: "0.8.9",</span><span id="b1b7" class="lb ir ht kx b fv lh ld l le lf">settings: {</span><span id="ec7c" class="lb ir ht kx b fv lh ld l le lf">optimizer: {</span><span id="8438" class="lb ir ht kx b fv lh ld l le lf">enabled: true,</span><span id="9cdb" class="lb ir ht kx b fv lh ld l le lf">runs: 200,</span><span id="f277" class="lb ir ht kx b fv lh ld l le lf">},</span><span id="5c0f" class="lb ir ht kx b fv lh ld l le lf">},</span><span id="5475" class="lb ir ht kx b fv lh ld l le lf">},</span><span id="3518" class="lb ir ht kx b fv lh ld l le lf">defaultNetwork: "localhost",</span><span id="07d0" class="lb ir ht kx b fv lh ld l le lf">};</span><span id="b549" class="lb ir ht kx b fv lh ld l le lf">export default config;</span></pre><h1 id="2502" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">使用UUPS代理部署的实施合同</h1><p id="dc4f" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">在contracts文件夹中，为我们将要部署UUPS代理的实现契约创建一个文件夹。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="03f2" class="lb ir ht kx b fv lc ld l le lf"><strong class="kx hu">mkdir contracts/uups</strong></span></pre><p id="782e" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">在<em class="lg"> contracts </em>目录下创建一个名为<em class="lg"> VersionAware.sol </em>的文件，并将以下代码复制粘贴到其中。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="d96b" class="lb ir ht kx b fv lc ld l le lf"><em class="lg">// SPDX-License-Identifier: Unlicense</em></span><span id="0cbc" class="lb ir ht kx b fv lh ld l le lf">pragma solidity ^0.8.0;</span><span id="4438" class="lb ir ht kx b fv lh ld l le lf">abstract contract VersionAware {</span><span id="19fc" class="lb ir ht kx b fv lh ld l le lf">string public versionAwareContractName;</span><span id="0cb8" class="lb ir ht kx b fv lh ld l le lf">function getContractNameWithVersion()</span><span id="9b24" class="lb ir ht kx b fv lh ld l le lf">external</span><span id="6a97" class="lb ir ht kx b fv lh ld l le lf">pure</span><span id="2414" class="lb ir ht kx b fv lh ld l le lf">virtual</span><span id="b2a6" class="lb ir ht kx b fv lh ld l le lf">returns (string memory);</span><span id="fff6" class="lb ir ht kx b fv lh ld l le lf">}</span></pre><p id="4e0a" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">在这里，我们创建了实现契约的基本框架，以便在部署和升级之后，我们可以轻松地看到版本升级。</p><p id="dec7" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">在<em class="lg"> contracts/uups </em>目录下创建两个名为Uups <em class="lg"> ProxyPatternV1.sol </em>和Uups <em class="lg"> ProxyPatternV2.sol </em>的文件，并将下面的代码复制粘贴到其中。</p><p id="d62d" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated"><em class="lg"> UupsProxyPatternV1.sol </em></p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="0478" class="lb ir ht kx b fv lc ld l le lf"><em class="lg">// SPDX-License-Identifier: Unlicense<br/></em>pragma solidity ^0.8.0;</span><span id="9f79" class="lb ir ht kx b fv lh ld l le lf">import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";<br/>import {OwnableUpgradeable} from "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";<br/>import {VersionAware} from "../VersionAware.sol";</span><span id="ab32" class="lb ir ht kx b fv lh ld l le lf">contract UupsProxyPatternV1 is<br/>UUPSUpgradeable,<br/>OwnableUpgradeable,<br/>VersionAware{</span><span id="7fd1" class="lb ir ht kx b fv lh ld l le lf">constructor() {<br/>_disableInitializers();<br/>}</span><span id="7f69" class="lb ir ht kx b fv lh ld l le lf">function initialize() external initializer {<br/>versionAwareContractName = "UUPS Proxy Pattern: V1";<br/><em class="lg">///@dev as there is no constructor, we need to initialise the OwnableUpgradeable explicitly<br/></em>__Ownable_init();<br/>}</span><span id="97cf" class="lb ir ht kx b fv lh ld l le lf"><em class="lg">///@dev required by the OZ UUPS module<br/></em>function _authorizeUpgrade(address) internal override onlyOwner {}</span><span id="9379" class="lb ir ht kx b fv lh ld l le lf">function getContractNameWithVersion()<br/>public<br/>pure<br/>override<br/>returns (string memory){<br/>return "UUPS Proxy Pattern: V1";<br/>}<br/>}</span></pre><p id="3cf6" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated"><em class="lg"> UupsProxyPatternV2.sol </em></p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="e657" class="lb ir ht kx b fv lc ld l le lf"><em class="lg">// SPDX-License-Identifier: Unlicense<br/></em>pragma solidity ^0.8.0;</span><span id="86c4" class="lb ir ht kx b fv lh ld l le lf">import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";<br/>import {OwnableUpgradeable} from "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";<br/>import {VersionAware} from "../VersionAware.sol";</span><span id="4d11" class="lb ir ht kx b fv lh ld l le lf">contract UupsProxyPatternV2 is<br/>UUPSUpgradeable,<br/>OwnableUpgradeable,<br/>VersionAware{</span><span id="eb38" class="lb ir ht kx b fv lh ld l le lf">constructor() {<br/>_disableInitializers();<br/>}</span><span id="db0a" class="lb ir ht kx b fv lh ld l le lf">function initialize() external reinitializer(2) {<br/>versionAwareContractName = "UUPS Proxy Pattern: V2";<br/><em class="lg">///@dev as there is no constructor, we need to initialise the OwnableUpgradeable explicitly<br/></em>__Ownable_init();<br/>}</span><span id="6b34" class="lb ir ht kx b fv lh ld l le lf"><em class="lg">///@dev required by the OZ UUPS module<br/></em>function _authorizeUpgrade(address) internal override onlyOwner {}</span><span id="0cdd" class="lb ir ht kx b fv lh ld l le lf">function getContractNameWithVersion()<br/>public<br/>pure<br/>override<br/>returns (string memory){<br/>return "UUPS Proxy Pattern: V2";<br/>}<br/>}</span></pre><p id="5c2a" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">注意，在两个契约中，我们都继承了<em class="lg">uupsupgradable . sol</em>，这使得契约UUPS升级兼容。从该契约继承要求我们实现<em class="lg"> _authorizeUpgrade </em>函数，该函数用于决定是否允许调用者升级。</p><p id="7f28" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">在这里，我试图解释上述合同的一些高级细节。如果你在第一次阅读时理解有困难，考虑现在跳过它，以后再回来。典型的可升级协定不应该有构造函数，因为实现协定的构造函数永远不能在代理协定的上下文中运行。我们在这里添加了一个安全的构造函数，因为它没有设置任何存储变量。不初始化就退出协定会造成安全威胁。在构造函数中调用<em class="lg">_ disable initializer</em>方法使得实现契约不可初始化，这比让实现没有构造函数也不初始化要安全得多。注意，我在V1的<em class="lg">初始化</em>方法中使用了<em class="lg">初始化器</em>修饰符。这个修饰符确保这个initialize方法只被调用一次，就像solidity确保构造函数一样。还要注意，在V2中，<em class="lg">初始化</em>方法的修饰符是<em class="lg">重新初始化器(2)。</em>这里2代表实现契约的版本。必须使用<em class="lg">重新初始化器</em>修改器，而不是<em class="lg">初始化器</em>，因为代理契约已经在V1初始化过一次。关于所有可升级智能契约都应该继承的<em class="lg"> Initializer.sol </em>契约，还有更多事情和细节需要了解。我将在以后写更多关于它的详细文章。</p><p id="15aa" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">现在，运行以下命令来编译智能合约。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="5bce" class="lb ir ht kx b fv lc ld l le lf"><strong class="kx hu">npx hardhat compile</strong></span></pre><h1 id="d8a6" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">UUPS代理部署和升级</h1><p id="8ece" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">首先，我们将使用UUPS代理部署版本1，然后将其升级到版本2。我们将使用一个安全帽脚本来做到这一点。在scripts文件夹中创建一个名为<em class="lg"> uups.js </em>的脚本，并将下面的代码复制粘贴到其中。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="156b" class="lb ir ht kx b fv lc ld l le lf">const { ethers, upgrades } = require("hardhat");</span><span id="e9f3" class="lb ir ht kx b fv lh ld l le lf">async function main() {</span><span id="6110" class="lb ir ht kx b fv lh ld l le lf">const UupsProxyPatternV1 = await ethers.getContractFactory("UupsProxyPatternV1");</span><span id="d0f9" class="lb ir ht kx b fv lh ld l le lf">const uupsProxyPatternV1 = await upgrades.deployProxy(UupsProxyPatternV1, [], {kind: 'uups', unsafeAllow: ['constructor']});</span><span id="60c7" class="lb ir ht kx b fv lh ld l le lf">await uupsProxyPatternV1.deployed();</span><span id="4fbd" class="lb ir ht kx b fv lh ld l le lf">console.log(`UUPS Proxy Pattern V1 is deployed to proxy address: ${uupsProxyPatternV1.address}`);</span><span id="32d1" class="lb ir ht kx b fv lh ld l le lf">let versionAwareContractName = await uupsProxyPatternV1.getContractNameWithVersion();</span><span id="9618" class="lb ir ht kx b fv lh ld l le lf">console.log(`UUPS Pattern and Version: ${versionAwareContractName}`);</span><span id="b8b6" class="lb ir ht kx b fv lh ld l le lf">const UupsProxyPatternV2 = await ethers.getContractFactory("UupsProxyPatternV2");</span><span id="0eeb" class="lb ir ht kx b fv lh ld l le lf">const upgraded = await upgrades.upgradeProxy(uupsProxyPatternV1.address, UupsProxyPatternV2, {kind: 'uups', unsafeAllow: ['constructor'], call: 'initialize'});</span><span id="ac34" class="lb ir ht kx b fv lh ld l le lf">console.log(`UUPS Proxy Pattern V2 is upgraded in proxy address: ${upgraded.address}`);</span><span id="3587" class="lb ir ht kx b fv lh ld l le lf">versionAwareContractName = await upgraded.getContractNameWithVersion();</span><span id="5e75" class="lb ir ht kx b fv lh ld l le lf">console.log(`UUPS Pattern and Version: ${versionAwareContractName}`);</span><span id="0279" class="lb ir ht kx b fv lh ld l le lf">}</span><span id="c90d" class="lb ir ht kx b fv lh ld l le lf"><em class="lg">// We recommend this pattern to be able to use async/await everywhere and properly handle errors.</em></span><span id="4579" class="lb ir ht kx b fv lh ld l le lf">main().catch((error) =&gt; {<br/>console.error(error);<br/>process.exitCode = 1;<br/>});</span></pre><p id="3389" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">我们首先部署带有代理的智能合约的版本1。Open zeppelin升级<em class="lg"> deployProxy </em>方法为我们解决了这个问题。一旦用代理部署了版本1，我们就在代理上调用<em class="lg">getContractNameWithVersion</em>函数。该方法将根据我们在契约的版本1中使该方法返回的内容返回一个字符串。然后我们继续用<em class="lg">升级代理</em>方法升级这个合同。升级结束后，我们再次调用<em class="lg">getContractNameWithVersion</em>函数来查看返回的字符串的变化。让我们运行脚本，看看结果。使用以下命令运行脚本。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="14b0" class="lb ir ht kx b fv lc ld l le lf"><strong class="kx hu">npx hardhat run scripts/uups.js</strong></span></pre><p id="a004" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">您应该会在控制台上看到以下内容。</p><pre class="ks kt ku kv fq kw kx ky kz aw la dt"><span id="08eb" class="lb ir ht kx b fv lc ld l le lf">Warning: Potentially unsafe deployment of UupsProxyPatternV1</span><span id="51a6" class="lb ir ht kx b fv lh ld l le lf">You are using the `unsafeAllow.constructor` flag.</span><span id="8ea0" class="lb ir ht kx b fv lh ld l le lf">Warning: A proxy admin was previously deployed on this network</span><span id="c516" class="lb ir ht kx b fv lh ld l le lf">This is not natively used with the current kind of proxy ('uups').<br/>    Changes to the admin will have no effect on this new proxy.</span><span id="4cce" class="lb ir ht kx b fv lh ld l le lf">UUPS Proxy Pattern V1 is deployed to proxy address: 0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512<br/>UUPS Pattern and Version: UUPS Proxy Pattern: V1<br/>Warning: Potentially unsafe deployment of UupsProxyPatternV2</span><span id="0105" class="lb ir ht kx b fv lh ld l le lf">You are using the `unsafeAllow.constructor` flag.</span><span id="d866" class="lb ir ht kx b fv lh ld l le lf">UUPS Proxy Pattern V2 is upgraded in proxy address: 0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512<br/>UUPS Pattern and Version: UUPS Proxy Pattern: V2</span></pre><p id="11f3" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">耶！结果在意料之中。实施合同已成功升级到版本2。这就是您如何使用UUPS代理模式部署和升级未来版本的契约，无论您的智能契约有多复杂。</p><p id="9c64" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">感谢阅读。</p><h1 id="66ac" class="iq ir ht bd is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn dt translated">我是谁？</h1><p id="532d" class="pw-post-body-paragraph jo jp ht jq b jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl hm dt translated">我是一名全栈区块链开发者，对构建一个去中心化的、潜在的更具包容性的未来充满热情。有区块链发展的需求吗？</p><p id="8328" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated">取得联系:📧hariharan @ aluminum . iitm . AC . in</p><p id="b023" class="pw-post-body-paragraph jo jp ht jq b jr kn jt ju jv ko jx jy jz kp kb kc kd kq kf kg kh kr kj kk kl hm dt translated"><a class="ae km" href="https://github.com/HashHaran" rel="noopener ugc nofollow" target="_blank"> Github </a></p><blockquote class="li"><p id="8204" class="lj lk ht bd ll lm ln lo lp lq lr kl ek translated">交易新手？尝试<a class="ae km" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae km" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>