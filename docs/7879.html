<html>
<head>
<title>Capture The Ether (All challenges) part 2: Math</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">捕捉以太(所有挑战)第2部分:数学</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/capture-the-ether-deprecated-part-2-math-4513592a789c?source=collection_archive---------31-----------------------#2022-12-23">https://medium.com/coinmonks/capture-the-ether-deprecated-part-2-math-4513592a789c?source=collection_archive---------31-----------------------#2022-12-23</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><ol class=""><li id="af15" class="iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh dt translated">象征性销售</li><li id="21e2" class="iq ir ht is b it ji iv jj ix jk iz jl jb jm jd je jf jg jh dt translated">象征鲸</li><li id="3cfc" class="iq ir ht is b it ji iv jj ix jk iz jl jb jm jd je jf jg jh dt translated">退休基金</li></ol><h1 id="dd29" class="jn jo ht bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dt translated">要阅读第1部分<a class="ae kl" href="https://coinsbench.com/capture-the-ether-deprecated-part1-lotteries-234bba08e285" rel="noopener ugc nofollow" target="_blank">，请点击此处</a></h1><p id="8dbd" class="pw-post-body-paragraph km kn ht is b it ko kp kq iv kr ks kt ix ku kv kw iz kx ky kz jb la lb lc jd hm dt translated"><a class="ae kl" href="https://capturetheether.com/" rel="noopener ugc nofollow" target="_blank"> Capture The Ether </a>是一款基于Solidity和EVM的CTF (capture the flag)游戏，目标是破解多个智能合约并窃取资金。</p><blockquote class="ld"><p id="644c" class="le lf ht bd lg lh li lj lk ll lm jd ek translated">不知道什么时候买卖cryp，试试<a class="ae kl" href="http://coincodecap.com/go/bityard" rel="noopener ugc nofollow" target="_blank">复制交易</a>。</p></blockquote><p id="52f7" class="pw-post-body-paragraph km kn ht is b it ln kp kq iv lo ks kt ix lp kv kw iz lq ky kz jb lr lb lc jd hm dt translated">几个月前，我已经完成了这些挑战(并写下了这些挑战),遗憾是，这些挑战已经不可玩了(至少从它的网站上),因为它被部署在Ropsten上，一个废弃的以太坊测试网。<br/>但我认为与你们分享这些并展示我战胜了其中一些挑战还是很有趣的。通过阅读这篇文章，你可能会学到一些东西。最后一件事:自从这些文章写出来后，我没有做太多的修改。我在隐型僵尸教程结束后马上做了这些挑战。</p><p id="99c6" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">如果你正在寻找这种挑战，你也有<a class="ae kl" href="https://ethernaut.openzeppelin.com/" rel="noopener ugc nofollow" target="_blank">以太</a>或<a class="ae kl" href="https://www.damnvulnerabledefi.xyz/" rel="noopener ugc nofollow" target="_blank"> DamnVunerableDeFi </a>。</p><p id="f4f9" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated"><em class="lv">免责声明:这些挑战基于solidity 0.4.21，这是一个相当老的版本了。与最新版本(0.8.x)可能有一些不同，但大多数内容仍然适用。影响这些契约最大变化是加法、减法和乘法期间可能发生的上溢和下溢。从solidity 0.8.0开始，这些操作人员直接集成了安全措施。在0.8.0之前，人们使用@openzeppelin/SafeMath库来防止合同溢出/下溢</em></p><h1 id="aee4" class="jn jo ht bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dt translated">1.象征性销售</h1><p id="c0f2" class="pw-post-body-paragraph km kn ht is b it ko kp kq iv kr ks kt ix ku kv kw iz kx ky kz jb la lb lc jd hm dt translated">要破解的代码:</p><figure class="lw lx ly lz fq ma"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="04c8" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">这个契约模拟了一个非常简单DEX，用户可以用ETH购买令牌，或者用他的余额(balanceOf mapping)出售令牌</p><p id="54c1" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">这个挑战是“数学”部分的一部分，意味着解决方案与数字和计算有关。这给了我们一些提示。</p><p id="8e99" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">我首先想到的是“<a class="ae kl" href="https://www.notion.so/Token-Sale-93499619ce494c1d919ea0b5df17ee67" rel="noopener ugc nofollow" target="_blank">溢出/下溢</a>”</p><h2 id="0ece" class="md jo ht bd jp me mf mg jt mh mi mj jx ix mk ml kb iz mm mn kf jb mo mp kj mq dt translated">溢出和下溢</h2><p id="a512" class="pw-post-body-paragraph km kn ht is b it ko kp kq iv kr ks kt ix ku kv kw iz kx ky kz jb la lb lc jd hm dt translated">当我们试图将一个太大或太小的数字放入一个数据类型时，就会发生下溢和上溢。</p><p id="c67b" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">例如，试图将值260放入uint8(无符号整数8位)会产生溢出，因为uint在[0；255](一个单位<strong class="is hu"> N </strong>的最大值是<em class="lv"> 2^N -1 </em></p><p id="93e0" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">值-5也是一样，它会产生下溢。</p><p id="eaff" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">在solidity中，当发生上溢/下溢时，该数字只返回到该数据类型的第一个或最后一个数字</p><p id="8442" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">260进一个uint8然后会给255+5 = 4[<strong class="is hu">255</strong>(+1)&gt;&gt;<strong class="is hu">0</strong>(+1)&gt;&gt;<strong class="is hu">1</strong>(+1)&gt;&gt;<strong class="is hu">2</strong>(+1)&gt;&gt;<strong class="is hu">3</strong>(+1)&gt;&gt;<strong class="is hu">4</strong></p><p id="cb1a" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">而-5则会给出0–5 =[0(-1)&gt; &gt;<strong class="is hu">255</strong>(-1)&gt;&gt;<strong class="is hu">254</strong>(-1)&gt;&gt;<strong class="is hu">253</strong>(-1)&gt;&gt;<strong class="is hu">252</strong>(-1)&gt;&gt;<strong class="is hu">251</strong></p><p id="c4ef" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">我用加法和减法向您展示了这一点，但显然它也适用于乘法，因为结果数字可能会超出界限。</p><h2 id="dbd2" class="md jo ht bd jp me mf mg jt mh mi mj jx ix mk ml kb iz mm mn kf jb mo mp kj mq dt translated">回到合同上</h2><p id="dfbb" class="pw-post-body-paragraph km kn ht is b it ko kp kq iv kr ks kt ix ku kv kw iz kx ky kz jb la lb lc jd hm dt translated">那么，现在我们知道了，你能在代码中找到这种行为发生的地方<a class="ae kl" href="https://www.notion.so/Token-Sale-93499619ce494c1d919ea0b5df17ee67" rel="noopener ugc nofollow" target="_blank">吗？</a></p><p id="bb4b" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">在这个挑战部分，我想做的是写下可能发生这种情况的位置，让我们看看我们得到了什么:</p><figure class="lw lx ly lz fq ma"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="44bd" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">如您所见，有4行标记了注释:3个潜在溢出，1个下溢。</p><p id="79b3" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">现在我们不得不考虑谁应该对如此糟糕的局面负责</p><p id="1109" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">第一个:</p><p id="894f" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated"><code class="eh mr ms mt mu b">require(msg.value == numTokens * PRICE_PER_TOKEN); //overflow</code></p><p id="4eed" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">这里，我们检查【T1【uint 256】乘以<code class="eh mr ms mt mu b">PRICE_PER_TOKEN</code>【uint 256】是否等于用户发送的ETH值(这里是msg.value)</p><p id="6903" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">这里没有暂停，这是溢出发生的地方。但是怎么做呢？</p><p id="5420" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated"><code class="eh mr ms mt mu b">PRICE_PER_TOKEN</code>等于合同开头所示的1乙醚。所以，无论我们在<code class="eh mr ms mt mu b">numTokens</code>中放入什么值，都会得到一个uint256 * 1，所以不会溢出，对吗？..</p><p id="8167" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">不对。在EVM上，1以太等于10 ⁸或1e18微</p><p id="8f54" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">卫是乙醚的最小单位(<a class="ae kl" href="https://gwei.io/fr/" rel="noopener ugc nofollow" target="_blank">见此处解释</a>)</p><p id="10de" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">所以，实际上<code class="eh mr ms mt mu b">PRICE_PER_TOKEN</code>并不等于1，而是10^18.你知道会发生什么吗？..</p><figure class="lw lx ly lz fq ma fe ff paragraph-image"><div class="fe ff mv"><img src="../Images/d1af9aaa4586bab2101d435de5adef82.png" data-original-src="https://miro.medium.com/v2/resize:fit:432/format:webp/1*kBhtGVIJyYp4aMGcCvzkWA.png"/></div><figcaption class="my mz fg fe ff na nb bd b be z ek">prepare for some numbers</figcaption></figure><p id="6009" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">一个uint256的最大值是<em class="lv"> (2 ⁵⁶)-1 </em>，等于:</p><p id="fbff" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated"><code class="eh mr ms mt mu b">115792089237316195423570985008687907853269984665640564039457584007913129639934 </code>因此，如果我们将10个⁸乘以<code class="eh mr ms mt mu b">115792089237316195423570985008687907853269984665640564039457</code>(我去掉了最后18个数字)，我们得到:</p><p id="44f1" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated"><code class="eh mr ms mt mu b">115792089237316195423570985008687907853269984665640564039457000000000000000000</code>(简单加了18个‘零’)</p><p id="ca6c" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">这仍然小于2 ⁵⁶，所以没有溢出，事实上，我们离最大值还有<code class="eh mr ms mt mu b">584007913129639934</code>。</p><p id="11a2" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">但是如果我用10^18乘以<code class="eh mr ms mt mu b">11579208923731619542357098500868790785326998466564056403945**8**</code>(我加了1，最后一位数字变了)，现在我们比uint256大0.416 ETH(见下面的快速数学)</p><pre class="lw lx ly lz fq nc mu nd bn ne nf bi"><span id="4fe2" class="ng jo ht mu b be nh ni l nj nk">   11579208923731619542357098500868790785326998466564056403945**8000000000000000000**<br/>(-)11579208923731619542357098500868790785326998466564056403945**7584007913129639934** <br/>=  ___________________________________________________________ **415992086870360064**<br/>=  ___________________________________________________________ 0.416 ETH</span></pre><p id="d659" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">所以，给定as <code class="eh mr ms mt mu b">numTokens</code>这个值，我们只需将<code class="eh mr ms mt mu b">415992086870360064</code>魏送到契约中，如上所述大约是0.416 ETH。</p><p id="6566" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">好吧，酷，但“现在怎么办”你认为，对不对？</p><p id="ad0a" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">请看下一行:</p><p id="254d" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated"><code class="eh mr ms mt mu b">balanceOf[msg.sender] += numTokens;</code></p><p id="6d4f" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">合同会认为我们的余额中有<code class="eh mr ms mt mu b">1157920892373.....564039458000000000000000000</code>！</p><p id="9969" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">这意味着我们可以根据合同出售尽可能多的代币，只要它少于或等于我们的余额。</p><p id="448d" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">因为这个挑战的获胜条件是:</p><pre class="lw lx ly lz fq nc mu nd bn ne nf bi"><span id="a07e" class="ng jo ht mu b be nh ni l nl nk">function isComplete() public view returns (bool) {<br/>        return address(this).balance &lt; 1 ether;<br/>    }</span></pre><p id="eafa" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">通过发送0.416 ETH，我们能够检索1 ETH，对吗？</p><figure class="lw lx ly lz fq ma fe ff paragraph-image"><div class="fe ff nm"><img src="../Images/46a7416a1fe3d53119251d8b8c11f166.png" data-original-src="https://miro.medium.com/v2/resize:fit:516/format:webp/1*CrdEaHLXpQj3bwhWm3zmWw.png"/></div></figure><figure class="lw lx ly lz fq ma fe ff paragraph-image"><div role="button" tabindex="0" class="no np di nq bf nr"><div class="fe ff nn"><img src="../Images/a5b9c227e47975d6ada8e217f9e44d64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_PM9IKdkWUl9D_YEOUPRGg.png"/></div></div></figure><p id="7192" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">果然奏效了！我们有一笔余额。</p><p id="b83d" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">现在我们只需要调用值为1的sell函数来取1 ETH。</p><p id="a4ca" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">顺便说一句，在实际情况下，合同余额可能远远超过1.41 ETH，在这种情况下，我可以收回所有的钱…</p><p id="282b" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated"><strong class="is hu">吓人吧？</strong></p><h1 id="2229" class="jn jo ht bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dt translated">2.象征鲸</h1><p id="c1e3" class="pw-post-body-paragraph km kn ht is b it ko kp kq iv kr ks kt ix ku kv kw iz kx ky kz jb la lb lc jd hm dt translated">要破解的代码:</p><figure class="lw lx ly lz fq ma"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="5c54" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">该合同模拟ERC20合同，包括其总供应量、每个地址的余额以及将令牌从一个地址转移到另一个地址的功能。</p><p id="bfeb" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">我已经把溢出和下溢注释放在了易受攻击的行上。这项挑战的目标是在总供应量为1000枚且无法铸造新代币的情况下，拥有超过100万枚代币的余额。</p><p id="e067" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">有4个函数，其中3个是可公开访问的(可以通过外部契约或EOA调用)</p><p id="48a1" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">另一个是内部的，这意味着只有契约本身可以调用它，或者从这个继承的任何契约。</p><p id="17ec" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">让我们一个一个来看看这些函数。</p><figure class="lw lx ly lz fq ma"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="1c86" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated"><code class="eh mr ms mt mu b">_transfer</code>将目标账户和我们要转移的代币数量作为输入，并充分更新余额。</p><p id="31f3" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">发送者看到他的余额由于他转移的代币的数量而减少，接收者看到它增加了相同的价值。</p><p id="8c75" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">如我们所见，这里没有保护措施。但是由于这个函数是内部的，我们不能直接调用它。</p><p id="4375" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">我们仍会牢记在心。</p><p id="53c5" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated"><strong class="is hu">下一个功能:</strong></p><figure class="lw lx ly lz fq ma"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="b7b9" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">这是<code class="eh mr ms mt mu b">_transfer</code>的公共函数。我们在这里看到为什么有两个功能。在调用<code class="eh mr ms mt mu b">_transfer<br/></code>之前，用require语句做一些安全检查，我们在这里看到require语句中可能有溢出。但是，这并不意味着代码在这里是易受攻击的。</p><p id="7d0a" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated"><strong class="is hu">下一个功能:</strong></p><figure class="lw lx ly lz fq ma"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="736d" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">该功能允许发送者批准另一个用户(消费者)代表他消费代币。</p><p id="4f9f" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">这更新了一个名为<code class="eh mr ms mt mu b">allowance</code>的映射，每当一个花钱者想要花另一个用户的代币时，就会检查这个映射。</p><p id="cb5d" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">下一个功能:</p><figure class="lw lx ly lz fq ma"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="3211" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">这就是使用<code class="eh mr ms mt mu b">allowance</code>的地方。这个功能允许某人将代币从任何地址转移到另一个地址，但这只能在他被允许的情况下才能完成，而且只能是允许数量的代币。</p><p id="8fc7" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">我们可以看到再次调用了<code class="eh mr ms mt mu b">_transfer</code>函数。</p><p id="d05f" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">那么，我们能做什么呢，这里有很多溢出/下溢漏洞，对吗？</p><p id="9bcc" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">我们需要一种方法来使用它们！</p><p id="e2da" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">问题在于函数本身的逻辑。开发商出错了，你看得出来吗？</p><h2 id="730e" class="md jo ht bd jp me mf mg jt mh mi mj jx ix mk ml kb iz mm mn kf jb mo mp kj mq dt translated">解决挑战</h2><p id="046b" class="pw-post-body-paragraph km kn ht is b it ko kp kq iv kr ks kt ix ku kv kw iz kx ky kz jb la lb lc jd hm dt translated">漏洞存在于<code class="eh mr ms mt mu b">transferFrom</code>函数中。</p><p id="2a0b" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">让我们检查每一行:<br/> <code class="eh mr ms mt mu b">function transferFrom(address from, address to, uint256 value) public<br/></code>我们把<code class="eh mr ms mt mu b">value</code>从<code class="eh mr ms mt mu b">from</code>转移到<code class="eh mr ms mt mu b">to<br/></code>比如说<code class="eh mr ms mt mu b">from = msg.sender = A</code>，<code class="eh mr ms mt mu b">to = B</code>和<code class="eh mr ms mt mu b">value=1000<br/></code>这给了我们:</p><figure class="lw lx ly lz fq ma"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="5451" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">因此，要将令牌从A发送到B，我们首先检查balance[B]+value仍然优于balance[B]。这是一种溢出保护；)</p><p id="0228" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">然后，我们检查A是否允许A花费这些代币(价值)<br/>然后，我们从允许A花费的价值中减去价值<br/>然后，我们将代币从A转移到b。<br/>好了，这里没有问题了。</p><p id="5ca7" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">让我们再做一次，但是这次我们想把这些令牌从B发送到c。区块链上的任何人都可以拥有任意多个地址。</p><ol class=""><li id="a619" class="iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh dt translated">因此，对于B，我们允许A使用B的钱包，使用<code class="eh mr ms mt mu b">approve</code>函数花费99999999个代币。</li><li id="b515" class="iq ir ht is b it ji iv jj ix jk iz jl jb jm jd je jf jg jh dt translated">现在，我们用钱包A再次连接，从B转到C，C也会是我们的钱包。</li></ol><figure class="lw lx ly lz fq ma"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="0c78" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">你看到了吗？..我们将令牌从B发送到C，但在逻辑上，这是从B到A检查的容差！这一点也不正常。这就是我们的弱点。<br/>让我们看看现在调用<code class="eh mr ms mt mu b">_transfer</code>会发生什么:</p><figure class="lw lx ly lz fq ma"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="1f4d" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">现在，A的余额已经远远超过100万代币，挑战也就解决了。</p><p id="c1b1" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">这是我在Excel上做的一个可视化图，来帮助我虚弱的大脑找到解决方案，如果机制不清楚，这可能会帮助你理解它:</p><figure class="lw lx ly lz fq ma fe ff paragraph-image"><div role="button" tabindex="0" class="no np di nq bf nr"><div class="fe ff nn"><img src="../Images/c8c9e9c172724102cbe8361fc8e9f45e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BjDvFdpjPsIManm3hyMe4Q.png"/></div></div></figure><h1 id="3ab5" class="jn jo ht bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk dt translated">3.退休基金</h1><p id="d7ba" class="pw-post-body-paragraph km kn ht is b it ko kp kq iv kr ks kt ix ku kv kw iz kx ky kz jb la lb lc jd hm dt translated">承包黑客:</p><figure class="lw lx ly lz fq ma"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="81c1" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">这个挑战是基于一个保险库合同，用户可以锁定他的ETH 10年。如果他试图在10年期限之前收回这些股票，他只能得到锁定价值的9/10。</p><p id="0b01" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">如果他这样做了，那么他可以把这份合同称为HODL金库。</p><p id="2315" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">这里的挑战是窃取穷人锁定的全部平衡。</p><p id="0910" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">这里的主人是挑战，受益者是我自己。</p><p id="df15" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">除非所有者提取他的资金，否则我将无法收取罚款，因为提取的金额将等于0。</p><figure class="lw lx ly lz fq ma"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="3035" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">所以，这是阻止我们收集资金，撤回的价值，因为我们没有办法修改余额，唯一能这样做的是拥有<code class="eh mr ms mt mu b">withdraw()</code>功能的所有者。</p><p id="bd7c" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">如果契约有一个<code class="eh mr ms mt mu b">fallback()</code>或者<code class="eh mr ms mt mu b">receive()</code>函数，我本来可以<a class="ae kl" href="https://solidity-by-example.org/sending-ether/" rel="noopener ugc nofollow" target="_blank">发送以太</a>并改变它的平衡，然后改变<code class="eh mr ms mt mu b">withdrawn</code>变量的值，但是他的契约里没有这个函数。</p><p id="e036" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">真的吗？..</p><p id="df37" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">我能够很快解决这个挑战，因为我能够记得我在一篇文章中发现的一个漏洞。</p><p id="09ed" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">即使他没有实现这些功能，也可以发送以太合同。</p><p id="3d77" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">为此，我们将使用<code class="eh mr ms mt mu b">selfdestruct(address target)</code>函数，它简单地从调用该函数的契约中删除所有字节码，并将剩余的字节码发送给目标契约。</p><p id="3349" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">所以，我签订了一份合同来实践这一点:</p><figure class="lw lx ly lz fq ma"><div class="bz el l di"><div class="mb mc l"/></div></figure><p id="9dfc" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">然后，我用Remix部署这个契约，使用RetirementFundChallenge地址作为构造函数的输入。</p><p id="dd7c" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">然后:</p><ol class=""><li id="cf75" class="iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh dt translated">我用<code class="eh mr ms mt mu b">sendEtherToContract()</code>向我的攻击契约发送0.5 ETH</li><li id="7c14" class="iq ir ht is b it ji iv jj ix jk iz jl jb jm jd je jf jg jh dt translated">我调用了<code class="eh mr ms mt mu b">attack()</code>函数，它销毁了攻击契约，并将0.5 ETH发送给退休基金挑战契约</li><li id="907d" class="iq ir ht is b it ji iv jj ix jk iz jl jb jm jd je jf jg jh dt translated">现在，如果我调用<code class="eh mr ms mt mu b">collectPenalty()</code>函数，<code class="eh mr ms mt mu b">startBalance - address(this).balance</code>的结果将等于1，这意味着require语句是&gt; 0并被通过</li><li id="5dbe" class="iq ir ht is b it ji iv jj ix jk iz jl jb jm jd je jf jg jh dt translated">我从合同中收回所有资金！</li></ol><p id="73d0" class="pw-post-body-paragraph km kn ht is b it iu kp kq iv iw ks kt ix ls kv kw iz lt ky kz jb lu lb lc jd hm dt translated">感谢阅读！下次在另一篇安全相关的文章中再见；)</p><blockquote class="ld"><p id="5009" class="le lf ht bd lg lh li lj lk ll lm jd ek translated"><em class="ns">加入Coinmonks </em> <a class="ae kl" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank"> <em class="ns">电报频道</em> </a> <em class="ns">和</em> <a class="ae kl" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> <em class="ns"> Youtube频道</em> </a> <em class="ns">了解加密交易和投资</em></p></blockquote><h1 id="89e2" class="jn jo ht bd jp jq jr js jt ju jv jw jx jy nt ka kb kc nu ke kf kg nv ki kj kk dt translated">另外，阅读</h1><ul class=""><li id="e179" class="iq ir ht is b it ko iv kr ix nw iz nx jb ny jd nz jf jg jh dt translated"><a class="ae kl" rel="noopener" href="/coinmonks/3commas-review-an-excellent-crypto-trading-bot-2020-1313a58bec92">3商业评论</a> | <a class="ae kl" href="https://coincodecap.com/pionex-review-exchange-with-crypto-trading-bot" rel="noopener ugc nofollow" target="_blank"> Pionex评论</a> | <a class="ae kl" rel="noopener" href="/coinmonks/coinrule-review-2021-a-beginner-friendly-crypto-trading-bot-daf0504848ba"> Coinrule评论</a></li><li id="dcd8" class="iq ir ht is b it ji iv jj ix jk iz jl jb jm jd nz jf jg jh dt translated"><a class="ae kl" rel="noopener" href="/coinmonks/ledger-vs-ngrave-zero-7e40f0c1d694">莱杰vs n格拉夫</a> | <a class="ae kl" rel="noopener" href="/coinmonks/ledger-nano-s-vs-x-battery-hardware-price-storage-59a6663fe3b0">莱杰纳诺s vs x </a> | <a class="ae kl" rel="noopener" href="/coinmonks/binance-review-ee10d3bf3b6e">币安评论</a></li><li id="a1bf" class="iq ir ht is b it ji iv jj ix jk iz jl jb jm jd nz jf jg jh dt translated"><a class="ae kl" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a> | <a class="ae kl" href="https://coincodecap.com/bingbon-review" rel="noopener ugc nofollow" target="_blank"> Bingbon评论</a></li><li id="b42a" class="iq ir ht is b it ji iv jj ix jk iz jl jb jm jd nz jf jg jh dt translated"><a class="ae kl" rel="noopener" href="/coinmonks/bybit-exchange-review-dbd570019b71"> Bybit Exchange审查</a> | <a class="ae kl" href="https://coincodecap.com/bityard-reivew" rel="noopener ugc nofollow" target="_blank"> Bityard审查</a> | <a class="ae kl" href="https://coincodecap.com/jet-bot-review" rel="noopener ugc nofollow" target="_blank"> Jet-Bot审查</a></li><li id="c6b2" class="iq ir ht is b it ji iv jj ix jk iz jl jb jm jd nz jf jg jh dt translated"><a class="ae kl" rel="noopener" href="/coinmonks/3commas-vs-pionex-vs-cryptohopper-best-crypto-bot-6a98d2baa203">3 commas vs crypto hopper</a>|<a class="ae kl" rel="noopener" href="/coinmonks/earn-crypto-interest-b10b810fdda3">赚取加密利息</a></li></ul></div></div>    
</body>
</html>