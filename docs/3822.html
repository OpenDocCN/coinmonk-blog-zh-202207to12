<html>
<head>
<title>Learn Solidity lesson 32. Multiple inheritance.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习坚实度第32课。多重继承。</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/learn-solidity-lesson-32-multiple-inheritance-d616e20182b7?source=collection_archive---------6-----------------------#2022-09-18">https://medium.com/coinmonks/learn-solidity-lesson-32-multiple-inheritance-d616e20182b7?source=collection_archive---------6-----------------------#2022-09-18</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/166c93508664635e0903c0f47866f044.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*--dlx7hHVJ8RqpxTllyHXQ.jpeg"/></div></div></figure><p id="ba99" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在本文中，我们将更多地研究继承，尤其是当它涉及多个契约时。</p><p id="cbe7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">继承合同可以将其遗产传递给子合同。最简单的方法是将继承直接传递给一个子契约。让我们看看下面的代码。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="53b3" class="ki kj ht ke b fv kk kl l km kn">pragma solidity ^0.8.7;</span><span id="466d" class="ki kj ht ke b fv ko kl l km kn">contract Foo {<br/>   uint public number = 20;<br/>   }<br/>contract Baz is Foo {}<br/>contract Bar is Baz {}</span></pre><p id="c0f4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh kp kq kr ke b">Baz</code>合同继承了<code class="eh kp kq kr ke b">Foo</code>合同的<code class="eh kp kq kr ke b">number</code>状态变量，而<code class="eh kp kq kr ke b">Bar</code>合同也继承了状态变量。</p><p id="b44c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">一个契约可以从多个契约中继承变量和函数。让我们看看下面的代码，其中一个契约从另外两个契约中继承变量。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="db30" class="ki kj ht ke b fv kk kl l km kn">pragma solidity ^0.8.7;</span><span id="80c2" class="ki kj ht ke b fv ko kl l km kn">contract Foo {<br/>   uint public number = 20;<br/>}<br/>contract Baz {  <br/>   string public name = "John";<br/>}<br/>contract Bar is Baz, Foo {}</span></pre><p id="f65a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">合同<code class="eh kp kq kr ke b">Bar</code>继承了<code class="eh kp kq kr ke b">Baz</code>、<code class="eh kp kq kr ke b">Foo</code>两者，因此也将继承<code class="eh kp kq kr ke b">number</code>、<code class="eh kp kq kr ke b">name</code>状态变量。我们很快会看到更多关于这个案子的情况。</p><p id="d215" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">重要的是要记住，当我们没有定义变量的可见性时，它会自动声明为<em class="ks">内部</em>。为了防止变量被继承，必须将其声明为<em class="ks"> private </em>。</p><p id="cd8e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">多重继承应该小心处理，因为它可能会导致一些错误。让我们写一个契约，从另外两个契约中继承相同的功能。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="b104" class="ki kj ht ke b fv kk kl l km kn">pragma solidity ^0.8.7;</span><span id="c51a" class="ki kj ht ke b fv ko kl l km kn">contract A {<br/>   function hello() public virtual pure returns (string memory) {<br/>      return "Hi from A";<br/>   }<br/>}</span><span id="2242" class="ki kj ht ke b fv ko kl l km kn">contract B {<br/>   function hello() public virtual pure returns (string memory) {<br/>      return "Hi from B";<br/>   }<br/>}</span><span id="8ce3" class="ki kj ht ke b fv ko kl l km kn">contract C is A,B {}</span></pre><p id="63c7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">上述代码不会编译，因为<code class="eh kp kq kr ke b">C</code>合同继承了两个具有相同签名的函数。要编译<code class="eh kp kq kr ke b">C</code>合同，需要覆盖<code class="eh kp kq kr ke b">hello</code>功能。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="359e" class="ki kj ht ke b fv kk kl l km kn">function hello() public override(A,B) pure returns (string memory) {<br/>   return A.hello();<br/>}</span></pre><p id="e39b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">由于<code class="eh kp kq kr ke b">hello</code>功能在<code class="eh kp kq kr ke b">A</code>和<code class="eh kp kq kr ke b">B</code>中都存在，因此有必要在<code class="eh kp kq kr ke b">override(A,B)</code>中注明。在功能(或合同的任何功能)内，可以使用<code class="eh kp kq kr ke b">A.hello()</code>或<code class="eh kp kq kr ke b">B.hello()</code>语法调用<code class="eh kp kq kr ke b">A</code>或<code class="eh kp kq kr ke b">B</code>的功能<code class="eh kp kq kr ke b">hello</code>。</p><p id="1b3b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">虽然这种语法通常表示对另一个合同的外部调用，但事实并非如此。</p><h1 id="ba50" class="kt kj ht bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">钻石问题</h1><p id="8537" class="pw-post-body-paragraph jb jc ht jd b je lq jg jh ji lr jk jl jm ls jo jp jq lt js jt ju lu jw jx jy hm dt translated">多重继承会产生一些问题，比如所谓的钻石问题。在我们具体讨论钻石问题之前，我们来看另一个例子。假设我们想要一份遗产，如下图所示。</p><figure class="jz ka kb kc fq iu fe ff paragraph-image"><div class="fe ff lv"><img src="../Images/af649b1da565273c105c42be05cbe734.png" data-original-src="https://miro.medium.com/v2/resize:fit:242/format:webp/1*WWk93JQ5FkXTrwgIX1quzA.png"/></div><figcaption class="lw lx fg fe ff ly lz bd b be z ek">Linear inheritance between contracts.</figcaption></figure><p id="25fd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在上述情况下，合同<code class="eh kp kq kr ke b">B</code>继承自<code class="eh kp kq kr ke b">A</code>，而<code class="eh kp kq kr ke b">A</code>继承自<code class="eh kp kq kr ke b">X</code>。但是，有几种方法可以建立这种继承。最简单的是通过单一继承，如下所示。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="0976" class="ki kj ht ke b fv kk kl l km kn">contract X {}<br/>contract A is X {}<br/>contract B is A {}</span></pre><p id="972c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">但是，合同<code class="eh kp kq kr ke b">B</code>也有可能直接继承<code class="eh kp kq kr ke b">X</code>。这将产生与上述结构不同的行为。我们可以这样做。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="ece4" class="ki kj ht ke b fv kk kl l km kn">contract X {}<br/>contract A is X {}<br/>contract B is X,A {}</span></pre><p id="bf91" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">合同<code class="eh kp kq kr ke b">X</code>和<code class="eh kp kq kr ke b">A</code>被<code class="eh kp kq kr ke b">B</code>继承的顺序很重要。从右到左，我们应该写最直接相关的合同。由于<code class="eh kp kq kr ke b">B</code>直接从<code class="eh kp kq kr ke b">A</code>继承而来，契约A必须在声明的最右边。</p><p id="8ea3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">以下代码将不会编译:</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="c92e" class="ki kj ht ke b fv kk kl l km kn">contract X {}<br/>contract A is X {}<br/>contract B is A,X {}</span></pre><p id="5d5a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">对错误的解释很简单。在合同<code class="eh kp kq kr ke b">A</code>的声明中，合同<code class="eh kp kq kr ke b">A</code>优先于合同<code class="eh kp kq kr ke b">X</code>。通过写<code class="eh kp kq kr ke b">B is A, X</code>，我们在说契约<code class="eh kp kq kr ke b">X</code>必须覆盖契约<code class="eh kp kq kr ke b">A</code>，但是契约<code class="eh kp kq kr ke b">A</code>也覆盖契约<code class="eh kp kq kr ke b">X</code>，这是一个矛盾。</p><p id="6e4b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在让我们介绍一下钻石问题。想象下面的继承结构，如下图所示。</p><figure class="jz ka kb kc fq iu fe ff paragraph-image"><div class="fe ff ma"><img src="../Images/ccfde0822f1f11c3b81ea9ea2e9c3a66.png" data-original-src="https://miro.medium.com/v2/resize:fit:582/format:webp/1*RGKPDI8U-QkN_b5cYv4TcA.png"/></div><figcaption class="lw lx fg fe ff ly lz bd b be z ek">The diamond problem.</figcaption></figure><p id="e4db" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">合同<code class="eh kp kq kr ke b">A</code>和<code class="eh kp kq kr ke b">B</code>继承自<code class="eh kp kq kr ke b">X</code>,<code class="eh kp kq kr ke b">C</code>继承自<code class="eh kp kq kr ke b">A</code>和<code class="eh kp kq kr ke b">B</code>。有几种方法可以构建这个继承，我们将从一种无法编译的方法开始。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="eab0" class="ki kj ht ke b fv kk kl l km kn">contract X {}<br/>contract A is X {}<br/>contract B is X {}<br/>contract C is A,B,X {}</span></pre><p id="7867" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">出于与上述相同的原因，此类代码将无法工作。我们说合同<code class="eh kp kq kr ke b">X</code>继承自<code class="eh kp kq kr ke b">B</code>，但是<code class="eh kp kq kr ke b">B</code>也继承自<code class="eh kp kq kr ke b">X</code>。这是一个矛盾。</p><p id="7ab2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们可以用四种方式来声明合同。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="9c85" class="ki kj ht ke b fv kk kl l km kn">contract C is X,A,B {}<br/>contract C is X,B,A {}<br/>contract C is A,B {}<br/>contract C is B,A {}</span></pre><p id="178e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">最大的区别在于合同<code class="eh kp kq kr ke b">A</code>和<code class="eh kp kq kr ke b">B</code>的顺序。在上面的第一行和第三行中，<code class="eh kp kq kr ke b">B</code>继承了<code class="eh kp kq kr ke b">A</code>，而在第二行和第四行中，<code class="eh kp kq kr ke b">A</code>继承了<code class="eh kp kq kr ke b">B</code>。</p><p id="0468" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在钻石问题上，我们必须最大限度地关注合同的构造者。让我们看看下面的代码。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="c6d5" class="ki kj ht ke b fv kk kl l km kn">contract X {<br/>   string public letter;<br/>}<br/>contract A is X {<br/>   constructor() {<br/>      letter = "A";<br/>   }<br/>}<br/>contract B is X {<br/>   constructor() {<br/>      letter = "B";<br/>   }<br/>}<br/>contract C is A,B {}</span></pre><p id="9484" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">你能算出<code class="eh kp kq kr ke b">letter</code>变量的值是多少吗？由于合同<code class="eh kp kq kr ke b">C</code>继承自<code class="eh kp kq kr ke b">A</code>和<code class="eh kp kq kr ke b">B</code>，根据合同<code class="eh kp kq kr ke b">C</code>的申报继承顺序，可以是<code class="eh kp kq kr ke b">“A”</code>或<code class="eh kp kq kr ke b">“B”</code>。因为声明如下:<code class="eh kp kq kr ke b">contract C is A, B</code>，这意味着契约<code class="eh kp kq kr ke b">B</code>覆盖了<code class="eh kp kq kr ke b">A</code>，所以变量<code class="eh kp kq kr ke b">letter</code>将是<code class="eh kp kq kr ke b">“B”</code>。</p><h1 id="86f8" class="kt kj ht bd ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp dt translated">抽象合同</h1><p id="e363" class="pw-post-body-paragraph jb jc ht jd b je lq jg jh ji lr jk jl jm ls jo jp jq lt js jt ju lu jw jx jy hm dt translated">当一些函数没有实现时，或者当我们没有向它们的构造函数提供所有必要的参数时，契约必须被声明为抽象的。</p><p id="add1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">抽象契约比接口更灵活，因为一些函数可以实现，我们可以声明状态变量。让我们看一个抽象契约的例子。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="480c" class="ki kj ht ke b fv kk kl l km kn">contract Abstract {<br/>   function hello() public pure returns (string memory) {<br/>      return "Hello World!";<br/>   }<br/>   function bye() public pure virtual returns (string memory);<br/>}</span></pre><p id="0407" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">上面的契约有一个未实现的函数，即<code class="eh kp kq kr ke b">bye</code>函数。实际上，编译器会报告一个错误，如下图所示。</p><figure class="jz ka kb kc fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mb"><img src="../Images/ddb676a84946ca0fc5f7a3041231b657.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AfG-ygB-mtWn9mT33GjBBA.png"/></div></div><figcaption class="lw lx fg fe ff ly lz bd b be z ek">Contracts with unimplemented functions must be marked as abstract.</figcaption></figure><p id="2006" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">解决上述错误非常简单，只需使用<strong class="jd hu"> abstract </strong>关键字将契约标记为抽象，如下所示。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="a765" class="ki kj ht ke b fv kk kl l km kn">abstract contract Abstract {...}</span></pre><p id="0aa6" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">抽象协定不能被实例化。像接口一样，它们被构建为由其他契约继承。当尝试部署抽象契约时，Remix会显示一个错误，如下图所示。</p><figure class="jz ka kb kc fq iu fe ff paragraph-image"><div class="fe ff mc"><img src="../Images/0704808610e2324795395893e59d1ca0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*s8xir8xCilylubF18Zebrg.png"/></div><figcaption class="lw lx fg fe ff ly lz bd b be z ek">It is not possible to deploy (or instantiate) an abstract contract.</figcaption></figure><p id="9e35" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们写一个抽象契约的简单例子，它被用作另一个契约的基础。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="9874" class="ki kj ht ke b fv kk kl l km kn">//SPDX-License-Identifier: MIT<br/>pragma solidity ^0.8.7;</span><span id="7bc8" class="ki kj ht ke b fv ko kl l km kn">abstract contract ModelContract {<br/>   uint public number;<br/>   function setNumber(uint _number) public {<br/>      number = _number;<br/>   }<br/>   function toBeImplemented() public virtual;<br/>}</span><span id="351f" class="ki kj ht ke b fv ko kl l km kn">contract MyContract is ModelContract {<br/>   function toBeImplemented() public override  {}<br/>}</span></pre><p id="8705" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh kp kq kr ke b">ModelContract </code>契约是抽象的。它不能被实例化，但是我们使用它作为<code class="eh kp kq kr ke b">MyContract</code>契约的基础。在其中，我们声明了一个状态变量和一个函数<code class="eh kp kq kr ke b">setNumber</code>，两者都被实现了。还有一个未实现的功能，<code class="eh kp kq kr ke b">toBeImplemented</code>。由于是要实现的函数，所以必须声明为<em class="ks">虚拟</em>。</p><p id="d435" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">感谢阅读！</strong></p><p id="d981" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎对本文提出意见和建议。</p><p id="91cf" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎任何投稿。<a class="ae md" href="http://www.buymeacoffee.com/jpmorais" rel="noopener ugc nofollow" target="_blank">www.buymeacoffee.com/jpmorais</a>。</p><blockquote class="me"><p id="63b1" class="mf mg ht bd mh mi mj mk ml mm mn jy ek translated">交易新手？尝试<a class="ae md" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae md" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>