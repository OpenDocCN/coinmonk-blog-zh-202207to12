<html>
<head>
<title>CSC101-Modifier</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CSC 101-修改器</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/csc101-modifier-1fa2ea868256?source=collection_archive---------58-----------------------#2022-08-30">https://medium.com/coinmonks/csc101-modifier-1fa2ea868256?source=collection_archive---------58-----------------------#2022-08-30</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="baec" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">函数修饰符用于修改函数的行为。例如，向函数添加先决条件。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff jo"><img src="../Images/78db353f85d00a7149d8bc2b6bc3c9de.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nYib8N6wIy-Papn96wyEKg.png"/></div></div></figure><h2 id="5b73" class="ka kb ht bd kc kd ke kf kg kh ki kj kk jb kl km kn jf ko kp kq jj kr ks kt ku dt translated">修饰语</h2><p id="defb" class="pw-post-body-paragraph iq ir ht is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hm dt translated">修饰符是可以在函数调用之前和/或之后运行的代码。坚固性文件将修改量定义如下:</p><blockquote class="la lb lc"><p id="5490" class="iq ir ld is b it iu iv iw ix iy iz ja le jc jd je lf jg jh ji lg jk jl jm jn hm dt translated"><em class="ht">“函数修饰符是编译时源代码的上卷。</em></p><p id="5327" class="iq ir ld is b it iu iv iw ix iy iz ja le jc jd je lf jg jh ji lg jk jl jm jn hm dt translated">它可以用来以声明的方式修改函数的语义。”</p></blockquote><p id="7395" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">修饰符可用于:</p><ul class=""><li id="636a" class="lh li ht is b it iu ix iy jb lj jf lk jj ll jn lm ln lo lp dt translated">限制访问</li><li id="89da" class="lh li ht is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp dt translated">验证输入</li><li id="abac" class="lh li ht is b it lq ix lr jb ls jf lt jj lu jn lm ln lo lp dt translated">防范重入黑客攻击</li></ul><p id="5270" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">假设我们在区块链上部署了一个智能合约，每个人都可以与我们的智能合约进行交互，也可以访问我们的合约和功能。这样，每个人都可以调用所有的功能并签署交易。这是我们使用修饰语的地方。使用修饰符，我们可以在执行函数之前检查条件。</p><p id="5f3f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">语法:</strong></p><pre class="jp jq jr js fq lv lw lx ly aw lz dt"><span id="bffd" class="ka kb ht lw b fv ma mb l mc md">modifier Modifier_Name{<br/>    // modifier code goes here...<br/>}</span></pre><p id="89c6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">示例</strong>:</p><pre class="jp jq jr js fq lv lw lx ly aw lz dt"><span id="92e7" class="ka kb ht lw b fv ma mb l mc md">modifier onlyOwner {<br/>      require(msg.sender == owner);<br/>      _;<br/>   }</span></pre><p id="6815" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在上面的代码中，如果交易发送方是合同所有者，将执行该功能。</p><p id="37df" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们通过其他例子更深入地了解一下。</p><pre class="jp jq jr js fq lv lw lx ly aw lz dt"><span id="7593" class="ka kb ht lw b fv ma mb l mc md">pragma solidity ^0.8.10;<br/><br/>contract Bank {<br/>uint private _value;<br/>adresse private _owner;<br/><br/>  function Bank(uint amount){<br/><br/>  value = amount;<br/>  owner = msg.sender;<br/>  }<br/><br/>  modifier _ownerFunction {<br/> <br/>  require(owner == msg.sender);<br/>  _;<br/>  }<br/>}</span></pre><p id="648c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">假设我们有一个虚拟银行，在上面的例子中，只有合同所有者可以执行这个功能。现在我们用<strong class="is hu"> require </strong>指定需求。<strong class="is hu">所有者</strong>和创建者的消息必须相同。只有创建者的地址与发送者的地址进行比较。如果该语句<strong class="is hu">为真</strong>，则代码被处理。如果该语句为<strong class="is hu">假</strong>，则什么都不会发生。然后我们设置“_”，这样函数总是先执行。如果不是智能合约创建者的人想要更改某些内容，这将显示一个错误。现在我们只需要给每个函数添加<strong class="is hu"> ownerFunction </strong>，我们不希望除了创建者之外的任何人能够改变任何东西。</p><p id="8b27" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们回到以前的例子:</p><pre class="jp jq jr js fq lv lw lx ly aw lz dt"><span id="a2f9" class="ka kb ht lw b fv ma mb l mc md">modifier onlyOwner {<br/>      require(msg.sender == owner);<br/>      _;<br/>   }</span></pre><p id="17d1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在我们想知道修改器是如何工作的。</p><p id="4d2c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">符号<code class="eh me mf mg lw b">_;</code>被称为合并通配符。它将功能代码与放置<code class="eh me mf mg lw b">_;</code>的修改代码合并。写<code class="eh me mf mg lw b">_;</code>符号的地方将决定这个函数是必须在修改代码之前、之间还是之后执行。</p><h2 id="bd93" class="ka kb ht bd kc kd ke kf kg kh ki kj kk jb kl km kn jf ko kp kq jj kr ks kt ku dt translated">将参数传递给修饰符</h2><p id="ac94" class="pw-post-body-paragraph iq ir ht is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hm dt translated">修饰符也可以接受参数。像函数一样，你只需要在修饰符名前面的括号中传递变量type + name。</p><p id="1b28" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">语法</strong>:</p><p id="0595" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">你可以写一个带参数或不带参数的修饰语。如果修饰符没有自变量，可以省略括号<code class="eh me mf mg lw b">()</code>。</p><pre class="jp jq jr js fq lv lw lx ly aw lz dt"><span id="8885" class="ka kb ht lw b fv ma mb l mc md">modifier MyModifier(uint a) {<br/>    // ...<br/>}modifier MyModifier() {<br/>    // ...<br/>}</span></pre><p id="2433" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">示例</strong>:</p><pre class="jp jq jr js fq lv lw lx ly aw lz dt"><span id="2ab7" class="ka kb ht lw b fv ma mb l mc md">modifier Fee (uint _fee) {<br/>    if (msg.value &gt;= _fee) {<br/>        _;<br/>    }<br/>}</span></pre><blockquote class="mh"><p id="340c" class="mi mj ht bd mk ml mm mn mo mp mq jn ek translated">交易新手？试试<a class="ae mr" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或者<a class="ae mr" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>