<html>
<head>
<title>Learn Solidity lesson 5. Uint, types and visibility.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习第五课“坚实”。单位、类型和可见性。</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/learn-solidity-lesson-5-uint-types-and-visibility-fbebb221c311?source=collection_archive---------4-----------------------#2022-07-19">https://medium.com/coinmonks/learn-solidity-lesson-5-uint-types-and-visibility-fbebb221c311?source=collection_archive---------4-----------------------#2022-07-19</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/63481cf4331a1b0997d1d53cb6bd3d55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cxyzDQDxrk6kR0AmIosJDw.jpeg"/></div></div></figure><p id="d6f3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在上一课中，我们创建了一个只有一个状态变量的协定，类型为string。现在让我们创建一个新的契约，带有新的状态变量，类型为(无符号)整数。</p><p id="a457" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在Remix中，编写以下代码。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="c7bd" class="ki kj ht ke b fv kk kl l km kn">pragma solidity ^0.8.7;<br/>   contract Sum {<br/>      uint x;<br/>      uint public y;<br/>   }</span></pre><p id="dbe2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当保存文件时，将会编译合同，但是会有一个警告:同样，还没有定义许可。为什么会这样？每份合同在区块链上发布时都是公开的，因此其源代码可以被审计(也可能被复制)。因此，建议作者包含有关代码使用许可的信息。</p><p id="2fef" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们添加一个许可证。第一行包含以下句子:</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="176a" class="ki kj ht ke b fv kk kl l km kn">//SPDX-License-Identifier: MIT</span></pre><p id="aef2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这样做后，再次编译，警告将会消失。我们将许可证定义为<em class="ko"> MIT </em>，但是我们也可以使用<em class="ko">未定义的</em>，或者其他类型的公共或私有许可证。本课程将不研究许可证类型之间的差异。</p><h1 id="bed8" class="kp kj ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">能见度</h1><p id="4ccc" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">Solidity中的变量有三种可见性:<strong class="jd hu">公开</strong>、<strong class="jd hu">私有</strong>和<strong class="jd hu">内部</strong>。当没有显式声明可见性时，它被编译器认为是<em class="ko">内部的</em>。合同<em class="ko">总和</em>中的变量<em class="ko"> x </em>就是这种情况。</p><p id="3dfd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">正如我们已经看到的，public类型的变量使得编译器通过调用自动创建一个方法来检索它。对于私有或内部变量来说，这种情况不会发生，正如我们在下图中看到的，只有变量<em class="ko"> y </em>有一个关联的方法。</p><figure class="jz ka kb kc fq iu fe ff paragraph-image"><div class="fe ff lr"><img src="../Images/cb2564a1bedc34964d860d11a0ed4f43.png" data-original-src="https://miro.medium.com/v2/resize:fit:822/format:webp/1*_SlvNe6INlYoxE946-pcpw.png"/></div><figcaption class="ls lt fg fe ff lu lv bd b be z ek">The compiler creates getter<em class="lw"> </em>methods only for public variables.</figcaption></figure><p id="0b4e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><em class="ko">私有</em>和<em class="ko">内部</em>的区别稍微微妙一些，但是很重要。<em class="ko">内部</em>变量被子契约继承，而<em class="ko">私有</em>变量不被继承。</p><p id="459a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">契约之间的继承是一个更高级的话题，但是让我给你举个例子。在同一个合同文件<em class="ko"> Sum.sol </em>中，我们定义第二个合同，命名为<em class="ko"> Son </em>，如下。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="dab9" class="ki kj ht ke b fv kk kl l km kn">contract Son is Sum {<br/>    function setX(uint _x) public {<br/>        x = _x;<br/>    }</span><span id="095b" class="ki kj ht ke b fv lx kl l km kn">function getX() public view returns(uint) {<br/>        return x;<br/>    }<br/>}</span></pre><p id="60b8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">它有两个函数，<em class="ko"> setX </em>和<em class="ko"> getX </em>，第一个负责改变变量<em class="ko"> x </em>，第二个负责返回变量<em class="ko"> x </em>。但是，请注意，我们在任何时候都没有定义变量<em class="ko"> x </em>！由合同<em class="ko">总和</em>定义，其中合同<em class="ko">子</em>是子合同，通过语句'<em class="ko">合同子是总和'</em>。</p><p id="f82f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">将变量<em class="ko"> x </em>改为<em class="ko"> private </em>，编译器会抛出错误，如下图所示。子契约不继承私有变量。</p><figure class="jz ka kb kc fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff ly"><img src="../Images/a6e3a9ef02b9c1d87a40b35ae76ab469.png" data-original-src="https://miro.medium.com/v2/resize:fit:1304/format:webp/1*D0qauMnARKvz1svrhwhrYA.png"/></div></div><figcaption class="ls lt fg fe ff lu lv bd b be z ek">Private variables are not inherited by the child contract.</figcaption></figure><h1 id="4464" class="kp kj ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">恒定不变</h1><p id="90bb" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">状态变量可以声明为<strong class="jd hu">常量</strong>和<strong class="jd hu">不可变</strong>。两者在初始化后都不能更改。</p><p id="a689" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">常量变量必须在声明时初始化，而不可变变量可以在契约的<strong class="jd hu">构造函数</strong>中初始化。构造函数是一个只在部署时运行的函数。</p><p id="90cf" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们为我们的契约添加一个新变量，<em class="ko"> z </em>，它将是<em class="ko">常量</em>。在状态变量中，包含以下代码行。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="18e7" class="ki kj ht ke b fv kk kl l km kn">uint private constant z = 10;</span></pre><p id="fa62" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">一旦声明，变量<em class="ko"> z </em>就不能再更改。从技术上讲，我们甚至不能说<em class="ko"> z </em>是一个状态变量，因为区块链并没有在数据库中为它保留一个专用空间。它的值被直接写入字节码。</p><p id="cf16" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">禁止在没有初始化的情况下声明常量变量，编译器会指出错误，如下图所示。</p><figure class="jz ka kb kc fq iu fe ff paragraph-image"><div class="fe ff lz"><img src="../Images/663a5c53908b32009b0cceec3de0d762.png" data-original-src="https://miro.medium.com/v2/resize:fit:1072/format:webp/1*wiZe8Yl36czk5jWj0XA1gA.png"/></div><figcaption class="ls lt fg fe ff lu lv bd b be z ek">Constant variables must be initialized at declaration.</figcaption></figure><p id="920f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">不可变变量可以不用初始化就声明，但是必须在构造函数中初始化。我们开始吧。我们首先声明一个新的变量，<em class="ko"> w </em>，它是<em class="ko">不可变的</em>。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="e647" class="ki kj ht ke b fv kk kl l km kn">uint private immutable w;</span></pre><p id="a878" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">之后，我们使用函数<em class="ko">构造函数</em>为契约声明一个构造函数，如下所示。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="4394" class="ki kj ht ke b fv kk kl l km kn">constructor() {<br/>   w = 20;<br/>}</span></pre><p id="9f65" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">到目前为止，合同没有编译器错误或警告，可以在下图中看到。</p><figure class="jz ka kb kc fq iu fe ff paragraph-image"><div class="fe ff ma"><img src="../Images/806c9e323d649f4a52414e3adb9e466b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1154/format:webp/1*gdY2zoXrwZdutM-yBb1ShQ.png"/></div><figcaption class="ls lt fg fe ff lu lv bd b be z ek">Constant and immutable variables cannot be changed after initialization.</figcaption></figure><h1 id="5d6b" class="kp kj ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">整数和无符号整数</h1><p id="63e6" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">在Solidity中，有必要在声明变量时指出变量的类型。在契约<em class="ko"> Sum </em>中，我们使用类型<strong class="jd hu"> uint </strong>，是<strong class="jd hu">无符号整数</strong>的简称，代表正整数。为了表示正整数和负整数，还有类型<strong class="jd hu"> int </strong>。</p><p id="f8d4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">实性有几种类型来表示整数和无符号整数。对于整数，有以下几种:<strong class="jd hu"> int8 </strong>，<strong class="jd hu"> int16 </strong>，<strong class="jd hu"> int24 </strong> …直至<strong class="jd hu"> int256 </strong>，与<strong class="jd hu"> int </strong>相同。对于无符号整数，我们有:<strong class="jd hu"> uint8 </strong>，<strong class="jd hu"> uint16 </strong>，<strong class="jd hu"> uint24 </strong> …直到<strong class="jd hu"> uint256 </strong>，与<strong class="jd hu"> uint </strong>相同。请注意，计数每8次发生一次，这是以位为单位的变量的大小。</p><p id="134e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">例如，类型<em class="ko"> uint8 </em>有8位，即1个字节。这意味着它接受0到255之间的数字。类型<em class="ko"> uint256 </em>，32字节，接受0和2⁵⁶-1之间的数字。如果我们试图给一个变量赋一个越界值，编译器会抛出一个错误。</p><p id="0453" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">例如，如果我们试图将值256赋给类型为<em class="ko"> uint8 </em>的变量，编译器会指出一个错误，如下图所示。</p><figure class="jz ka kb kc fq iu fe ff paragraph-image"><div class="fe ff mb"><img src="../Images/feefe98c9c7ffde76a27210b9daf75ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:824/format:webp/1*m-1Kfv2zIjbku6xEz-U3OQ.png"/></div><figcaption class="ls lt fg fe ff lu lv bd b be z ek">Variable of type uint8 accepts numbers between 0 and 255.</figcaption></figure><p id="04b2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">除了字符串和整数，Solidity还有其他类型。我们可以将这些类型分为两类:<strong class="jd hu">值类型</strong>和<strong class="jd hu">引用类型</strong>。值类型是其变量直接存储其值的类型，而引用类型存储对赋值所在位置的引用。</p><p id="cab2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">整数和无符号整数是值类型的变量。字符串是引用类型的变量。这就是当函数参数是字符串时使用<em class="ko">内存</em>关键字的原因。这个主题将在另一课中进一步解释。</p><p id="8dfb" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们在契约中包含一个改变变量<em class="ko"> y </em>值的函数。在合同中包含以下代码:</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="64f9" class="ki kj ht ke b fv kk kl l km kn">function setY(uint _y) public {<br/>   y = _y;<br/>}</span></pre><p id="24e7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">注意，没有必要指出函数的参数<em class="ko"> _y </em>在内存中(或其他地方)，因为它是通过值传递给函数的，而不是通过引用。</p><blockquote class="mc md me"><p id="9e5d" class="jb jc ko jd b je jf jg jh ji jj jk jl mf jn jo jp mg jr js jt mh jv jw jx jy hm dt translated">交易新手？尝试<a class="ae mi" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae mi" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote><p id="5fe4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">合同到目前为止，没有编译器错误或警告，可以在下图中看到。在下一课中，我们将继续学习。</p><figure class="jz ka kb kc fq iu fe ff paragraph-image"><div class="fe ff mj"><img src="../Images/915c700efb53399d54a80794a8fe2bca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1124/format:webp/1*q2STv2pQsPv7BHBpB0nuEA.png"/></div><figcaption class="ls lt fg fe ff lu lv bd b be z ek">The contract <em class="lw">Sum</em>, so far.</figcaption></figure><p id="c5fd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">感谢阅读！</strong></p></div></div>    
</body>
</html>