<html>
<head>
<title>Comparing Parity’s ink! with Solidity: EVM VS Substrate programming</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">比较平价的墨迹！坚实:EVM与衬底编程</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/comparing-paritys-ink-with-solidity-evm-vs-substrate-programming-14379a79d7fc?source=collection_archive---------1-----------------------#2022-11-20">https://medium.com/coinmonks/comparing-paritys-ink-with-solidity-evm-vs-substrate-programming-14379a79d7fc?source=collection_archive---------1-----------------------#2022-11-20</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="bcf6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这个系列中，我将对比EVM链和基于基底的链，以澄清与这个主题相关的潜在误解和误会。</p><p id="679c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">本文的核心焦点是这两个链的技术(编程)方面，但是我将阐明与它们相关的其他一些基本概念。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff jo"><img src="../Images/887bf93d8eea655d287fe07879842d56.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VkfpUi8sndtQq4SeDmzkkA.png"/></div></div><figcaption class="ka kb fg fe ff kc kd bd b be z ek">Substrate VS EVM</figcaption></figure><p id="37a3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">由<a class="ae ke" href="https://www.parity.io/" rel="noopener ugc nofollow" target="_blank"> Parity technologies </a>开发的Substrate是一个开源框架，它提供了一种可用于构建定制区块链的“SDK”。</p><blockquote class="kf kg kh"><p id="5976" class="iq ir ki is b it iu iv iw ix iy iz ja kj jc jd je kk jg jh ji kl jk jl jm jn hm dt translated">好玩的事实:Polkadot是使用底层框架在核心开发的最突出的区块链；被称为“Polkadot运行时环境”。</p></blockquote><p id="2869" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在底层开发智能合约的核心语言是Rust。</p><p id="5757" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">使用底物开发的一些著名链是Polkadot、Aleph Zero、围裙实验室、Aventus等。</p><p id="f594" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">另一方面，最初由Vitalik Buterin创建的<strong class="is hu">以太坊虚拟机</strong>或EVM是一个程序(或软件),它运行智能合同，并在每次有新块添加到链中时计算以太坊网络的状态。EVM位于以太坊的硬件和节点网络层。</p><p id="a635" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">EVM的智能合约是使用Solidity开发的。兼容或能够运行EVM的一些区块链有币安智能链(BSC)、Polygon、Avalanche等</p><p id="acd9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">首先，我将以列表的形式概述两种链类型之间的核心区别。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff km"><img src="../Images/44dea63d031fbe67c2892b18deb6793c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ot9ot_1B8VeYk35p1VVqAQ.png"/></div></div><figcaption class="ka kb fg fe ff kc kd bd b be z ek">Comparing Substrate framework to EVM</figcaption></figure><p id="7949" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在我看来，基质框架是奇偶技术的一个惊人创新，是现代、理想和未来区块链网络的关键。</p><p id="6c50" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">发现了这两种基础架构之间的核心差异后，我将开始比较<a class="ae ke" href="https://paritytech.github.io/ink/" rel="noopener ugc nofollow" target="_blank">墨水！</a>(锈)和<a class="ae ke" href="https://docs.soliditylang.org/" rel="noopener ugc nofollow" target="_blank">坚实度</a>。</p><blockquote class="kf kg kh"><p id="5914" class="iq ir ki is b it iu iv iw ix iy iz ja kj jc jd je kk jg jh ji kl jk jl jm jn hm dt translated">请注意，基板和EVM不是区块链。</p></blockquote><h1 id="a98c" class="kn ko ht bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">固态</h1><p id="215b" class="pw-post-body-paragraph iq ir ht is b it ll iv iw ix lm iz ja jb ln jd je jf lo jh ji jj lp jl jm jn hm dt translated">Solidity是一种面向对象的高级语言，用于开发智能合约。被设计成一种<a class="ae ke" href="https://en.wikipedia.org/wiki/List_of_programming_languages_by_type#Curly-bracket_languages" rel="noopener ugc nofollow" target="_blank">花括号</a>语言类型，它的目标是以太坊虚拟机(EVM)。它的语法和设计模式受到C++、Python和JavaScript的影响。</p><p id="4108" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">典型的Solidity smart合同看起来是这样的(来自<a class="ae ke" href="https://docs.soliditylang.org/en/v0.8.17/solidity-by-example.html" rel="noopener ugc nofollow" target="_blank"> Solidity文档</a>):</p><pre class="jp jq jr js fq lq lr ls lt aw lu dt"><span id="c183" class="lv ko ht lr b fv lw lx l ly lz">// SPDX-License-Identifier: GPL-3.0<br/>pragma solidity ^0.8.4;<br/>contract SimpleAuction {<br/>    // Parameters of the auction. Times are either<br/>    // absolute unix timestamps (seconds since 1970-01-01)<br/>    // or time periods in seconds.<br/>    address payable public beneficiary;<br/>    uint public auctionEndTime;<br/><br/>    // Current state of the auction.<br/>    address public highestBidder;<br/>    uint public highestBid;<br/><br/>    // Allowed withdrawals of previous bids<br/>    mapping(address =&gt; uint) pendingReturns;<br/><br/>    // Set to true at the end, disallows any change.<br/>    // By default initialized to `false`.<br/>    bool ended;<br/><br/>    // Events that will be emitted on changes.<br/>    event HighestBidIncreased(address bidder, uint amount);<br/>    event AuctionEnded(address winner, uint amount);<br/><br/>    // Errors that describe failures.<br/><br/>    // The triple-slash comments are so-called natspec<br/>    // comments. They will be shown when the user<br/>    // is asked to confirm a transaction or<br/>    // when an error is displayed.<br/><br/>    /// The auction has already ended.<br/>    error AuctionAlreadyEnded();<br/>    /// There is already a higher or equal bid.<br/>    error BidNotHighEnough(uint highestBid);<br/>    /// The auction has not ended yet.<br/>    error AuctionNotYetEnded();<br/>    /// The function auctionEnd has already been called.<br/>    error AuctionEndAlreadyCalled();<br/><br/>    /// Create a simple auction with `biddingTime`<br/>    /// seconds bidding time on behalf of the<br/>    /// beneficiary address `beneficiaryAddress`.<br/>    constructor(<br/>        uint biddingTime,<br/>        address payable beneficiaryAddress<br/>    ) {<br/>        beneficiary = beneficiaryAddress;<br/>        auctionEndTime = block.timestamp + biddingTime;<br/>    }<br/><br/>    /// Bid on the auction with the value sent<br/>    /// together with this transaction.<br/>    /// The value will only be refunded if the<br/>    /// auction is not won.<br/>    function bid() external payable {<br/>        // No arguments are necessary, all<br/>        // information is already part of<br/>        // the transaction. The keyword payable<br/>        // is required for the function to<br/>        // be able to receive Ether.<br/><br/>        // Revert the call if the bidding<br/>        // period is over.<br/>        if (block.timestamp &gt; auctionEndTime)<br/>            revert AuctionAlreadyEnded();<br/><br/>        // If the bid is not higher, send the<br/>        // money back (the revert statement<br/>        // will revert all changes in this<br/>        // function execution including<br/>        // it having received the money).<br/>        if (msg.value &lt;= highestBid)<br/>            revert BidNotHighEnough(highestBid);<br/><br/>        if (highestBid != 0) {<br/>            // Sending back the money by simply using<br/>            // highestBidder.send(highestBid) is a security risk<br/>            // because it could execute an untrusted contract.<br/>            // It is always safer to let the recipients<br/>            // withdraw their money themselves.<br/>            pendingReturns[highestBidder] += highestBid;<br/>        }<br/>        highestBidder = msg.sender;<br/>        highestBid = msg.value;<br/>        emit HighestBidIncreased(msg.sender, msg.value);<br/>    }<br/><br/>    /// Withdraw a bid that was overbid.<br/>    function withdraw() external returns (bool) {<br/>        uint amount = pendingReturns[msg.sender];<br/>        if (amount &gt; 0) {<br/>            // It is important to set this to zero because the recipient<br/>            // can call this function again as part of the receiving call<br/>            // before `send` returns.<br/>            pendingReturns[msg.sender] = 0;<br/><br/>            // msg.sender is not of type `address payable` and must be<br/>            // explicitly converted using `payable(msg.sender)` in order<br/>            // use the member function `send()`.<br/>            if (!payable(msg.sender).send(amount)) {<br/>                // No need to call throw here, just reset the amount owing<br/>                pendingReturns[msg.sender] = amount;<br/>                return false;<br/>            }<br/>        }<br/>        return true;<br/>    }<br/><br/>    /// End the auction and send the highest bid<br/>    /// to the beneficiary.<br/>    function auctionEnd() external {<br/>        // It is a good guideline to structure functions that interact<br/>        // with other contracts (i.e. they call functions or send Ether)<br/>        // into three phases:<br/>        // 1. checking conditions<br/>        // 2. performing actions (potentially changing conditions)<br/>        // 3. interacting with other contracts<br/>        // If these phases are mixed up, the other contract could call<br/>        // back into the current contract and modify the state or cause<br/>        // effects (ether payout) to be performed multiple times.<br/>        // If functions called internally include interaction with external<br/>        // contracts, they also have to be considered interaction with<br/>        // external contracts.<br/><br/>        // 1. Conditions<br/>        if (block.timestamp &lt; auctionEndTime)<br/>            revert AuctionNotYetEnded();<br/>        if (ended)<br/>            revert AuctionEndAlreadyCalled();<br/><br/>        // 2. Effects<br/>        ended = true;<br/>        emit AuctionEnded(highestBidder, highestBid);<br/><br/>        // 3. Interaction<br/>        beneficiary.transfer(highestBid);<br/>    }<br/>}</span></pre><h1 id="fb78" class="kn ko ht bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">墨水！</h1><p id="8c29" class="pw-post-body-paragraph iq ir ht is b it ll iv iw ix lm iz ja jb ln jd je jf lo jh ji jj lp jl jm jn hm dt translated">墨水！是一种嵌入式领域特定语言(<a class="ae ke" href="https://wiki.haskell.org/Embedded_domain_specific_language" rel="noopener ugc nofollow" target="_blank"> eDSL </a>)，由奇偶技术公司开发，用于为区块链编写基于<a class="ae ke" href="https://github.com/paritytech/substrate" rel="noopener ugc nofollow" target="_blank">底层</a>框架的Rust智能合同。墨水！契约被编译到WebAssembly中，并可以部署到任何基于底层的链中。</p><p id="2565" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">来自<a class="ae ke" href="https://paritytech.github.io/ink/#hello-world--the-flipper" rel="noopener ugc nofollow" target="_blank">油墨的智能合同示例！文档</a>如下图所示:</p><pre class="jp jq jr js fq lq lr ls lt aw lu dt"><span id="a89b" class="lv ko ht lr b fv lw lx l ly lz">#[ink::contract]<br/>mod flipper {<br/>    /// The storage of the flipper contract.<br/>    #[ink(storage)]<br/>    pub struct Flipper {<br/>        /// The single `bool` value.<br/>        value: bool,<br/>    }<br/><br/>    impl Flipper {<br/>        /// Instantiates a new Flipper contract and initializes<br/>        /// `value` to `init_value`.<br/>        #[ink(constructor)]<br/>        pub fn new(init_value: bool) -&gt; Self {<br/>            Self {<br/>                value: init_value,<br/>            }<br/>        }<br/><br/>        /// Flips `value` from `true` to `false` or vice versa.<br/>        #[ink(message)]<br/>        pub fn flip(&amp;mut self) {<br/>            self.value = !self.value;<br/>        }<br/><br/>        /// Returns the current state of `value`.<br/>        #[ink(message)]<br/>        pub fn get(&amp;self) -&gt; bool {<br/>            self.value<br/>        }<br/>    }<br/><br/>    /// Simply execute `cargo test` in order to test your contract<br/>    /// using the below unit tests.<br/>    #[cfg(test)]<br/>    mod tests {<br/>        use super::*;<br/>        <br/>        #[ink::test]<br/>        fn it_works() {<br/>            let mut flipper = Flipper::new(false);<br/>            assert_eq!(flipper.get(), false);<br/>            flipper.flip();<br/>            assert_eq!(flipper.get(), true);<br/>        }<br/>    }<br/>}</span></pre><p id="028a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">已经看到了两种编程语言之间的语法差异，也应该知道行为和执行方面的差异。</p><h1 id="17ff" class="kn ko ht bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">对比墨迹！和坚固性</h1><ul class=""><li id="3ed0" class="ma mb ht is b it ll ix lm jb mc jf md jj me jn mf mg mh mi dt translated">墨水！能够在任何WASM (WebAssembly)虚拟机上运行，而Solidity是专门为EVM兼容网络设计的。</li><li id="fd56" class="ma mb ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi dt translated">用墨水写的程序！在WebAssembly中编码，而在Solidity中编码为EVM字节码。</li><li id="1a94" class="ma mb ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi dt translated">可以用墨水写多个构造函数！，而只有简单的构造函数必须用Solidity编写。</li><li id="5ee8" class="ma mb ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi dt translated">墨水！默认情况下，智能合约具有溢出保护，而Solidity在其核心并不考虑溢出(人们必须手动考虑会导致溢出的情况)。</li><li id="08e5" class="ma mb ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi dt translated">墨水！程序可以用支持Rust的工具编写，而Solidity有一个定制的工具包。</li><li id="dd77" class="ma mb ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi dt translated">这两种编程语言都设计有语义版本。</li><li id="c699" class="ma mb ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi dt translated">两种编程语言都有元数据；即应用二进制接口(ABI)。</li><li id="396c" class="ma mb ht is b it mj ix mk jb ml jf mm jj mn jn mf mg mh mi dt translated">墨水的存储大小是动态的(可变的)!，而Solidity定义了256位的存储。</li></ul><blockquote class="kf kg kh"><p id="cd92" class="iq ir ki is b it iu iv iw ix iy iz ja kj jc jd je kk jg jh ji kl jk jl jm jn hm dt translated">Rust是一种理想的智能合同语言；从我这里拿走这个。</p></blockquote><p id="f0ac" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">平价科技公司开发了一个革命性的框架，值得称赞！</p><p id="14a6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">查看下面运行在Substrate上的一些最大的网络(这不是一个完整的列表):</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff mo"><img src="../Images/4e090c9b98d3fe77f73d8b655f74616e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fgKIQ22S6Km5tdxzC_ZSKA.png"/></div></div><figcaption class="ka kb fg fe ff kc kd bd b be z ek">Image credits: <a class="ae ke" href="https://substrate.io/ecosystem/projects/" rel="noopener ugc nofollow" target="_blank">https://substrate.io/ecosystem/projects/</a></figcaption></figure><p id="2de0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我坚信您已经看到了这两种编程语言之间的差异，并且您愿意开始使用ink进行开发！今天(Solidity也很酷，但是墨迹！，由于Rust拥有的力量，与Solidity相比，是你下一个区块链项目的更好选择)。</p><p id="3961" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在其他条件相同的情况下，我希望你喜欢阅读这篇文章。</p><p id="c1df" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">请在Twitter上查看我，并关注我💚</p><p id="4dbf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">谢谢你一直读到这篇文章，法国人！</p><blockquote class="mp"><p id="8ef3" class="mq mr ht bd ms mt mu mv mw mx my jn ek translated">交易新手？尝试<a class="ae ke" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae ke" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>