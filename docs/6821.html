<html>
<head>
<title>Smart Contracts Vulnerabilities</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">智能合同漏洞</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/smart-contracts-vulnerabilities-abbd6185252a?source=collection_archive---------3-----------------------#2022-11-28">https://medium.com/coinmonks/smart-contracts-vulnerabilities-abbd6185252a?source=collection_archive---------3-----------------------#2022-11-28</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="0ffd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">正如我们在之前的文章<a class="ae jo" rel="noopener" href="/coinmonks/ethereum-smart-contracts-1d92dd8e7f83">中介绍的以太坊智能合约</a>以及以太坊区块链的一些基本概念。现在是我们提出安全问题的时候了，因为智能合约处理和转移大量资产，所以除了正确执行之外，在实现后仍然受到保护以防攻击也是至关重要的，不要忘记它不可改变的本质。</p><p id="ac3e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">在本文</strong>中，我将讲述智能合约中的一系列漏洞。然后，<strong class="is hu">在接下来的几篇文章</strong>中，我将尝试浏览近年来一些著名的攻击，这些攻击利用这些漏洞，允许黑客窃取金钱或造成其他损害，我们将看到如何使用两种攻击检测方法来预防和保护。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/93760033474416a6f80699006615c86c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wbqImpTvZ9QuazmyisikFg.png"/></div></div></figure><h1 id="ff43" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">文章的大纲</h1><blockquote class="kz la lb"><p id="e920" class="iq ir lc is b it iu iv iw ix iy iz ja ld jc jd je le jg jh ji lf jk jl jm jn hm dt translated"><strong class="is hu"> <em class="ht"> 1。区块链级别</em> </strong></p><p id="3534" class="iq ir lc is b it iu iv iw ix iy iz ja ld jc jd je le jg jh ji lf jk jl jm jn hm dt translated"><strong class="is hu"> <em class="ht"> 2。EVM等级</em> </strong></p><p id="3788" class="iq ir lc is b it iu iv iw ix iy iz ja ld jc jd je le jg jh ji lf jk jl jm jn hm dt translated"><strong class="is hu"> <em class="ht"> 3。坚固程度</em>和</strong></p></blockquote></div><div class="ab cl lg lh hb li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hm hn ho hp hq"><p id="c7d8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">以太坊智能合约中存在多个漏洞，可能导致严重的安全问题，并且可能发生在不同的级别区块链级别、以太坊虚拟机(EVM)级别或可靠性级别。</p><pre class="jq jr js jt fq ln lo lp lq aw lr dt"><span id="f7d4" class="ls kc ht lo b fv lt lu l lv lw"><strong class="lo hu">Blockchain level<br/>    </strong>Bad Randomness<br/>    Timestamp Dependence<br/>    Solidity incorrect blockhash<br/>    Transaction-order Dependence<br/>    Unencrypted private data On-chain</span><span id="3515" class="ls kc ht lo b fv lx lu l lv lw"><strong class="lo hu">EVM level<br/>    </strong>Short address attack<br/>    Immutable bugs<br/>    Stack size limit</span><span id="e9e1" class="ls kc ht lo b fv lx lu l lv lw"><strong class="lo hu">Solidity level<br/>    Call control<br/>           </strong>- Reentrancy<br/>           - Message call with hardcoded gas amount<br/>           - <strong class="lo hu">Call to the Unknown<br/>                - </strong>Delegatecall to Untrusted Callee<br/>                - Solidity call without data<br/>                - Solidity Unchecked external call</span><span id="339f" class="ls kc ht lo b fv lx lu l lv lw"><strong class="lo hu">    Access control<br/>          - Protection Issues<br/>                - </strong>Unprotected selfdestruct<br/>                - Unprotected Ether Withdrawal, Leaking Ether to arbitrary address<br/>                - Unexpected Ether<br/>                - Authorization through tx.origin<br/>                - Missing protection against Sig Replay Attack<br/>                - Lack of Proper Signature Verification<br/>                - Insufficient signature information (Signature Malleability) <br/>                - Hash collisions with MVLA<br/>          <strong class="lo hu">-</strong> <strong class="lo hu">Visibility Issues<br/>                - </strong>Functions Default Visibility<br/>                - State Variable Default Visibility</span><span id="acd4" class="ls kc ht lo b fv lx lu l lv lw"><strong class="lo hu">    Data control<br/>          - Arithmetic Issues<br/>                - </strong>Integer overflow/underflow<br/>                - Array overflow<br/>          - Ether lost (Frozen Ether, locked money)</span><span id="ce91" class="ls kc ht lo b fv lx lu l lv lw"><strong class="lo hu">    Resource control<br/>          - DoS<br/>                - </strong>DoS with Failed Call<br/>                - DoS With Block Gas Limit<br/>          - Code With No effects<br/>          - Presence of unused variables<br/>          - Insufficient Gas Greifing</span><span id="c423" class="ls kc ht lo b fv lx lu l lv lw"><strong class="lo hu">    Solidity Programming Issues<br/>          - Tool control<br/>                 - </strong>Outdated compiler version<br/>                 - Floating or No Pragma<br/>                 - Uninitialized Storage Pointer<br/>                 - Use of Deprecated functions constructions<br/>                 - Erroneous constructor name<br/>          - Variable Shadowing<br/>          - Write to Arbitrary Storage Location<br/>          - Incorrect Inheritance Order<br/>          - Typographical Errors<br/>          - Forcing Ether to</span><span id="25a0" class="ls kc ht lo b fv lx lu l lv lw"><strong class="lo hu">Exception Handling<br/>          - </strong>Assert Violation<br/>          - Requirement Violation</span></pre><p id="8e36" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">嗯，我已经尽力画出来了，这样你可以看得更清楚。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/59fa486fba6789db230d52038fad4dff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hwBi-SjNVskLE5LTfExmjQ.png"/></div></div><figcaption class="ly lz fg fe ff ma mb bd b be z ek">Smart contracts Vulnerabilities</figcaption></figure><p id="55cc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们来看看其中的一些漏洞，更准确地说，这些漏洞是最著名的。</p><h1 id="a51d" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">1.区块链层面</h1><h2 id="8768" class="ls kc ht bd kd mc md me kh mf mg mh kl jb mi mj kp jf mk ml kt jj mm mn kx mo dt translated"><strong class="ak"> 1。1交易订单依赖性</strong></h2><p id="3599" class="pw-post-body-paragraph iq ir ht is b it mp iv iw ix mq iz ja jb mr jd je jf ms jh ji jj mt jl jm jn hm dt translated">每个块包含一组交易，而区块链的状态会更新几次，智能合约的状态由其字段的值和当前余额决定。此外，当用户通过事务调用智能合约时，智能合约的实际状态对于任何用户来说都是不可预测的。因此，<strong class="is hu">无法保证</strong>事务在初始化时会处于与契约相同的状态。</p><p id="e5f3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果一个块包含两个同时调用同一个契约的事务，那么用户将无法知道在他们的单个事务被执行/将要被执行时契约处于哪个状态。</p><p id="6d71" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如上图所示，如果用户1和用户2分别在同一时间<strong class="is hu"> t </strong>向智能合约t发送交易<strong class="is hu"> Ti </strong>和<strong class="is hu"> Tj </strong>，两个用户都不知道第一个交易执行时合约处于什么状态。此外，这些事务的顺序仅由th块的矿工决定。即使用户1在用户2发送<strong class="is hu"> Tj </strong>之前发送事务<strong class="is hu"> Ti </strong>。绝对不能保证<strong class="is hu"> Ti </strong>会在<strong class="is hu"> Tj </strong>之前执行。如果先执行Ti，合同的状态将从状态<strong class="is hu"> S </strong>变为状态<strong class="is hu">Si</strong>；但是，如果先执行<strong class="is hu"> Tj </strong>，合同的状态将从状态<strong class="is hu"> S </strong>变为状态<strong class="is hu"> Sj </strong>。因此，合同的最终状态取决于事务的执行顺序，而事务的执行顺序是由块挖掘的顺序决定的。</p><p id="3dbd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">利用这一漏洞在现实世界中至关重要，在现实世界中，买方和卖方使用智能合同进行金融交易。这是因为卖家经常更新他们出售的物品的价格，而买家在发送交易时会将他们观察到的价格发送到他们的购买请求中。因此，在利用交易订单依赖性的攻击的情况下，买家可能不得不花费比预期多得多的钱。</p><p id="3070" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然而，这个问题可以通过使用交易计数器来“锁定”商定的初始价格来避免。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mu"><img src="../Images/c84fa32a2266b051cff00cb0085b1bd4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ghhMgecgbgADoEaSgkeaww.png"/></div></div><figcaption class="ly lz fg fe ff ma mb bd b be z ek"><strong class="bd mv">Transaction-order Dependence</strong></figcaption></figure><h2 id="2b72" class="ls kc ht bd kd mc md me kh mf mg mh kl jb mi mj kp jf mk ml kt jj mm mn kx mo dt translated">1.2 <strong class="ak">时间戳相关性</strong></h2><p id="a063" class="pw-post-body-paragraph iq ir ht is b it mp iv iw ix mq iz ja jb mr jd je jf ms jh ji jj mt jl jm jn hm dt translated">要在以太坊区块链上执行任何操作，如以太转移，智能合约会接收一个时间戳，指定该区块生成的时间。该时间戳由矿工根据他们本地系统的时间设置。因此，他们可以很容易地操纵和修改它。</p><p id="3c0a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当智能协定使用块时间戳作为执行关键操作的触发条件的一部分或作为随机生成器的来源时，会出现此漏洞。恶意的挖掘者可以将提供的时间戳调整几秒钟，从而改变联系人的输出以对自己有利。</p><p id="f405" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">时间戳依赖性是由于以太坊只要求时间戳必须大于其前一个块的时间戳，并且在当前时钟未来的900秒内。因此，如果合同使用基于时间戳的条件来确定是否转移资金，恶意矿工可以稍微改变时间戳以满足条件，从而有利于攻击者。为了避免这种漏洞，作者建议使用块索引，因为它是增量的，可以防止被操纵。</p><h1 id="e1bb" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">2.以太坊虚拟机(EVM)级别</h1><h2 id="28c1" class="ls kc ht bd kd mc md me kh mf mg mh kl jb mi mj kp jf mk ml kt jj mm mn kx mo dt translated"><strong class="ak"> 2.1不可变的bug</strong></h2><p id="fff0" class="pw-post-body-paragraph iq ir ht is b it mp iv iw ix mq iz ja jb mr jd je jf ms jh ji jj mt jl jm jn hm dt translated">智能合约的一个特点是它们是不可变的。部署到区块链后，不能修改或删除它们。这也意味着他们的行为将是用户所期望的，因为这是由共识协议保证的。然而，如果合同包含一个错误，就没有办法修复它，因此，教育程序员和开发人员设计更安全的合同并提供在实现过程中修改或终止(或者更准确地说是销毁)它们的方法是很重要的。</p><h2 id="407b" class="ls kc ht bd kd mc md me kh mf mg mh kl jb mi mj kp jf mk ml kt jj mm mn kx mo dt translated">2.2 <strong class="ak">堆栈大小限制</strong></h2><p id="993c" class="pw-post-body-paragraph iq ir ht is b it mp iv iw ix mq iz ja jb mr jd je jf ms jh ji jj mt jl jm jn hm dt translated">每当一个协定调用另一个协定或其自身时，与该事务相关联的调用堆栈就增加一帧。由于调用堆栈被限制在<strong class="is hu"> 1024 </strong>帧，超过这个限制的新调用将导致异常。以太坊区块链的辛勤工作解决了这一漏洞，并产生了一个“分叉”,重新定义了呼叫气体消耗的计算方式。因此，一个调用者最多可以分配<strong class="is hu"> 64 </strong>中的<strong class="is hu"> 63 </strong>个单元:由于目前每个块的gas限制是<strong class="is hu"> 4.7M </strong>个单元，这意味着调用栈的最大可达深度总是小于<strong class="is hu"> 1024 </strong>。</p><h1 id="f39e" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">3.坚固程度</h1><h2 id="8f4a" class="ls kc ht bd kd mc md me kh mf mg mh kl jb mi mj kp jf mk ml kt jj mm mn kx mo dt translated"><strong class="ak"> 3.1重入</strong></h2><p id="960c" class="pw-post-body-paragraph iq ir ht is b it mp iv iw ix mq iz ja jb mr jd je jf ms jh ji jj mt jl jm jn hm dt translated">重入是在2016年攻击DAO期间首次观察到的。当在初始执行完成之前允许外部协定调用对调用协定进行新的调用时，就会发生这种情况。</p><p id="eedb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当契约在发送资金之前没有更新其状态时，攻击者可以递归调用目标的资金提取函数。因此，这允许攻击者绕过有效性检查，直到调用方的契约耗尽所有乙醚或事务耗尽汽油。</p><p id="1e9c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">此漏洞是由于回退函数的结构允许攻击者在将控制流转移到另一个协定时重复调用调用者的函数，这也是因为缺少gas限制。</p><p id="f855" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">但是，这可以通过确保在调用另一个协定之前更新协定的状态变量来避免。这是通过在契约的状态上引入一个“互斥”锁来确保只有锁的所有者才能更改状态，并使用transfer方法向其他契约发送资金来实现的，因为该方法只向被调用的契约传输2300 gas。</p><p id="fa29" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">注意，重入主要有两种类型:单函数重入和跨函数重入。</p><p id="f8df" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> <em class="lc">单功能</em> </strong>。更简单，更容易防止跨功能重入。当易受攻击的函数是攻击者每次试图调用的唯一函数时，就会发生这种情况。</p><p id="95a9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"> <em class="lc">跨职能</em> </strong>。更难以察觉。当易受攻击的函数与另一个对攻击者有利的函数共享一个状态时，就会发生这种情况。</p><h2 id="fb98" class="ls kc ht bd kd mc md me kh mf mg mh kl jb mi mj kp jf mk ml kt jj mm mn kx mo dt translated">3.2 <strong class="ak">误处理异常</strong></h2><p id="159c" class="pw-post-body-paragraph iq ir ht is b it mp iv iw ix mq iz ja jb mr jd je jf ms jh ji jj mt jl jm jn hm dt translated">在以太坊中，一个契约调用另一个契约有几种方式，例如，通过发送指令或直接调用契约本身的函数。</p><p id="a16c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当异常处理不当时，会出现此漏洞。实际上，根据调用方式的不同，被调用契约中的异常可能会传播到调用者。异常传播中的这些不一致为新的漏洞打开了大门，恶意用户可以利用这些漏洞通过导致发送函数失败来调用调用协定。此外，异常可能由多种情况引起，如气体耗尽、超出调用堆栈限制、被调用节点中的意外系统错误。因此，解决这个问题的一种方法是对通话中的用气量设置上限。</p><h2 id="5dcc" class="ls kc ht bd kd mc md me kh mf mg mh kl jb mi mj kp jf mk ml kt jj mm mn kx mo dt translated">3.3 <strong class="ak">无气送</strong></h2><p id="3735" class="pw-post-body-paragraph iq ir ht is b it mp iv iw ix mq iz ja jb mr jd je jf ms jh ji jj mt jl jm jn hm dt translated">如果没有为特定呼叫提供足够的气体，无气体发送会导致交易失败。由于网络上的最大燃气限制会随着交易费用的变化而变化，因此根据燃气消耗量提供断电例外是很重要的。开发不需要太多气体的功能也很重要。</p><h2 id="127d" class="ls kc ht bd kd mc md me kh mf mg mh kl jb mi mj kp jf mk ml kt jj mm mn kx mo dt translated">3.4 <strong class="ak">未检查的外部呼叫</strong></h2><p id="c22e" class="pw-post-body-paragraph iq ir ht is b it mp iv iw ix mq iz ja jb mr jd je jf ms jh ji jj mt jl jm jn hm dt translated">Solidity中的一些外部调用，如“<strong class="is hu"> send </strong>()”、“<strong class="is hu"> call </strong>()”、“<strong class="is hu"> delegatecall </strong>()”和“<strong class="is hu"> staticcall() </strong>”从不抛出异常，它们只返回一个布尔值“<strong class="is hu"> false </strong>”。因此，即使调用遇到问题、意外失败或攻击者强制失败，契约的执行也将继续。</p><p id="80b8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了解决这个问题，建议返回值必须由开发人员手工检查，他也可以使用"<strong class="is hu"> transfer() </strong>"函数。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mw"><img src="../Images/93d90ee860ef9b6d6fedc5211535672c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*X4pijM6MRfPjdSUd7Cth3w.png"/></div></div><figcaption class="ly lz fg fe ff ma mb bd b be z ek">Vulnerable and not vulnerable code to Unchecked external call</figcaption></figure><h2 id="16ea" class="ls kc ht bd kd mc md me kh mf mg mh kl jb mi mj kp jf mk ml kt jj mm mn kx mo dt translated">3.5 <strong class="ak">通过tx.origin授权</strong></h2><p id="ab6d" class="pw-post-body-paragraph iq ir ht is b it mp iv iw ix mq iz ja jb mr jd je jf ms jh ji jj mt jl jm jn hm dt translated"><strong class="is hu"> tx.origin </strong>是一个可靠性变量，返回发送交易的账户地址。如果授权帐户调用易受攻击的协定，使用此变量进行授权可能会使协定易受攻击。可以对通过授权检查的易受攻击的契约进行调用，因为<strong class="is hu"> tx.origin </strong>返回交易的原始发送者，在这种情况下是授权账户。为了避免这个问题，建议使用“<strong class="is hu"> msg.sender </strong>”代替“<strong class="is hu"> tx.origin </strong>”授权。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff mx"><img src="../Images/48817a46c285edeada0871344f61770a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cZ0WDy7auQ-1ElS3RxbV7w.png"/></div></div><figcaption class="ly lz fg fe ff ma mb bd b be z ek">Vulnerable code using “tx.origin”</figcaption></figure><h2 id="28bd" class="ls kc ht bd kd mc md me kh mf mg mh kl jb mi mj kp jf mk ml kt jj mm mn kx mo dt translated">3.6 <strong class="ak">无保护自毁</strong></h2><p id="d248" class="pw-post-body-paragraph iq ir ht is b it mp iv iw ix mq iz ja jb mr jd je jf ms jh ji jj mt jl jm jn hm dt translated">“<strong class="is hu">自毁</strong>”指令销毁区块链上的合约，并将合约余额发送到指定地址。它对于销毁不再使用合同或易受攻击的合同(错误、漏洞，..).然而，如果它没有适当的访问控制，恶意方可以利用它来<strong class="is hu">自毁</strong>合同。</p><h2 id="304e" class="ls kc ht bd kd mc md me kh mf mg mh kl jb mi mj kp jf mk ml kt jj mm mn kx mo dt translated">3.7 <strong class="ak">函数和变量默认可见性</strong></h2><p id="7d5e" class="pw-post-body-paragraph iq ir ht is b it mp iv iw ix mq iz ja jb mr jd je jf ms jh ji jj mt jl jm jn hm dt translated">默认情况下，没有特定可见性类型的函数被认为是“公共的”。如果开发人员忘记设置可见性，那么恶意用户就会设法进行未经授权或意外的状态更改，这会导致漏洞。为了避免这个问题，建议必须根据函数指定适当的可见性。注意，函数可以指定为:“<strong class="is hu">外部</strong>”、“<strong class="is hu">公共</strong>”、“<strong class="is hu">内部</strong>”和“<strong class="is hu">私有</strong>”。</p><h2 id="329f" class="ls kc ht bd kd mc md me kh mf mg mh kl jb mi mj kp jf mk ml kt jj mm mn kx mo dt translated">3.8 <strong class="ak">整数溢出和下溢</strong></h2><p id="e815" class="pw-post-body-paragraph iq ir ht is b it mp iv iw ix mq iz ja jb mr jd je jf ms jh ji jj mt jl jm jn hm dt translated">这发生在接受未经授权的数据或值(例如，超过256位限制的数据)的事务中。这是因为由于Solidity只能处理256位以内的数字，增加(或减少)一个高于(或低于)最大(或最小)值的数字会导致<strong class="is hu">溢出</strong>(或<strong class="is hu">下溢</strong>)。此外，此漏洞是由于Solidity源代码没有对数字输入执行正确的验证，并且Solidity编译器和EVM都没有实施整数下溢或溢出检测。</p><p id="9eb1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">因此，建议使用<a class="ae jo" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/math/SafeMath.sol" rel="noopener ugc nofollow" target="_blank"><strong class="is hu">openzeplin safe math</strong></a><strong class="is hu"/>库来减轻此类攻击。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff my"><img src="../Images/377c08e837005fc368f40afbcb6eb0fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gC-mZiN6nQ67s77G85lprw.png"/></div></div><figcaption class="ly lz fg fe ff ma mb bd b be z ek">Vulnerable source code example : Integer overflow and underflow</figcaption></figure><h2 id="5a38" class="ls kc ht bd kd mc md me kh mf mg mh kl jb mi mj kp jf mk ml kt jj mm mn kx mo dt translated">3.9 <strong class="ak">乙醚丢失(冻结乙醚，锁钱)</strong></h2><p id="bd2c" class="pw-post-body-paragraph iq ir ht is b it mp iv iw ix mq iz ja jb mr jd je jf ms jh ji jj mt jl jm jn hm dt translated">被编程为接收以太网的合同必须实现诸如“<strong class="is hu">转移</strong>”、“<strong class="is hu">发送</strong>”或“<strong class="is hu">调用值</strong>”的方法，以便提取以太网。所以，如果契约没有实现这些方法，就会造成钱堵！</p><p id="2314" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">下面的源代码展示了一个契约的例子，它被编程为接收以太，但不撤销以太。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div class="fe ff mz"><img src="../Images/852262f860b19876d987558564dbab6d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1004/format:webp/1*rRlWq88sVQFxoRijzGf1kQ.png"/></div><figcaption class="ly lz fg fe ff ma mb bd b be z ek">Vulnerable source code example : Ether lost (Frozen Ether, locked money)</figcaption></figure><h2 id="440c" class="ls kc ht bd kd mc md me kh mf mg mh kl jb mi mj kp jf mk ml kt jj mm mn kx mo dt translated">3.10 <strong class="ak">拒绝服务(DoS) </strong></h2><p id="5f9b" class="pw-post-body-paragraph iq ir ht is b it mp iv iw ix mq iz ja jb mr jd je jf ms jh ji jj mt jl jm jn hm dt translated">这种类型的攻击使得用户无法访问智能合约。这可能是由于高成本循环、无限循环、定价过低的操作、呼叫失败或气体限制。</p><h2 id="0c3f" class="ls kc ht bd kd mc md me kh mf mg mh kl jb mi mj kp jf mk ml kt jj mm mn kx mo dt translated">代价高昂的循环</h2><p id="7a2f" class="pw-post-body-paragraph iq ir ht is b it mp iv iw ix mq iz ja jb mr jd je jf ms jh ji jj mt jl jm jn hm dt translated">这些包含高成本操作的循环会耗尽合约的所有能量。</p><h2 id="4e8a" class="ls kc ht bd kd mc md me kh mf mg mh kl jb mi mj kp jf mk ml kt jj mm mn kx mo dt translated">无限循环</h2><p id="bccf" class="pw-post-body-paragraph iq ir ht is b it mp iv iw ix mq iz ja jb mr jd je jf ms jh ji jj mt jl jm jn hm dt translated">可能导致无限循环的错误或编程错误。</p><h2 id="df5a" class="ls kc ht bd kd mc md me kh mf mg mh kl jb mi mj kp jf mk ml kt jj mm mn kx mo dt translated">低价运营</h2><p id="a493" class="pw-post-body-paragraph iq ir ht is b it mp iv iw ix mq iz ja jb mr jd je jf ms jh ji jj mt jl jm jn hm dt translated">一般来说，天然气的价值与作业消耗的资源成正比。然而，一些被称为“IO密集型操作”的操作低估了这个值，导致它们在单个事务中被大量执行。这样，攻击者就可以对合同或以太网区块链发起DOS攻击。这个问题已经通过改变不同操作的值得到了解决。</p><h2 id="1a33" class="ls kc ht bd kd mc md me kh mf mg mh kl jb mi mj kp jf mk ml kt jj mm mn kx mo dt translated">呼叫失败的DoS</h2><p id="7d89" class="pw-post-body-paragraph iq ir ht is b it mp iv iw ix mq iz ja jb mr jd je jf ms jh ji jj mt jl jm jn hm dt translated">外部调用可能会意外或故意失败，从而导致允许DOS攻击的漏洞。</p><p id="9f1b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了最大限度地减少此类故障造成的损失，建议将每个外部调用隔离到它自己的事务中，该事务可以由调用接收方发起。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff na"><img src="../Images/1a0b792d405670ef7153735d217fe075.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*W3I6SoKDdMxfLyPWXmVBwA.png"/></div></div><figcaption class="ly lz fg fe ff ma mb bd b be z ek">Vulnerable source code example : DOS with failed call</figcaption></figure><h2 id="0543" class="ls kc ht bd kd mc md me kh mf mg mh kl jb mi mj kp jf mk ml kt jj mm mn kx mo dt translated">3.10.5带阻塞气体限制的DoS</h2><p id="420b" class="pw-post-body-paragraph iq ir ht is b it mp iv iw ix mq iz ja jb mr jd je jf ms jh ji jj mt jl jm jn hm dt translated">当部署智能合约或调用其内部函数时，这些动作的执行需要一定量的gas。根据所需的计算能力，以太坊规定了每个块的gas限制，一个块中包含的所有事务的总和不能超过某个阈值。</p><p id="19a0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">编程模式在集中式应用程序中是无害的，但当执行一个函数的成本超过每个块的gas限制时，它会导致智能合约中的拒绝服务。此外，修改随时间增长的数组会导致拒绝服务。</p><p id="de78" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">建议考虑随时间增长的数组，并避免需要在整个数据结构上循环的操作。</p></div><div class="ab cl lg lh hb li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hm hn ho hp hq"><p id="9cdc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><em class="lc">【梅丽莎的功劳】</em></p></div><div class="ab cl lg lh hb li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hm hn ho hp hq"><p id="f3e3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果你喜欢，请留下你的评论，关注我，当我写新文章时你会得到通知，你也可以在<a class="ae jo" href="https://twitter.com/reotmani" rel="noopener ugc nofollow" target="_blank">推特</a>:)上关注我</p></div><div class="ab cl lg lh hb li" role="separator"><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll lm"/><span class="lj bw bk lk ll"/></div><div class="hm hn ho hp hq"><h1 id="093d" class="kb kc ht bd kd ke nb kg kh ki nc kk kl km nd ko kp kq ne ks kt ku nf kw kx ky dt translated">资源</h1><p id="da14" class="pw-post-body-paragraph iq ir ht is b it mp iv iw ix mq iz ja jb mr jd je jf ms jh ji jj mt jl jm jn hm dt translated">【https://arxiv.org/abs/1908.04507 T4】</p><p id="d5be" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><a class="ae jo" rel="noopener" href="/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21">https://medium . com/coin monks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972 C3 af 7c 21</a></p><p id="1ab3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><a class="ae jo" href="https://arxiv.org/abs/1908.08605" rel="noopener ugc nofollow" target="_blank">https://arxiv.org/abs/1908.08605</a></p><p id="dc17" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><a class="ae jo" href="https://eprint.iacr.org/2016/1007.pdf" rel="noopener ugc nofollow" target="_blank">https://eprint.iacr.org/2016/1007.pdf</a></p><p id="6d25" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><a class="ae jo" href="https://ntnuopen.ntnu.no/ntnu-xmlui/bitstream/handle/11250/2479191/18400_FULLTEXT.pdf" rel="noopener ugc nofollow" target="_blank">https://ntnuopen . ntnu . no/ntnu-XM lui/bitstream/handle/11250/2479191/18400 _ full text . pdf</a></p><p id="4449" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">https://swcregistry.io/</p><blockquote class="ng"><p id="b299" class="nh ni ht bd nj nk nl nm nn no np jn ek translated">交易新手？试试<a class="ae jo" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或者<a class="ae jo" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>