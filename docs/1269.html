<html>
<head>
<title>Learn Solidity lesson 9. Mappings.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习第九课“坚实”。映射。</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/learn-solidity-lesson-9-mappings-ec84cf501af3?source=collection_archive---------6-----------------------#2022-07-26">https://medium.com/coinmonks/learn-solidity-lesson-9-mappings-ec84cf501af3?source=collection_archive---------6-----------------------#2022-07-26</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/4ec4aa2d5282ed0bc07fca422b20911b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*p-eG_fAiesty3DREp7agJQ.jpeg"/></div></div></figure><p id="55cd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">映射是一种将键与值相关联的类型。就像一个函数，把键作为参数，然后返回值。但是，键不记录在区块链中，只记录它的哈希，因此不可能从值中检索键。</p><p id="a8bd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">地图声明如下。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="578e" class="ki kj ht ke b fv kk kl l km kn">mapping(keyType =&gt; valueType) variableName;</span></pre><p id="1a7e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">密钥可以是任何值类型、字符串、字节、枚举甚至其他契约。该值可以是任何类型，包括另一个映射。例如，字符串到uint映射的一个示例可以声明如下。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="cba4" class="ki kj ht ke b fv kk kl l km kn">mapping(string =&gt; uint) distribution;</span></pre><p id="b5b8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">为了向上面的映射添加新元素，使用了下面的语句。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="352a" class="ki kj ht ke b fv kk kl l km kn">distribution["John"] = 10;</span></pre><p id="a203" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">重要的是要理解密钥文字<code class="eh ko kp kq ke b">John</code>并不存储在区块链上。文字<code class="eh ko kp kq ke b">John</code>被转换成一个散列值，该散列值作为查找值<code class="eh ko kp kq ke b">10</code>的地址。</p><p id="3e96" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">哈希函数</strong>将任何大小的任何数据类型(从单个字到1 TB的数据)转换成固定长度的数字。在以太坊使用的散列函数的情况下，固定值是32字节。所以我们可以理解为什么散列函数是不可逆的:从32字节的散列中不可能恢复出初始信息。</p><p id="955f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">不可能迭代映射，因为键不是连续的。因此，如果不显式地尝试获取<code class="eh ko kp kq ke b">John</code>的值，就不可能知道键<code class="eh ko kp kq ke b">John</code>是否有值。要从键中检索映射值，使用以下语法。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="9203" class="ki kj ht ke b fv kk kl l km kn">mappingName[key]</span></pre><p id="24c2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在我们的示例中，为了检索键<code class="eh ko kp kq ke b">John</code>的值并将该值赋给一个变量，我们使用下面的语句。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="ca71" class="ki kj ht ke b fv kk kl l km kn">uint value = distribution["João"];</span></pre><p id="17c1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">地图在Solidity中的许多用途之一是在ERC-20令牌合同中。</p><h1 id="f1c3" class="kr kj ht bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">ERC-20令牌中的映射</h1><p id="1a93" class="pw-post-body-paragraph jb jc ht jd b je lo jg jh ji lp jk jl jm lq jo jp jq lr js jt ju ls jw jx jy hm dt translated">ERC-20令牌是以太坊和兼容区块链上最广泛使用的令牌标准。如果你拥有一些加密货币或游戏的代币，最有可能的是合同变量中的记录。</p><p id="5cf6" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">每个ERC-20令牌都有一个名为<strong class="jd hu"> balanceOf </strong>的映射，通常声明如下。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="5ca6" class="ki kj ht ke b fv kk kl l km kn">mapping(address =&gt; uint256) public balanceOf;</span></pre><p id="c03c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">上面的映射将地址作为键，将无符号整数作为值，它存储关于地址拥有多少令牌的信息。该变量是公共的，因此可以通过调用获取值。</p><p id="b7b1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当您的wallet(例如MetaMask)通知您拥有给定合约的<em class="lt"> X </em>令牌时，它所做的是获取合约的变量<em class="lt"> balanceOf </em>的值，将您的帐户作为密钥传递。</p><p id="fdbb" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们看一个例子。我在多角形网上有一个有一定戴量的账号。<strong class="jd hu">戴</strong>是一种美元<strong class="jd hu">稳定币</strong>，也就是说，它是一种保持(或试图保持)与美元1:1平价的代币。在下图中，MetaMask显示了我在该帐户中有多少Dai。</p><figure class="jz ka kb kc fq iu fe ff paragraph-image"><div class="fe ff lu"><img src="../Images/c6a8272dfe061d2c06a1848aa92986ec.png" data-original-src="https://miro.medium.com/v2/resize:fit:876/format:webp/1*FzV6PyJyZXvGRFQvTnqUVA.png"/></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">MetaMask reports the amount of tokens an account owns.</figcaption></figure><p id="61f4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">同样的信息可以直接从契约中检索，调用的函数<em class="lt">balance。在下图中，我们使用多边形的块资源管理器<a class="ae lz" href="http://polygonscan.com" rel="noopener ugc nofollow" target="_blank">polygonscan.com</a>来完成这个任务。</em></p><figure class="jz ka kb kc fq iu fe ff paragraph-image"><div class="fe ff ma"><img src="../Images/fdc6bff32cffc4c60941510d198b813a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1334/format:webp/1*xI36YV4empjOy_WC35pV9A.png"/></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">Using the block explorer it is possible to interact with the contract directly.</figcaption></figure><p id="7cf6" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">注意，值是相同的，但是MetaMask知道令牌有18个小数位，并根据该信息格式化令牌的数量。我希望大家都清楚，拥有ERC-20代币只不过是地图中<em class="lt">平衡的一个记录。</em></p><p id="93fd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">ERC-20代币也使用地图来存储关于账户的信息，允许其他账户代表他/她处理一定量的代币。让我们进一步解释一下。Ana可以允许Bob代表她发送来自给定合同的多达30个令牌。</p><p id="9949" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">Bob可以移动30个令牌的信息是从地址到整数的映射，类型为(Bob -&gt; 20)。但是，这张地图链接到了另一个地址，Ana的地址，as:Ana--&gt;(Bob--&gt; 20)。该数据结构可以如下实现。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="5406" class="ki kj ht ke b fv kk kl l km kn">mapping(address =&gt; mapping(address =&gt; uint)) _allowance;</span></pre><p id="473b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">变量名为<em class="lt"> _allowance </em>，是一个地址到另一个地址的映射。注意，这是允许的，因为两个映射的键类型都是类型<em class="lt">地址</em>。</p><h1 id="43dc" class="kr kj ht bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">迭代映射</h1><p id="391b" class="pw-post-body-paragraph jb jc ht jd b je lo jg jh ji lp jk jl jm lq jo jp jq lr js jt ju ls jw jx jy hm dt translated">正如我们已经说过的，不可能迭代映射的<em class="lt">类型的变量，因为键是从原始键值的散列中生成的32字节数字。</em></p><p id="ed24" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果我们想要存储密钥的原始值，我们需要在另一种类型的变量中进行:一个<em class="lt">数组</em>。我们还没有谈到数组，但我们将简要解释如何在数组的帮助下迭代地图。</p><p id="b3aa" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">该方法包括每次在映射中存储新条目时，将原始键存储在一个数组中。让我们看看下面的代码。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="a923" class="ki kj ht ke b fv kk kl l km kn">mapping(string =&gt; uint) myMap;<br/>arrayKeys.push(string);</span></pre><p id="bd4e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">第一行已经知道了。第二行在名为<em class="lt"> arrayKeys </em>的数组中存储了一个新条目。这样，我们将所有的键存储在一个键数组中。因为数组是可迭代的，所以可以迭代数组，并为数组的每个元素检索映射中的键值。</p><p id="c15b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">感谢阅读！</strong></p><p id="a95c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎任何投稿。<a class="ae lz" href="http://www.buymeacoffee.com/jpmorais" rel="noopener ugc nofollow" target="_blank">www.buymeacoffee.com/jpmorais</a></p><blockquote class="mb"><p id="0f4b" class="mc md ht bd me mf mg mh mi mj mk jy ek translated">交易新手？试试<a class="ae lz" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或者<a class="ae lz" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>