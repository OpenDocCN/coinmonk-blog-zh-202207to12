<html>
<head>
<title>Hacking Secrets in Ethereum Smart Contracts</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">以太坊智能合约中的黑客秘密</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/hacking-secrets-in-ethereum-smart-contracts-646c638c395c?source=collection_archive---------5-----------------------#2022-08-22">https://medium.com/coinmonks/hacking-secrets-in-ethereum-smart-contracts-646c638c395c?source=collection_archive---------5-----------------------#2022-08-22</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="e735" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">演示为什么不能在“私有”方法中存储秘密。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff jo"><img src="../Images/3433285cbf916d500ee3e7b114135771.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qa503Uhc2JuLeaHhmJI6nQ.jpeg"/></div></div></figure></div><div class="ab cl ka kb hb kc" role="separator"><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf kg"/><span class="kd bw bk ke kf"/></div><div class="hm hn ho hp hq"><p id="a886" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当我开始学习solidity和smart contracts时，我第一次尝试了一个简单的合同，如果用户提供正确的密码，它将允许取款。</p><p id="bc4e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这似乎是一个足够简单的应用程序，我想我可以将密码作为一个私有变量存储在智能合同中，我甚至可以在未来使用changePassword方法进行更改。</p><p id="022c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><code class="eh kh ki kj kk b">string private password = "CanIHazMyMoniesPlz";</code></p><p id="0573" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在许多应用中，存储秘密是件好事。<br/>例如，我可以:</p><ul class=""><li id="a4cf" class="kl km ht is b it iu ix iy jb kn jf ko jj kp jn kq kr ks kt dt translated">创建一个文字游戏，让人们根据猜测付费</li><li id="8202" class="kl km ht is b it ku ix kv jb kw jf kx jj ky jn kq kr ks kt dt translated">隐藏秘密内容的URL，只有令牌持有者才能看到</li><li id="120f" class="kl km ht is b it ku ix kv jb kw jf kx jj ky jn kq kr ks kt dt translated">为web3游戏中的随机数生成器存储随机种子</li><li id="248d" class="kl km ht is b it ku ix kv jb kw jf kx jj ky jn kq kr ks kt dt translated">制作一个NFT，其特征在某个时间戳之后显现</li><li id="b07c" class="kl km ht is b it ku ix kv jb kw jf kx jj ky jn kq kr ks kt dt translated">等等。</li></ul><p id="33e6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然而，在我深入研究之后，我很快发现这根本不是处理私人信息的安全方式。可靠性合同存放在区块链，区块链对全世界公开。雄心勃勃的区块链探险家可以检索和利用你合同中的任何数据。</p><blockquote class="kz"><p id="10e1" class="la lb ht bd lc ld le lf lg lh li jn ek translated">不要在你的智能合约中存储秘密！</p></blockquote><p id="eca4" class="pw-post-body-paragraph iq ir ht is b it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hm dt translated">尽管名字如此，存储在“私有”变量中的数据对每个人都是可见的。</p><h1 id="f086" class="lo lp ht bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml dt translated">如果他们不是，为什么他们被称为“私人”？</h1><p id="e50c" class="pw-post-body-paragraph iq ir ht is b it mm iv iw ix mn iz ja jb mo jd je jf mp jh ji jj mq jl jm jn hm dt translated">学习solidity时，您会了解到可以创建以下范围的变量(从最小到最大许可):</p><ul class=""><li id="4d50" class="kl km ht is b it iu ix iy jb kn jf ko jj kp jn kq kr ks kt dt translated"><code class="eh kh ki kj kk b">private</code>、<code class="eh kh ki kj kk b">internal</code>、<code class="eh kh ki kj kk b">external</code>、<code class="eh kh ki kj kk b">public</code></li></ul><p id="6619" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当试图从一个智能协定访问另一个智能协定时，调用智能协定无法看到私有变量。因此，有人可能会认为可以安全地将秘密信息存储在私有变量中，而不必担心有人会访问和利用这些私有信息。</p><p id="1a31" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然而，这个声明并不意味着“私有”,因为没有人可以读取数据。相反，Private指的是变量的范围(即什么代码可以访问它)。</p><p id="daaa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这些是上面提到的关键字的更清晰的定义:</p><ul class=""><li id="d2b6" class="kl km ht is b it iu ix iy jb kn jf ko jj kp jn kq kr ks kt dt translated">private:只能从自己的协定中调用</li><li id="9bff" class="kl km ht is b it ku ix kv jb kw jf kx jj ky jn kq kr ks kt dt translated">内部:可以从自身和派生的契约中调用</li><li id="7709" class="kl km ht is b it ku ix kv jb kw jf kx jj ky jn kq kr ks kt dt translated">外部:可以从外部合同(所有非内部的合同)中调用</li><li id="88ce" class="kl km ht is b it ku ix kv jb kw jf kx jj ky jn kq kr ks kt dt translated">public:可以从内部和外部契约中调用</li></ul><blockquote class="mr ms mt"><p id="ac1e" class="iq ir mu is b it iu iv iw ix iy iz ja mv jc jd je mw jg jh ji mx jk jl jm jn hm dt translated">Scope关键字不影响变量的可见性，因为变量存储在区块链中，并且总是由每个人使用。</p></blockquote><h1 id="8cb5" class="lo lp ht bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml dt translated">从头开始的演示</h1><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff my"><img src="../Images/aa4802643529239b6d8d6d5a2afb397e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Pc_ydEGBZmWA47Ax"/></div></div><figcaption class="mz na fg fe ff nb nc bd b be z ek">Photo by <a class="ae nd" href="https://unsplash.com/@markwilliamspics?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mark Williams</a> on <a class="ae nd" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e7fc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">下面我将向你展示这个概念的一步一步的演示。</p><p id="9e94" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们将执行以下操作:</p><ol class=""><li id="412a" class="kl km ht is b it iu ix iy jb kn jf ko jj kp jn ne kr ks kt dt translated">为开发环境设置hardhat</li><li id="6287" class="kl km ht is b it ku ix kv jb kw jf kx jj ky jn ne kr ks kt dt translated">创建并编译智能合同和部署脚本</li><li id="884b" class="kl km ht is b it ku ix kv jb kw jf kx jj ky jn ne kr ks kt dt translated">设置本地以太坊节点，并在本地部署智能合约</li><li id="973c" class="kl km ht is b it ku ix kv jb kw jf kx jj ky jn ne kr ks kt dt translated">运行一些代码来检索智能协定中私有变量的值</li></ol><p id="6589" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">打开你的终端，让我们开始吧！</p><h1 id="f64f" class="lo lp ht bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml dt translated">安装安全帽</h1><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff nf"><img src="../Images/3158fbf01d9ddee656f907f6a9aeb678.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E5km9BJ5XNTD54PcYmWmAA.jpeg"/></div></div></figure><p id="9fc9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Hardhat 是一个流行的工具，用于开发以太坊上的可靠性合同。我们将在演示中使用它，因此我们首先需要安装它。</p><p id="1ecc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我假设你已经安装了npm。如果您没有安装它，请按照如下指南进行安装:</p><div class="ng nh fm fo ni nj"><a rel="noopener follow" target="_blank" href="/@hayasnc/how-to-install-nodejs-and-npm-on-mac-using-homebrew-b33780287d8f"><div class="nk ab ej"><div class="nl ab nm cl cj nn"><h2 class="bd hu fv z el no eo ep np er et hs dt translated">如何用自制软件在Mac上安装NodeJS和NPM</h2><div class="nq l"><h3 class="bd b fv z el no eo ep np er et ek translated">步骤1:安装自制软件</h3></div><div class="nr l"><p class="bd b gc z el no eo ep np er et ek translated">medium.com</p></div></div><div class="ns l"><div class="nt l nu nv nw ns nx jy nj"/></div></div></a></div><p id="1ebf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">首先让我们建立一个安全帽项目</p><ol class=""><li id="2f91" class="kl km ht is b it iu ix iy jb kn jf ko jj kp jn ne kr ks kt dt translated">创建新文件夹</li><li id="56f6" class="kl km ht is b it ku ix kv jb kw jf kx jj ky jn ne kr ks kt dt translated">进入文件夹并运行<code class="eh kh ki kj kk b">npx hardhat</code></li></ol><p id="9e90" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">3.为了保持代码简单，我们将在这个项目中使用javascript。选择该选项并按enter键接受其余的默认选择。</p><p id="b120" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">您应该会看到类似下面的屏幕。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff ny"><img src="../Images/6516a138aac5e32cdeeba4e96a4a7fa8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-3ltg5Aky78LmQoHV2itYA.png"/></div></div></figure><p id="4e6b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后，它应该开始安装npm依赖项并设置您的项目。一旦完成，你可以检查目录，你应该会看到如下…</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff nz"><img src="../Images/1107acc3e151d182006459486b444d0b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*RQBtW6NzeKNaRsUksl2HHg.png"/></div></div></figure><p id="ac17" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">4.在您最喜欢的编辑器中打开<code class="eh kh ki kj kk b">./contracts/Lock.sol</code>(我将使用<a class="ae nd" href="https://code.visualstudio.com/" rel="noopener ugc nofollow" target="_blank"> VSCode </a>)。</p><h1 id="27dc" class="lo lp ht bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml dt translated">设置带有秘密的智能合同</h1><p id="46d1" class="pw-post-body-paragraph iq ir ht is b it mm iv iw ix mn iz ja jb mo jd je jf mp jh ji jj mq jl jm jn hm dt translated">您开立的合约在特定的时间内锁定。我们可以修改这个智能合约，如果您提供正确的密码(存储为私有变量),就可以有一个方法让您提前获得资金。</p><ol class=""><li id="f410" class="kl km ht is b it iu ix iy jb kn jf ko jj kp jn ne kr ks kt dt translated">创建一个新的私有方法，调用如下:<br/> <code class="eh kh ki kj kk b">string private password;</code></li><li id="1e99" class="kl km ht is b it ku ix kv jb kw jf kx jj ky jn ne kr ks kt dt translated">更新构造函数以设置密码:</li></ol><pre class="jp jq jr js fq oa kk ob oc aw od dt"><span id="e146" class="oe lp ht kk b fv of og l oh oi">constructor(uint _unlockTime, string memory _password) payable {<br/>    require(<br/>        block.timestamp &lt; _unlockTime,<br/>        "Unlock time should be in the future"<br/>    );<br/>    unlockTime = _unlockTime;<br/>    owner = payable(msg.sender);<br/>    password = _password;<br/>}</span></pre><p id="60fb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">3.创建一个新的<code class="eh kh ki kj kk b">forceWithdraw</code>方法，它与<code class="eh kh ki kj kk b">withdraw</code>方法相同，但是接受一个密码并检查它，而不是时间戳。它应该是这样的:</p><pre class="jp jq jr js fq oa kk ob oc aw od dt"><span id="0b47" class="oe lp ht kk b fv of og l oh oi">function forceWithdraw(uint _password) public {<br/>    require(strcmp(_password, password);<br/>    require(msg.sender == owner, "You aren't the owner");<br/>    emit Withdrawal(address(this).balance, block.timestamp);<br/>    owner.transfer(address(this).balance);<br/>}</span><span id="61b6" class="oe lp ht kk b fv oj og l oh oi">/** Compare 2 strings */<br/>function strcmp(string memory s1, string memory s2) pure internal returns (bool) {<br/>    return keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2));<br/>}</span></pre><p id="9e96" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">(注意，Solidity不能比较字符串，所以我必须添加一个助手函数<code class="eh kh ki kj kk b">strcmp</code>来执行字符串相等检查)</p><p id="bdc2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">您的整个合同应该如下所示:</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff ok"><img src="../Images/00090ca269c88bfe57dc389c7e5efb16.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AUexw5YUZCeD9jBPnxkk_Q.png"/></div></div></figure><p id="94bc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">4.最后，您需要更新部署设置来设置密码。您只需要将密码参数添加到部署方法中，如下:<br/> <code class="eh kh ki kj kk b">const lock = await Lock.deploy(unlockTime, "CanIHazMyMoniesPlz", {value: lockedAmount});</code></p><p id="f95f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我重构了部署脚本，将部署提取到一个私有方法中，但是您可以在下面看到我的脚本是如何结束的:</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff ol"><img src="../Images/0b4f697d672dffb91604db8db5c37b89.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I896Wjz95ZxO06z2NoUSgg.png"/></div></div></figure><p id="0435" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">尽管这是人为的，但该合同将允许所有者通过输入密码提前取回锁定的ETH。密码是在合同创建时设置的，但在合同代码本身中看不到。</p><p id="bb56" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">正如您将在下一节中看到的，即使您没有访问部署脚本的权限，您仍然能够弄清楚私有<code class="eh kh ki kj kk b">password</code>参数中存储了什么</p><h1 id="f049" class="lo lp ht bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml dt translated">运行本地以太坊节点并部署</h1><p id="1017" class="pw-post-body-paragraph iq ir ht is b it mm iv iw ix mn iz ja jb mo jd je jf mp jh ji jj mq jl jm jn hm dt translated">现在您已经准备好了代码，您可以启动ethereum本地实例并部署到区块链。我们可以用hardhat命令很容易地做到这一点:</p><ol class=""><li id="e8a9" class="kl km ht is b it iu ix iy jb kn jf ko jj kp jn ne kr ks kt dt translated">运行<code class="eh kh ki kj kk b">npx hardhat node</code>在本地运行你的节点<br/>——注意这会产生一堆带有地址和私钥的钱包。<br/> -还要注意它在顶部运行的地址。最有可能的是它应该在<code class="eh kh ki kj kk b">http://localhost:8545</code>上运行。该消息将如下所示:</li></ol><pre class="jp jq jr js fq oa kk ob oc aw od dt"><span id="cac1" class="oe lp ht kk b fv of og l oh oi">Started HTTP and WebSocket JSON-RPC server at <a class="ae nd" href="http://127.0.0.1:8545/" rel="noopener ugc nofollow" target="_blank">http://127.0.0.1:8545/</a></span></pre><p id="a278" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">2.在另一个终端窗口中，使用以下命令编译脚本并将其部署到本地节点:</p><pre class="jp jq jr js fq oa kk ob oc aw od dt"><span id="a49a" class="oe lp ht kk b fv of og l oh oi">&gt; npx hardhat compile ; npx hardhat run scripts/deploy.js --network localhost</span></pre><p id="663e" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">通过检查您的以太坊节点终端窗口，您可以看到它已被部署，您应该会看到类似下面的内容:</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff om"><img src="../Images/3243c0b8bfeb0cb84970f9cb77c9a8d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CXmQOI5D67GjKOZdscXGjw.png"/></div></div></figure><p id="175d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">3.请注意此处的合同地址。如果您返回到另一个窗口，您还应该在运行命令的响应中看到合同地址。它应该是这样的:</p><pre class="jp jq jr js fq oa kk ob oc aw od dt"><span id="5fce" class="oe lp ht kk b fv of og l oh oi">Lock with 1 ETH and unlock timestamp 1692636050 deployed to 0x5FbDB2315678afecb367f032d93F642f64180aa3</span></pre><blockquote class="kz"><p id="a284" class="la lb ht bd lc ld on oo op oq or jn ek translated">现在，您已经在本地部署了合同！</p></blockquote><p id="9091" class="pw-post-body-paragraph iq ir ht is b it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hm dt translated">接下来，我们将进入控制台访问区块链，并找出密码！</p><h1 id="b773" class="lo lp ht bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml dt translated">从区块链中提取秘密</h1><p id="3276" class="pw-post-body-paragraph iq ir ht is b it mm iv iw ix mn iz ja jb mo jd je jf mp jh ji jj mq jl jm jn hm dt translated">现在有趣的部分来了！让我们进入javascript控制台并检索存储信息。</p><ol class=""><li id="1e2d" class="kl km ht is b it iu ix iy jb kn jf ko jj kp jn ne kr ks kt dt translated">Hardhat带有一个javascript控制台，提供一些关键功能，并自动加载库<a class="ae nd" href="https://docs.ethers.io/v5/getting-started/" rel="noopener ugc nofollow" target="_blank"> ethers.js </a>。我们将使用这个库对本地以太坊区块链进行网络呼叫。加载控制台，并使用以下命令将其连接到本地主机上的区块链:</li></ol><pre class="jp jq jr js fq oa kk ob oc aw od dt"><span id="32a0" class="oe lp ht kk b fv of og l oh oi">npx hardhat console --network localhost</span></pre><p id="c934" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">2.接下来，我们将使用以下命令初始化一个提供者:</p><pre class="jp jq jr js fq oa kk ob oc aw od dt"><span id="af43" class="oe lp ht kk b fv of og l oh oi">const provider = ethers.getDefaultProvider('<a class="ae nd" href="http://localhost:8545'" rel="noopener ugc nofollow" target="_blank">http://localhost:8545'</a>)</span></pre><p id="77a8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">将提供者视为区块链的客户端接口。这可以用来从我们的区块链节点获取我们需要的信息。</p><p id="6d22" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">3.让我们使用提供者来检查所有者钱包的当前余额。我们可以对比一下这个来证明<code class="eh kh ki kj kk b">forceWithdraw</code>确实起作用了。运行下面的命令并记住返回的数字(应该是9998.99…):</p><pre class="jp jq jr js fq oa kk ob oc aw od dt"><span id="7538" class="oe lp ht kk b fv of og l oh oi">&gt; ethers.utils.formatEther(await provider.getBalance('0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266'))<br/>'9998.999714736'</span></pre><p id="cb38" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">4.现在让我们连接到合同。使用以下代码执行此操作，但请确保将附加的地址替换为您的合同地址:</p><pre class="jp jq jr js fq oa kk ob oc aw od dt"><span id="1d7b" class="oe lp ht kk b fv of og l oh oi">&gt; const Lock = await ethers.getContractFactory('Lock');<br/>undefined<br/>&gt; const lock = await Lock.attach('0x5fbdb2315678afecb367f032d93f642f64180aa3');<br/>undefined</span></pre><p id="dc4c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">5.您可以通过使用错误的密码来测试force retract不起作用。尝试以下方法:</p><pre class="jp jq jr js fq oa kk ob oc aw od dt"><span id="5db3" class="oe lp ht kk b fv of og l oh oi">&gt; lock.forceWithdraw("bad password")<br/>Promise {<br/>  &lt;pending&gt;,<br/>  [Symbol(async_id_symbol)]: 1507,<br/>  [Symbol(trigger_async_id_symbol)]: 6,<br/>  [Symbol(destroyed)]: { destroyed: false }<br/>}<br/>&gt; Uncaught:<br/>Error: cannot estimate gas; transaction may fail or may require manual gas limit [ See: <a class="ae nd" href="https://links.ethers.org/v5-errors-UNPREDICTABLE_GAS_LIMIT" rel="noopener ugc nofollow" target="_blank">https://links.ethers.org/v5-errors-UNPREDICTABLE_GAS_LIMIT</a> ] (reason="Error: VM Exception while processing transaction: reverted with reason string 'incorrect password'",<br/>...</span></pre><p id="3e58" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如您所见，没有正确的密码，该命令不起作用。</p><blockquote class="kz"><p id="a57c" class="la lb ht bd lc ld le lf lg lh li jn ek translated">让我们检查节点存储中的正确密码</p></blockquote><p id="f8d8" class="pw-post-body-paragraph iq ir ht is b it lj iv iw ix lk iz ja jb ll jd je jf lm jh ji jj ln jl jm jn hm dt translated">6.在hardhat控制台中，运行以下命令</p><pre class="jp jq jr js fq oa kk ob oc aw od dt"><span id="af16" class="oe lp ht kk b fv of og l oh oi">&gt; const passwordHex = await provider.getStorageAt(lock.address, 2);<br/>undefined</span></pre><blockquote class="mr ms mt"><p id="97b9" class="iq ir mu is b it iu iv iw ix iy iz ja mv jc jd je mw jg jh ji mx jk jl jm jn hm dt translated">注:<code class="eh kh ki kj kk b">2</code>代表内存位置。我将在下一节解释这一点</p></blockquote><p id="1a60" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">您可以检查为<code class="eh kh ki kj kk b">passwordHex</code>返回的值，它应该如下所示:</p><pre class="jp jq jr js fq oa kk ob oc aw od dt"><span id="dd0a" class="oe lp ht kk b fv of og l oh oi">&gt; passwordHex<br/>'0x43616e4948617a4d794d6f6e696573506c7a0000000000000000000000000000'</span></pre><p id="eecf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">7.十六进制值对我们来说并不那么有用。我们现在必须将十六进制转换成字符串。让我们创建一个函数，将它转换成可读的字符串</p><pre class="jp jq jr js fq oa kk ob oc aw od dt"><span id="1ae5" class="oe lp ht kk b fv of og l oh oi">&gt; const decode = hex =&gt; {<br/>... const hexStr = hex.toString();<br/>... let stringBuilder = [];<br/>... for (let i=0; i &lt; hexStr.length; i += 2) {<br/>..... stringBuilder.push(String.fromCharCode(parseInt(hex.substr(i,2), 16)));stri<br/>..... }<br/>... return stringBuilder.join('');<br/>... }<br/>undefined</span></pre><p id="abaa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">8.对passwordHex运行函数以获取值</p><pre class="jp jq jr js fq oa kk ob oc aw od dt"><span id="8ed5" class="oe lp ht kk b fv of og l oh oi">&gt;console.log(decode(passwordHex))<br/>CanIHazMyMoniesPlz<br/>undefined</span></pre><figure class="jp jq jr js fq jt fe ff paragraph-image"><div class="fe ff os"><img src="../Images/8ed66f49fa50122bb80953c851932843.png" data-original-src="https://miro.medium.com/v2/resize:fit:1276/1*WpHH5dldchlb_0aPrxxyhA.gif"/></div><figcaption class="mz na fg fe ff nb nc bd b be z ek">Safe Cracked!</figcaption></figure><p id="91dc" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，您可以使用找回的密码取回您的资金:</p><pre class="jp jq jr js fq oa kk ob oc aw od dt"><span id="3c0c" class="oe lp ht kk b fv of og l oh oi">&gt; ethers.utils.formatEther(await provider.getBalance('0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'))<br/>'9998.99941542475'<br/>&gt; await lock.forceWithdraw('CanIHazMyMoniesPlz')<br/>{<br/>  hash: '0x80241e3ece8a5a2888978040cb9de0a7b918108f6cc28537fb796c1ff36d18ff',<br/>  ...<br/>}<br/>&gt; ethers.utils.formatEther(await provider.getBalance('0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'))<br/>'9999.999367167822353675'</span></pre><h1 id="0e30" class="lo lp ht bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml dt translated">这个神秘的“2”位置是什么？</h1><p id="38cf" class="pw-post-body-paragraph iq ir ht is b it mm iv iw ix mn iz ja jb mo jd je jf mp jh ji jj mq jl jm jn hm dt translated">上面我忽略了一件事，那就是我们如何从<code class="eh kh ki kj kk b">getStorageAt</code>函数中获得位置参数‘2’。</p><p id="e725" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了获得这一价值，我们必须了解存储是如何工作的。</p><p id="214a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这里有一个关于稳固性规则的简单总结:</p><ul class=""><li id="54cc" class="kl km ht is b it iu ix iy jb kn jf ko jj kp jn kq kr ks kt dt translated">在函数外部声明的变量是状态变量，默认情况下，所有状态变量都存储在存储器中。</li><li id="6d4a" class="kl km ht is b it ku ix kv jb kw jf kx jj ky jn kq kr ks kt dt translated"><code class="eh kh ki kj kk b">immutable</code>和<code class="eh kh ki kj kk b">constant</code>实际上被编译成代码，因此不会占用任何存储空间。</li><li id="19a4" class="kl km ht is b it ku ix kv jb kw jf kx jj ky jn kq kr ks kt dt translated">每个存储槽的大小为32字节</li><li id="8efc" class="kl km ht is b it ku ix kv jb kw jf kx jj ky jn kq kr ks kt dt translated">如果符合<br/>，单个存储槽可以容纳多个变量——例如，一个布尔值只需要一位，所以如果它们是背靠背的，你可以在单个存储槽中存储8 * 32 = 256个布尔值</li><li id="3a56" class="kl km ht is b it ku ix kv jb kw jf kx jj ky jn kq kr ks kt dt translated">结构和固定数组开始一个新的存储槽</li><li id="2abd" class="kl km ht is b it ku ix kv jb kw jf kx jj ky jn kq kr ks kt dt translated">动态数组为每个元素创建一个槽</li><li id="ac94" class="kl km ht is b it ku ix kv jb kw jf kx jj ky jn kq kr ks kt dt translated">映射是声明映射的键和存储槽的连接[查看<a class="ae nd" href="https://ethereum.stackexchange.com/questions/114186/how-does-ethereum-fit-a-mapping-into-storage" rel="noopener ugc nofollow" target="_blank">这就回答</a>关于映射如何存储的更多细节]</li></ul><p id="941d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这有点简单，但对你来说足够了。如果您想了解EVM如何处理存储的更多细节，请查看本指南。</p><p id="c19d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">使用这些规则，我们可以查看我们的可靠性代码，并计算出密码存储在slot 2中，如下所示:</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff ot"><img src="../Images/66af72ad1d90f5c4de6e97635d00733c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*grOZSc6yFfgbmNlt_TRfaA.png"/></div></div></figure><h1 id="01ad" class="lo lp ht bd lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml dt translated">不要把秘密藏在仓库里</h1><p id="08b4" class="pw-post-body-paragraph iq ir ht is b it mm iv iw ix mn iz ja jb mo jd je jf mp jh ji jj mq jl jm jn hm dt translated">如上所述，存储在存储器中的秘密是不安全的。更糟糕的是，黑客可能会创建工具来简化或自动化许多步骤，我在上面建议让这个过程变得更快更容易。</p><p id="61a8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">你最好的办法是首先不要依赖这些秘密的存在。然而，有时您需要为您的应用程序存储秘密。寻找解决这个问题的方法超出了本文的范围，但是您可以探索以下一些方法:</p><ol class=""><li id="d5cd" class="kl km ht is b it iu ix iy jb kn jf ko jj kp jn ne kr ks kt dt translated">你的申请的那一部分需要属于区块链吗？区块链对许多用例来说非常好，但对其他用例来说就不那么好了。考虑是否有更好的选择，比如调用常规的网络服务。这造成了集中化的问题，但在某些情况下可能是相关的。</li><li id="2a1d" class="kl km ht is b it ku ix kv jb kw jf kx jj ky jn ne kr ks kt dt translated">能不能靠<code class="eh kh ki kj kk b">msg.sender</code>。<code class="eh kh ki kj kk b">Msg.sender</code>是一个不拥有键就无法真正操作的字段。在某些应用中，这可能有助于保护您需要保护的任何东西。</li><li id="14ea" class="kl km ht is b it ku ix kv jb kw jf kx jj ky jn ne kr ks kt dt translated">作为上述内容的变体，钱包密钥可用于“签名”信息(即加密/解密)。您可以将加密的数据存储在区块链中，只允许签名者使用他们的密钥(存储在区块链之外)来访问它。<a class="ae nd" href="https://github.com/pubkey/eth-crypto/blob/master/tutorials/encrypted-message.md" rel="noopener ugc nofollow" target="_blank">详见本代码</a></li><li id="18e7" class="kl km ht is b it ku ix kv jb kw jf kx jj ky jn ne kr ks kt dt translated">一种有趣的方法是<a class="ae nd" href="https://karl.tech/learning-solidity-part-2-voting/" rel="noopener ugc nofollow" target="_blank">提交揭示模式</a>。这种模式应用有限，而且有点复杂，但它是一种策略，可以用来隐藏用户提供的信息，直到所有用户都提交了他们的输入。(例如，秘密拍卖)</li></ol><p id="1e67" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">区块链数据的隐私是一项尖端技术中的尖端。未来将继续开发方法来支持在区块链上存储私有数据的用例。然而，在那之前…</p><blockquote class="kz"><p id="de6f" class="la lb ht bd lc ld le lf lg lh li jn ek translated">不要把秘密藏在仓库里</p><p id="98b7" class="la lb ht bd lc ld le lf lg lh li jn ek translated">加入Coinmonks <a class="ae nd" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae nd" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>获取每日<a class="ae nd" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank">加密新闻</a></p></blockquote><h1 id="1dea" class="lo lp ht bd lq lr ls lt lu lv lw lx ly lz ou mb mc md ov mf mg mh ow mj mk ml dt translated">另外，阅读</h1><ul class=""><li id="e1f0" class="kl km ht is b it mm ix mn jb ox jf oy jj oz jn kq kr ks kt dt translated"><a class="ae nd" href="https://coincodecap.com/smithbot-review" rel="noopener ugc nofollow" target="_blank"> SmithBot评论</a> | <a class="ae nd" href="https://coincodecap.com/free-open-source-trading-bots" rel="noopener ugc nofollow" target="_blank"> 4款最佳免费开源交易机器人</a></li><li id="6c26" class="kl km ht is b it ku ix kv jb kw jf kx jj ky jn kq kr ks kt dt translated"><a class="ae nd" rel="noopener" href="/coinmonks/coinbase-bots-ac6359e897f3">比特币基地僵尸工具</a> | <a class="ae nd" rel="noopener" href="/coinmonks/ascendex-review-53e829cf75fa"> AscendEX审查</a> | <a class="ae nd" rel="noopener" href="/coinmonks/okex-trading-bots-234920f61e60"> OKEx交易僵尸工具</a></li><li id="ef77" class="kl km ht is b it ku ix kv jb kw jf kx jj ky jn kq kr ks kt dt translated"><a class="ae nd" rel="noopener" href="/coinmonks/buy-bitcoin-in-india-feb50ddfef94">如何在印度购买比特币？</a> | <a class="ae nd" rel="noopener" href="/coinmonks/wazirx-review-5c811b074f5b">瓦济克斯审查</a></li><li id="53a3" class="kl km ht is b it ku ix kv jb kw jf kx jj ky jn kq kr ks kt dt translated"><a class="ae nd" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a> | <a class="ae nd" href="https://coincodecap.com/probit-review" rel="noopener ugc nofollow" target="_blank"> Probit审查</a></li><li id="0396" class="kl km ht is b it ku ix kv jb kw jf kx jj ky jn kq kr ks kt dt translated"><a class="ae nd" rel="noopener" href="/coinmonks/cryptohopper-alternatives-d67287b16d27">隐料斗替代品</a> | <a class="ae nd" rel="noopener" href="/coinmonks/hitbtc-review-c5143c5d53c2"> HitBTC审查</a></li></ul></div></div>    
</body>
</html>