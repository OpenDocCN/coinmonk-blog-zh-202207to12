<html>
<head>
<title>What is the Merkle tree?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">什么是Merkle树？</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/what-is-the-merkle-tree-91825a8a8891?source=collection_archive---------19-----------------------#2022-09-16">https://medium.com/coinmonks/what-is-the-merkle-tree-91825a8a8891?source=collection_archive---------19-----------------------#2022-09-16</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="5901" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu"><em class="jo">Merkle树(哈希树)是一种为大量数据生成单个哈希的算法。该方法用于检查文件的完整性和验证数据。它是如何工作的？我们为什么需要它？让我们来了解一下！</em>T3】</strong></p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/722ebb938d01ab55d5e3c0117aa336c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*k8nglhQXCMSEX-a6yqbnMA.png"/></div></div></figure><p id="03d1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">哈希树可以表示为一种结构，其分支从底部分支到中间节点。在分支的末端，放置代表数据片段的叶子。根哈希位于树的底部(Merkle root)。后者是比特币块头的必需组件。</p><p id="04b8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">可以使用根哈希来验证每个事务。您只需要下载块头和操作的认证路径。Merkle树减少了所需的计算数量，从而简化了支付验证(SPV)。</p><h1 id="a9f5" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">谁在何时创造了Merkle树？</h1><p id="c3fc" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hm dt translated">T4教授Ralph Merkle开发了哈希树的概念。在<strong class="is hu"> 1979 </strong>年，他发明了一种表示数字签名的方法。斯坦福大学拥有这项技术的专利。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/54074b3ae869c55a0898b194548a95d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Fuw76N-IbuRFAhhfxRktgw.png"/></div></div></figure><p id="5c56" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这位科学家提议使用二叉哈希树。Merkle还对密码学的发展做出了重大贡献。他因<strong class="is hu"> 1987 </strong>出版物<a class="ae le" href="https://link.springer.com/chapter/10.1007/3-540-48184-2_32" rel="noopener ugc nofollow" target="_blank">“基于с传统加密函数的数字签名”</a>而闻名。</p><h1 id="b5a7" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">为什么我们需要Merkle树？</h1><p id="87bd" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hm dt translated">集中式系统从所有用户依赖的单一来源提供数据。它确保收到的信息是正确的。</p><p id="fa46" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">分布式数据库就是区块链。它的内容存储在节点网络上。该节点不能接受来自其他参与者的消息，除非它们被验证。该节点必须决定该块是否包含有效的事务。</p><p id="70ec" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">Merkle树可以用来节省计算费用。它们使您能够减少下载的数据量，并通过哈希优化验证。</p><p id="cbb8" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">比特币、以太坊和其他加密货币都使用这种方法。它用于获取验证一组事务的数据字符串。此外，该算法还用于文件系统和数据库。使用Merkle树对信息进行错误检查和同步。</p><h1 id="6999" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">Merkle树是如何工作的？</h1><p id="3255" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hm dt translated">Merkle树是从头开始建造的。散列数据片段产生叶顶点中的值。下一级的节点包含两个子节点之和的散列。串联是一种组合数据的方法。对以下级别的节点重复该操作，直到获得单个散列。如果元素的数量是奇数，其中一个将被复制或不变地转移到下一级。</p><p id="2ccf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当构造一个树时，获得一个散列，它被称为Merkle根。它代表所有的数据片段。因此，Merkle树是一个单向散列函数。</p><p id="fb8f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">该算法允许您创建一个二进制结构，其节点值由两个字符串组成。后一种属性允许验证大量数据，而无需为每个片段重新计算散列。在这种情况下，确定单个元素的真实性的计算成本要低得多。</p><p id="b419" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">为了确保数组的正确性和完整性，必须将根哈希与参考值进行比较。片段可以是事务数据或文件的一部分。</p><h1 id="214d" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">比特币中的Merkle树是如何使用的？</h1><p id="baf5" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hm dt translated">比特币区块链是由写入链末端的碎片构建而成的。它包含有关用户转移的信息。因为事务的数量和信息量都是可变的，所以块没有固定的大小。</p><p id="e9d7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">比特币节点会创建标头来优化计算。它们由以下要素组成:</p><ul class=""><li id="0225" class="lf lg ht is b it iu ix iy jb lh jf li jj lj jn lk ll lm ln dt translated"><a class="ae le" href="https://developer.bitcoin.org/reference/block_chain.html" rel="noopener ugc nofollow" target="_blank">块版本号</a>；</li><li id="d088" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln dt translated">前一个块的哈希；</li><li id="5d5b" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln dt translated">Merkle树的根；</li><li id="bb70" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln dt translated">时间戳；</li><li id="81b9" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln dt translated">挖掘复杂性的目标；</li><li id="23ab" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln dt translated">生成块时使用的一次性代码(随机数)。</li></ul><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/4a6ecb231fcdada744bec78663a233cf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ECVxbL5Zd42fn3q92E-Ydg.png"/></div></div></figure><p id="f470" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">报头长度为80字节，不包括任何事务。因为每十分钟生成一次，所以数据量每年增加4.2兆。</p><p id="6d29" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">事务信息被散列，允许您获得事务id。传输数据以十六进制格式保存。根哈希表示块中的所有事务。构建Merkle树来寻找后者。以下算法用于处理数据:</p><ol class=""><li id="c245" class="lf lg ht is b it iu ix iy jb lh jf li jj lj jn lt ll lm ln dt translated">块中包含事务的散列(标识符):散列(L1)、散列(L2)、散列(L3)等等。它们形成了树叶。</li><li id="084d" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lt ll lm ln dt translated">来自两个相邻标识符之和的散列被放置在下一级:散列(散列(L1) +散列(L2))。在二叉树中，每一层的节点数必须是偶数。否则，将复制最后一个单元格的散列，并将其放入另一个元素中。</li><li id="1378" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lt ll lm ln dt translated">重复散列数据量的过程，直到获得Merkle根。</li></ol><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/3af83f3e43c89f5e810ded191887d4f4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LH7Es-sHI27fejO7cAJZuQ.png"/></div></div></figure><p id="67cd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">每个事务的有效性由产生的散列来确认。当形成区块链时，节点仅使用先前块的报头。</p><p id="40b1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">隔离证人协议于2017年8月在<strong class="is hu">更新。它采用了不同的事务数据结构，从而减小了数据块的大小。该更新的采用降低了比特币区块链的负载。</strong></p><h1 id="5024" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">Merkle树有什么优势？</h1><p id="0334" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hm dt translated">散列树使得验证事务属于特定块变得更加容易，并确保数据在传输时的完整性。该方法是更容易的支付验证所必需的。在比特币白皮书中，中本聪建议使用SPV。</p><p id="e902" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如果节点有足够的计算能力，它可以加载所有的块并计算每个事务的散列。然后形成Merkle树。它们允许您验证数据的完整性和每个操作的有效性。如果节点资源有限，它只能请求块头和事务id。</p><p id="9e33" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><a class="ae le" href="https://www.coinbase.com/ru/cloud/discover/dev-foundations/blockchain-client-types#Light-clients" rel="noopener ugc nofollow" target="_blank">轻客户端</a>加载被验证交易的头和认证路径(Merkle proof)。它们从完整节点请求信息。认证路径包括来自位于从顶点到事务的路径上的每对树节点的散列。</p><p id="ff5c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">它们从整个节点请求信息。从顶点到事务的路径上的每对树节点的散列被包括在认证路径中。</p><p id="2489" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">要验证操作，必须找到Merkle根。如果接收到的散列与块报头中的字符串匹配，则交易被确认。几乎不可能在另一个数据集中找到所需的Merkle根，从而确保操作的有效性。</p><p id="95eb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">SPV方法使简单客户端能够与区块链交互，同时减少下载的数据量。例如，具有五个事务的500千字节的块大小对于Merkle的证明只需要140字节。</p><h1 id="4a51" class="kb kc ht bd kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky dt translated">以太坊用的是哪棵Merkle树？</h1><p id="5677" class="pw-post-body-paragraph iq ir ht is b it kz iv iw ix la iz ja jb lb jd je jf lc jh ji jj ld jl jm jn hm dt translated">Merkle二叉树是表示为列表的数组的理想选择。它的结构保持不变，这使得散列事务更容易。前缀树是以太坊中表示数据的一种不同方式。</p><p id="60f2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">该树使您能够将数据存储在关联数组中。字符串是定义集合中元素位置的键。树的分支由不同的符号表示以形成结构，因此元素的键唯一地标识它。</p><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/df49bd265ee77e165d69b32b17516380.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PQ6IqdLwDTFORk6Qr-kQjQ.png"/></div></div></figure><p id="40c7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">与比特币不同，以太坊区块链使用三种哈希树:</p><ul class=""><li id="adaa" class="lf lg ht is b it iu ix iy jb lh jf li jj lj jn lk ll lm ln dt translated">事务树；</li><li id="1d8a" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln dt translated">国家之树；</li><li id="7946" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln dt translated">包含交易结果数据的树。</li></ul><p id="1aca" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">块头包括三个根哈希。以太坊允许您创建能够执行一组基本操作的轻型客户端，例如:</p><ul class=""><li id="41b8" class="lf lg ht is b it iu ix iy jb lh jf li jj lj jn lk ll lm ln dt translated">检查块中是否有交易；</li><li id="33d6" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln dt translated">确认特定地址的存在；</li><li id="308e" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln dt translated">确定用户的余额；</li><li id="51e1" class="lf lg ht is b it lo ix lp jb lq jf lr jj ls jn lk ll lm ln dt translated">找出操作或智能合约的结果。</li></ul><figure class="jq jr js jt fq ju fe ff paragraph-image"><div role="button" tabindex="0" class="jv jw di jx bf jy"><div class="fe ff jp"><img src="../Images/e2d2d89338501848a97e99c5ea35f52e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NDdfYjo_sjoWngSCHY1fCQ.png"/></div></div></figure><p id="f674" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这些操作是在没有完全加载块的情况下执行的。哈希树简化了计算，允许轻量级客户端在个人电脑、笔记本电脑和智能手机上运行。</p><p id="ab33" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">以太坊的交易数据处理算法类似于比特币。与状态树交互更加困难。数组元素的键表示用户的地址，其值表示帐户余额。</p><p id="f2cd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">散列树需要频繁的数据更新以及地址的添加和删除。该算法的实现需要一个可变的结构。它的参数受到限制，以防止DDoS攻击，这种攻击允许攻击者创建非常深的树。</p><p id="a862" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">否则，更新结构和执行操作将需要很长时间。</p><p id="08f9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">树根应该完全由数据决定，而不是由它的参数决定。因此，需要能够以任何顺序进行更新。</p><p id="8c21" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">您可以使用前缀树来解决这些问题。以太坊中的每个结构元素都有16个子元素。此方法最适合以十六进制格式对节点进行编码。</p><p id="716d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">要获得前缀树中的关键字，必须指定与分支对应的连续字符。它们指定了从根到所选元素的路径。键值是动态的，这意味着您可以随时添加或删除新节点。</p><blockquote class="lu lv lw"><p id="a43c" class="iq ir jo is b it iu iv iw ix iy iz ja lx jc jd je ly jg jh ji lz jk jl jm jn hm dt translated">如果您对Merkle tree主题有任何补充，欢迎发表评论！<br/>在跟踪更新方面，订阅我们的<a class="ae le" href="https://medium.com/sunflowercorporation" rel="noopener"> Medium feed。</a></p><p id="e822" class="iq ir jo is b it iu iv iw ix iy iz ja lx jc jd je ly jg jh ji lz jk jl jm jn hm dt translated">敬请期待！</p></blockquote><blockquote class="ma"><p id="04bc" class="mb mc ht bd md me mf mg mh mi mj jn ek translated">交易新手？试试<a class="ae le" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a>或者<a class="ae le" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>