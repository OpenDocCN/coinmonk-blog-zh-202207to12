<html>
<head>
<title>Chewing the Solidity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">咀嚼坚实</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/chewing-the-solidity-a3a1cdfbca6?source=collection_archive---------27-----------------------#2022-07-09">https://medium.com/coinmonks/chewing-the-solidity-a3a1cdfbca6?source=collection_archive---------27-----------------------#2022-07-09</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="4424" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">继续我们的区块链系列，这是坚实基础的第一部分。<br/> <strong class="is hu"> <em class="jo">合同支付{ <br/>函数支付者()公共应付{ <br/> }} </em> </strong></p><p id="45a9" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">上面的代码片段是发送一些加密支付到一个特定的地址，但它似乎是一种外来的语言。没有吗？为了更好地理解这一点，让我们深入了解关于坚固的一切。Solidity是一种高级静态类型的区分大小写的编程语言。</p><h2 id="3051" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj dt translated">混合IDE</h2><p id="5e73" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hm dt translated">像其他编程语言一样，我们需要一个IDE来编写和编译Solidity。通常，我们使用Remix。<br/>remix是用于开发、部署和管理的开源IDE。它支持Solidity和Vyper。混音是基于javascript编码和构建的。</p><h2 id="fc53" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj dt translated">智能合同编制</h2><p id="6e36" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hm dt translated">每个智能合约都有一个带<strong class="is hu">的源文件。sol </strong>作为扩展。它在Solidity编译器上编译。有两个组成部分与之相关- ABI和字节码。<br/>计算机科学上下文中的ABI(应用程序二进制接口)是两个程序模块之间的接口，通常是操作系统和用户程序之间的接口。<br/>而字节码是被解析、编译、包含的实际代码。它包含与blocks模块相关的程序、合同和文件的基本信息。<br/>关于ABI和字节码的具体信息-</p><ul class=""><li id="bffa" class="kp kq ht is b it iu ix iy jb kr jf ks jj kt jn ku kv kw kx dt translated">契约字节码是可读形式的公共代码，</li><li id="7fa8" class="kp kq ht is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx dt translated">契约不必是公开的，</li><li id="cd7a" class="kp kq ht is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx dt translated">字节码是不可变的，</li><li id="8685" class="kp kq ht is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx dt translated">ABI充当应用程序和智能合约之间的桥梁，</li><li id="b339" class="kp kq ht is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx dt translated">没有源代码就无法生成ABI和字节码。</li></ul><p id="d291" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，让我们开始关于可靠性的实际编码工作。是时候弄脏我们的手了…</p><p id="ca25" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在开始编程代码之前，我们必须初始化许可证细节，这些细节将在编译时进行验证。<br/><strong class="is hu"><em class="jo">SPDX-License-Identifier:GPL-3.0<br/></em></strong>现在第二行要讲的是solidity版本。<strong class="is hu"> <em class="jo"> <br/> pragma实度≥0 . 7 . 0&lt;0 . 9 . 0；<br/> </em> </strong>以上语法表示我们使用的是任何大于等于0.7.0且低于0.9.0的Solidity版本。一旦我们在solidity程序文件的顶部指明了这两条信息，我们就可以开始我们面向目标的编程语法了。</p><h2 id="1e22" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj dt translated">构造器</h2><p id="0266" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hm dt translated">Constructor是Solidity中使用的保留关键字，用于创建更像“object”的新实例。构造函数是任何给定的Solidity编程语言中最重要的部分。一个构造者的一些重要特征是-</p><ul class=""><li id="c795" class="kp kq ht is b it iu ix iy jb kr jf ks jj kt jn ku kv kw kx dt translated">它只执行一次，</li><li id="3ca4" class="kp kq ht is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx dt translated">在一个solidity程序中，我们只能创建一个构造函数，</li><li id="9c7e" class="kp kq ht is b it ky ix kz jb la jf lb jj lc jn ku kv kw kx dt translated">如果没有显式定义的构造函数，编译器会创建一个默认的构造函数。</li></ul><blockquote class="ld le lf"><p id="bf26" class="iq ir jo is b it iu iv iw ix iy iz ja lg jc jd je lh jg jh ji li jk jl jm jn hm dt translated">交易新手？试试<a class="ae lj" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或者<a class="ae lj" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote><h2 id="3e4d" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj dt translated"><strong class="ak">Solidity中的数据类型</strong></h2><p id="4110" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hm dt translated">像其他编程语言一样，Solidity也有一些默认的数据类型- <em class="jo"> Boolean、unit、int、address、bytes和string。</em></p><h2 id="1e0f" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj dt translated"><em class="lk">整数</em></h2><p id="c648" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hm dt translated">我们用两个关键字来表示整数——int，unit。int用于有符号整数，unit用于无符号整数。<br/> int的范围是从int8到int256，其中每增加一步，对应的大小为8。对于uint也是如此，即范围从uint8到uint256。<br/>默认情况下，int和unit都是256。两者的默认值都是0。</p><h2 id="1b08" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj dt translated">排列</h2><p id="4883" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hm dt translated">数组用于存储数据、值等，数组有两种类型:静态和动态。<br/>动态数组的大小在初始化时是不固定的，静态数组也是如此。<br/><strong class="is hu"><em class="jo">uint[]public arr；</em> </strong> —这表示一个动态数组，因为我们声明了一个数组，但没有绑定它的大小。<br/>While<strong class="is hu"><em class="jo">uint[4]public arr =[1，2，3，4]；</em> </strong> <em class="jo"> —它</em>是静态数组，因为我们在声明它的时候附加了关于数组大小的信息。</p><h2 id="3bd0" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj dt translated">布尔代数学体系的</h2><p id="554f" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hm dt translated">布尔仅用于存储<strong class="is hu">真</strong>或<strong class="is hu">假</strong>。</p><h2 id="80f8" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj dt translated">结构</h2><p id="fe32" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hm dt translated">该结构是一种复杂的数据类型，它是在基本数据类型的帮助下形成的。<br/>结构可以在构造内部或外部声明。在外部声明它意味着它可以被多个契约访问。<br/> <strong class="is hu">例- </strong> <br/>结构学校{ <br/> uint卷；<br/>字符串名称；<br/> }</p><h2 id="9640" class="jp jq ht bd jr js jt ju jv jw jx jy jz jb ka kb kc jf kd ke kf jj kg kh ki kj dt translated">列举型别</h2><p id="30af" class="pw-post-body-paragraph iq ir ht is b it kk iv iw ix kl iz ja jb km jd je jf kn jh ji jj ko jl jm jn hm dt translated">当我们给某个常数/数指定一个特定的名字时，它就被称为枚举。<br/> <strong class="is hu">示例- <br/> </strong>构造状态{ <br/>枚举学生{已注册，未_注册，已列入等待列表} <br/>学生公共学生_ 1 =学生.未_注册；<br/>}<strong class="is hu"><br/></strong>student _ 1的打印值会给出1作为结果，因为枚举是从0开始的。</p><p id="0df7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这些是与Solidity编程语言相关的基础知识。为了能够在solidity中编码和编写我们的第一个智能合同，我将再分享一篇文章，这基本上是Solidity基础的第二部分，题为“消化Solidity”。感谢你的时间，直到下一个博客，让我们继续链接块！</p></div></div>    
</body>
</html>