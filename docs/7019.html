<html>
<head>
<title>The Ultimate Guide to Learn Solidity</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习稳健的终极指南</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/the-key-is-solidity-f7d96ea30fd6?source=collection_archive---------1-----------------------#2022-12-03">https://medium.com/coinmonks/the-key-is-solidity-f7d96ea30fd6?source=collection_archive---------1-----------------------#2022-12-03</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><div class=""><h2 id="dfc5" class="pw-subtitle-paragraph iq hs ht bd b ir is it iu iv iw ix iy iz ja jb jc jd je jf jg jh ek translated">一个博客中的语言信息</h2></div><figure class="jj jk jl jm fq jn fe ff paragraph-image"><div role="button" tabindex="0" class="jo jp di jq bf jr"><div class="fe ff ji"><img src="../Images/97a4ff5a1d423cce57135ab4937fb3ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nmIPWO8eAL-bu4LzZufu3Q.png"/></div></div><figcaption class="ju jv fg fe ff jw jx bd b be z ek">solidity cheatsheet:</figcaption></figure></div><div class="ab cl jy jz hb ka" role="separator"><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd ke"/><span class="kb bw bk kc kd"/></div><div class="hm hn ho hp hq"><h1 id="b997" class="kf kg ht bd kh ki kj kk kl km kn ko kp iz kq ja kr jc ks jd kt jf ku jg kv kw dt translated">固态</h1><p id="f728" class="pw-post-body-paragraph kx ky ht kz b la lb iu lc ld le ix lf lg lh li lj lk ll lm ln lo lp lq lr ls hm dt translated">Solidity是一种高级的、面向契约的编程语言，用于编写运行在以太坊平台上的智能契约。Solidity是专门为在Ethereum平台上编写智能合同而开发的，旨在便于具有面向对象编程语言经验的开发人员学习和使用。</p><p id="0b0d" class="pw-post-body-paragraph kx ky ht kz b la lt iu lc ld lu ix lf lg lv li lj lk lw lm ln lo lx lq lr ls hm dt translated">简单来说，Solidity允许开发人员编写在以太坊区块链上运行的自动执行合同。这些合同可用于创建可在以太坊网络上运行的分散式应用程序(DApps ),允许用户与区块链进行交互，并安全地存储和传输数字资产。</p><p id="f1fe" class="pw-post-body-paragraph kx ky ht kz b la lt iu lc ld lu ix lf lg lv li lj lk lw lm ln lo lx lq lr ls hm dt translated">Solidity是一种静态类型语言，这意味着变量类型必须在使用之前声明。它支持各种数据类型，包括整数、布尔值和字符串，以及复杂的数据结构，如数组和映射。Solidity还包括对继承的支持，允许开发人员创建复杂的、模块化的、易于扩展和修改的契约。</p><h2 id="ae3d" class="ly kg ht bd kh lz ma mb kl mc md me kp lg mf mg kr lk mh mi kt lo mj mk kv ml dt translated">坚实度变量:</h2><p id="158d" class="pw-post-body-paragraph kx ky ht kz b la lb iu lc ld le ix lf lg lh li lj lk ll lm ln lo lp lq lr ls hm dt translated">在Solidity编程语言中，变量用于存储可以在合同中使用的数据值。Solidity是一种静态类型的语言，这意味着变量在使用之前必须用特定的类型声明。</p><p id="465c" class="pw-post-body-paragraph kx ky ht kz b la lt iu lc ld lu ix lf lg lv li lj lk lw lm ln lo lx lq lr ls hm dt translated">有几种不同类型的变量可用于实度，包括:</p><ul class=""><li id="6edb" class="mm mn ht kz b la lt ld lu lg mo lk mp lo mq ls mr ms mt mu dt translated"><code class="eh mv mw mx my b">bool</code>:该类型代表一个布尔值(真或假)。</li><li id="4a42" class="mm mn ht kz b la mz ld na lg nb lk nc lo nd ls mr ms mt mu dt translated"><code class="eh mv mw mx my b">int</code>和<code class="eh mv mw mx my b">uint</code>:这些类型分别表示有符号和无符号整数。整数的大小(8位、16位等。声明变量时必须指定)。</li><li id="a3ee" class="mm mn ht kz b la mz ld na lg nb lk nc lo nd ls mr ms mt mu dt translated"><code class="eh mv mw mx my b">address</code>:此类型代表以太坊地址。</li><li id="eda4" class="mm mn ht kz b la mz ld na lg nb lk nc lo nd ls mr ms mt mu dt translated"><code class="eh mv mw mx my b">bytes</code>:这个类型代表一个字节序列。在声明变量时，必须指定字节的大小。</li><li id="ad9c" class="mm mn ht kz b la mz ld na lg nb lk nc lo nd ls mr ms mt mu dt translated"><code class="eh mv mw mx my b">string</code>:这个类型表示一串Unicode字符。</li></ul><p id="25a1" class="pw-post-body-paragraph kx ky ht kz b la lt iu lc ld lu ix lf lg lv li lj lk lw lm ln lo lx lq lr ls hm dt translated">下面是一个在Solidity中声明和初始化一些变量的例子:</p><pre class="jj jk jl jm fq ne my nf bn ng nh bi"><span id="4e01" class="ni kg ht my b be nj nk l nl nm">bool success = true;<br/>int8 number = -5;<br/>uint256 count = 100;<br/>address owner = 0x1234567890abcdef;<br/>bytes32 data = 0xabcdef0123456789abcdef0123456789;<br/>string message = "Hello, world!";</span></pre><p id="5d3d" class="pw-post-body-paragraph kx ky ht kz b la lt iu lc ld lu ix lf lg lv li lj lk lw lm ln lo lx lq lr ls hm dt translated">用不同的数据类型声明和初始化了六个变量。<code class="eh mv mw mx my b">success</code>变量是布尔值，<code class="eh mv mw mx my b">number</code>变量是有符号的8位整数，<code class="eh mv mw mx my b">count</code>变量是无符号的256位整数，<code class="eh mv mw mx my b">owner</code>变量是以太坊地址，<code class="eh mv mw mx my b">data</code>变量是32字节的序列，<code class="eh mv mw mx my b">message</code>变量是字符串。</p><p id="c6fa" class="pw-post-body-paragraph kx ky ht kz b la lt iu lc ld lu ix lf lg lv li lj lk lw lm ln lo lx lq lr ls hm dt translated">总的来说，变量是Solidity中编程的重要组成部分。它们允许开发人员在契约中存储和操作数据，使得在以太坊平台上构建复杂的动态应用程序成为可能。</p><h2 id="2687" class="ly kg ht bd kh lz ma mb kl mc md me kp lg mf mg kr lk mh mi kt lo mj mk kv ml dt translated">固态字节</h2><p id="d8b4" class="pw-post-body-paragraph kx ky ht kz b la lb iu lc ld le ix lf lg lh li lj lk ll lm ln lo lp lq lr ls hm dt translated"><code class="eh mv mw mx my b">bytes</code>数据类型类似于<code class="eh mv mw mx my b">string</code>数据类型，但与使用特定字符编码(如ASCII或UTF-8)进行编码的字符串不同，<code class="eh mv mw mx my b">bytes</code>数据类型是一个原始的字节序列，没有特定的编码。</p><p id="d040" class="pw-post-body-paragraph kx ky ht kz b la lt iu lc ld lu ix lf lg lv li lj lk lw lm ln lo lx lq lr ls hm dt translated">要声明一个数据类型为<code class="eh mv mw mx my b">bytes</code>的变量，可以使用<code class="eh mv mw mx my b">bytes</code>关键字，后跟变量名，如下所示:</p><pre class="jj jk jl jm fq ne my nf bn ng nh bi"><span id="001f" class="ni kg ht my b be nj nk l nl nm">bytes myBytes;</span></pre><p id="ec06" class="pw-post-body-paragraph kx ky ht kz b la lt iu lc ld lu ix lf lg lv li lj lk lw lm ln lo lx lq lr ls hm dt translated">您还可以使用<code class="eh mv mw mx my b">bytesN</code>语法指定字节数组的长度，其中<code class="eh mv mw mx my b">N</code>是字节数组的长度，以字节为单位。例如:</p><pre class="jj jk jl jm fq ne my nf bn ng nh bi"><span id="8274" class="ni kg ht my b be nj nk l nl nm">bytes32 myBytes32; // Declares a byte array with 32 bytes</span></pre><p id="438b" class="pw-post-body-paragraph kx ky ht kz b la lt iu lc ld lu ix lf lg lv li lj lk lw lm ln lo lx lq lr ls hm dt translated">一旦声明了一个<code class="eh mv mw mx my b">bytes</code>变量，就可以使用<code class="eh mv mw mx my b">hex</code>关键字给它赋值，后跟字节数组的十六进制表示。例如:</p><pre class="jj jk jl jm fq ne my nf bn ng nh bi"><span id="6639" class="ni kg ht my b be nj nk l nl nm">myBytes = hex"01020304"; // Assigns the byte array [0x01, 0x02, 0x03, 0x04] to myBytes</span></pre><p id="16f2" class="pw-post-body-paragraph kx ky ht kz b la lt iu lc ld lu ix lf lg lv li lj lk lw lm ln lo lx lq lr ls hm dt translated">除了<code class="eh mv mw mx my b">hex</code>关键字之外，<code class="eh mv mw mx my b">bytes</code>数据类型还支持<code class="eh mv mw mx my b">abi.encode</code>和<code class="eh mv mw mx my b">abi.encodePacked</code>函数，这些函数可用于将数据编码为特定格式，以便在函数调用或其他上下文中使用。</p><h2 id="dd68" class="ly kg ht bd kh lz ma mb kl mc md me kp lg mf mg kr lk mh mi kt lo mj mk kv ml dt translated">消息发送者和消息值</h2><p id="b026" class="pw-post-body-paragraph kx ky ht kz b la lb iu lc ld le ix lf lg lh li lj lk ll lm ln lo lp lq lr ls hm dt translated"><code class="eh mv mw mx my b">msg.sender</code>指调用当前函数的账户地址。例如，这可以用于确定呼叫者的身份或实现访问控制检查。</p><p id="6ccc" class="pw-post-body-paragraph kx ky ht kz b la lt iu lc ld lu ix lf lg lv li lj lk lw lm ln lo lx lq lr ls hm dt translated"><code class="eh mv mw mx my b">msg.value</code>指事务的值，在魏，即调用当前函数。这可用于检查随交易发送的乙醚量，或将金额转移到另一个账户。</p><p id="5c07" class="pw-post-body-paragraph kx ky ht kz b la lt iu lc ld lu ix lf lg lv li lj lk lw lm ln lo lx lq lr ls hm dt translated">以下是如何在可靠性合同中使用<code class="eh mv mw mx my b">msg.sender</code>和<code class="eh mv mw mx my b">msg.value</code>的示例:</p><pre class="jj jk jl jm fq ne my nn no aw np dt"><span id="cbfd" class="ly kg ht my b fv nq nr l ns nm">contract ExampleContract {<br/>    // Store the address of the contract owner<br/>    address public owner;</span><span id="c56f" class="ly kg ht my b fv nt nr l ns nm">    constructor() public {<br/>        // Set the contract owner to the caller of the constructor<br/>        owner = msg.sender;<br/>    }</span><span id="c7a9" class="ly kg ht my b fv nt nr l ns nm">    function withdrawFunds(uint amount) public {<br/>        // Check that the caller is the contract owner<br/>        require(msg.sender == owner, "Only the contract owner can withdraw funds");</span><span id="2989" class="ly kg ht my b fv nt nr l ns nm">        // Check that the caller sent at least the amount they are trying to withdraw<br/>        require(msg.value &gt;= amount, "Insufficient funds");</span><span id="daec" class="ly kg ht my b fv nt nr l ns nm">        // Transfer the amount to the caller<br/>        msg.sender.transfer(amount);<br/>    }<br/>}</span></pre><p id="fcdb" class="pw-post-body-paragraph kx ky ht kz b la lt iu lc ld lu ix lf lg lv li lj lk lw lm ln lo lx lq lr ls hm dt translated"><code class="eh mv mw mx my b">withdrawFunds</code>函数使用<code class="eh mv mw mx my b">msg.sender</code>检查调用者是否是合同所有者，并使用<code class="eh mv mw mx my b">msg.value</code>检查调用者是否至少发送了他们试图提取的金额。如果检查通过，该功能使用<code class="eh mv mw mx my b">msg.sender.transfer</code>将指定数量的乙醚转移给调用者。</p><p id="70b1" class="pw-post-body-paragraph kx ky ht kz b la lt iu lc ld lu ix lf lg lv li lj lk lw lm ln lo lx lq lr ls hm dt translated"><code class="eh mv mw mx my b">msg.sender</code>和<code class="eh mv mw mx my b">msg.value</code>是有用的内置变量，它们提供关于调用Solidity契约中当前函数的事务或消息的信息。它们可用于实现访问控制检查、传输值等等。</p><h2 id="8448" class="ly kg ht bd kh lz ma mb kl mc md me kp lg mf mg kr lk mh mi kt lo mj mk kv ml dt translated">固体中的函数</h2><p id="a96a" class="pw-post-body-paragraph kx ky ht kz b la lb iu lc ld le ix lf lg lh li lj lk ll lm ln lo lp lq lr ls hm dt translated">Solidity中的函数具有以下通用语法:</p><pre class="jj jk jl jm fq ne my nf bn ng nh bi"><span id="ff78" class="ni kg ht my b be nj nk l nl nm">function functionName(parameter1, parameter2, ...) visibility_modifier returns (return_type1, return_type2, ...) {<br/>    // Function body<br/>}</span></pre><p id="43d2" class="pw-post-body-paragraph kx ky ht kz b la lt iu lc ld lu ix lf lg lv li lj lk lw lm ln lo lx lq lr ls hm dt translated">这里，<code class="eh mv mw mx my b">functionName</code>是函数的名字，<code class="eh mv mw mx my b">parameter1</code>，<code class="eh mv mw mx my b">parameter2</code>等。是函数的参数，<code class="eh mv mw mx my b">visibility_modifier</code>是决定函数是公有还是私有的关键字，<code class="eh mv mw mx my b">return_type1</code>，<code class="eh mv mw mx my b">return_type2</code>等。是函数返回值的类型。</p><p id="9bb8" class="pw-post-body-paragraph kx ky ht kz b la lt iu lc ld lu ix lf lg lv li lj lk lw lm ln lo lx lq lr ls hm dt translated">例如，下面的代码定义了一个名为<code class="eh mv mw mx my b">addNumbers</code>的公共函数，它采用两个<code class="eh mv mw mx my b">uint</code>(无符号整数)参数并返回一个<code class="eh mv mw mx my b">uint</code>值:</p><pre class="jj jk jl jm fq ne my nf bn ng nh bi"><span id="852d" class="ni kg ht my b be nj nk l nl nm">function addNumbers(uint a, uint b) public returns (uint) {<br/>    return a + b;<br/>}</span></pre><p id="7c04" class="pw-post-body-paragraph kx ky ht kz b la lt iu lc ld lu ix lf lg lv li lj lk lw lm ln lo lx lq lr ls hm dt translated">可以使用<code class="eh mv mw mx my b">functionName(arg1, arg2, ...)</code>语法从契约内部调用函数，或者通过向契约地址发送事务从契约外部调用函数。</p><p id="29cc" class="pw-post-body-paragraph kx ky ht kz b la lt iu lc ld lu ix lf lg lv li lj lk lw lm ln lo lx lq lr ls hm dt translated">修饰符应用于使用<code class="eh mv mw mx my b">modifier</code>关键字的函数，并可用于实现访问控制、参数验证和其他功能。</p><h2 id="f935" class="ly kg ht bd kh lz ma mb kl mc md me kp lg mf mg kr lk mh mi kt lo mj mk kv ml dt translated">坚实中的继承</h2><p id="1155" class="pw-post-body-paragraph kx ky ht kz b la lb iu lc ld le ix lf lg lh li lj lk ll lm ln lo lp lq lr ls hm dt translated">继承是有用的，因为它允许开发人员创建复杂的、模块化的、易于扩展和修改的契约。派生协定可以简单地继承基础协定的代码和行为，并根据需要添加自己的自定义内容，而不是将代码从一个协定复制并粘贴到另一个协定。</p><p id="195d" class="pw-post-body-paragraph kx ky ht kz b la lt iu lc ld lu ix lf lg lv li lj lk lw lm ln lo lx lq lr ls hm dt translated">为了在Solidity中实现继承，在派生契约中使用了<code class="eh mv mw mx my b">is</code>关键字来指定它所继承的基础契约。例如:</p><pre class="jj jk jl jm fq ne my nf bn ng nh bi"><span id="730d" class="ni kg ht my b be nj nk l nl nm">contract BaseContract {<br/>    // Code and behavior defined in the base contract<br/>}<br/><br/>contract DerivedContract is BaseContract {<br/>    // Code and behavior defined in the derived contract, which<br/>    // inherits from the base contract<br/>}</span></pre><p id="a794" class="pw-post-body-paragraph kx ky ht kz b la lt iu lc ld lu ix lf lg lv li lj lk lw lm ln lo lx lq lr ls hm dt translated">在这个例子中，<code class="eh mv mw mx my b">DerivedContract</code>契约继承了<code class="eh mv mw mx my b">BaseContract</code>契约。这意味着<code class="eh mv mw mx my b">DerivedContract</code>契约可以访问<code class="eh mv mw mx my b">BaseContract</code>契约中定义的所有代码和行为，以及它自己定义的任何代码和行为。</p><h2 id="7f0f" class="ly kg ht bd kh lz ma mb kl mc md me kp lg mf mg kr lk mh mi kt lo mj mk kv ml dt translated">可变能见度</h2><p id="9b03" class="pw-post-body-paragraph kx ky ht kz b la lb iu lc ld le ix lf lg lh li lj lk ll lm ln lo lp lq lr ls hm dt translated">从契约外部可以看到一个<code class="eh mv mw mx my b">public</code>变量，可以通过调用契约的公共函数来访问它。例如:</p><pre class="jj jk jl jm fq ne my nf bn ng nh bi"><span id="fc28" class="ni kg ht my b be nj nk l nl nm">contract ExampleContract {<br/>    // Public variable<br/>    uint public variable;<br/><br/>    function setVariable(uint value) public {<br/>        variable = value;<br/>    }<br/><br/>    function getVariable() public view returns (uint) {<br/>        return variable;<br/>    }<br/>}</span></pre><p id="a7c9" class="pw-post-body-paragraph kx ky ht kz b la lt iu lc ld lu ix lf lg lv li lj lk lw lm ln lo lx lq lr ls hm dt translated"><code class="eh mv mw mx my b">variable</code>变量被标记为<code class="eh mv mw mx my b">public</code>，这意味着可以从契约外部访问它。<code class="eh mv mw mx my b">setVariable</code>函数允许将<code class="eh mv mw mx my b">variable</code>设置为新值，<code class="eh mv mw mx my b">getVariable</code>函数允许通过调用合同的公共函数来读取<code class="eh mv mw mx my b">variable</code>。</p><p id="9e0b" class="pw-post-body-paragraph kx ky ht kz b la lt iu lc ld lu ix lf lg lv li lj lk lw lm ln lo lx lq lr ls hm dt translated">另一方面，<code class="eh mv mw mx my b">private</code>变量在契约外部是不可见的，只能在契约内部访问。例如:</p><pre class="jj jk jl jm fq ne my nf bn ng nh bi"><span id="0bd9" class="ni kg ht my b be nj nk l nl nm">contract ExampleContract {<br/>    // Private variable<br/>    uint private variable;<br/><br/>    function setVariable(uint value) public {<br/>        variable = value;<br/>    }<br/><br/>    function getVariable() public view returns (uint) {<br/>        // Access the private variable within the contract<br/>        return variable;<br/>    }<br/>}</span></pre><p id="e9db" class="pw-post-body-paragraph kx ky ht kz b la lt iu lc ld lu ix lf lg lv li lj lk lw lm ln lo lx lq lr ls hm dt translated"><code class="eh mv mw mx my b">variable</code>变量被标记为<code class="eh mv mw mx my b">private</code>，这意味着它只能从契约内部访问。<code class="eh mv mw mx my b">setVariable</code>函数仍然可以将<code class="eh mv mw mx my b">variable</code>设置为新值，但是<code class="eh mv mw mx my b">getVariable</code>函数不能将<code class="eh mv mw mx my b">variable</code>值返回给调用者，因为它被标记为<code class="eh mv mw mx my b">private.</code></p><p id="c209" class="pw-post-body-paragraph kx ky ht kz b la lt iu lc ld lu ix lf lg lv li lj lk lw lm ln lo lx lq lr ls hm dt translated">谢谢你们</p><p id="5b5e" class="pw-post-body-paragraph kx ky ht kz b la lt iu lc ld lu ix lf lg lv li lj lk lw lm ln lo lx lq lr ls hm dt translated">在Twitter上关注我:<a class="ae nu" href="https://twitter.com/Param_eth" rel="noopener ugc nofollow" target="_blank"> @Param_eth </a></p><blockquote class="nv"><p id="026f" class="nw nx ht bd ny nz oa ob oc od oe ls ek translated">交易新手？尝试<a class="ae nu" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae nu" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p><p id="6448" class="nw nx ht bd ny nz oa ob oc od oe ls ek translated">加入Coinmonks <a class="ae nu" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae nu" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>获取每日<a class="ae nu" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank">加密新闻</a></p></blockquote><h1 id="f3a4" class="kf kg ht bd kh ki of kk kl km og ko kp iz oh ja kr jc oi jd kt jf oj jg kv kw dt translated">另外，阅读</h1><ul class=""><li id="8c0e" class="mm mn ht kz b la lb ld le lg ok lk ol lo om ls mr ms mt mu dt translated"><a class="ae nu" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a> | <a class="ae nu" rel="noopener" href="/coinmonks/crypto-tax-software-ed4b4810e338">加密税务软件</a></li><li id="719e" class="mm mn ht kz b la mz ld na lg nb lk nc lo nd ls mr ms mt mu dt translated"><a class="ae nu" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">网格交易</a> | <a class="ae nu" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">加密硬件钱包</a></li><li id="0501" class="mm mn ht kz b la mz ld na lg nb lk nc lo nd ls mr ms mt mu dt translated"><a class="ae nu" rel="noopener" href="/coinmonks/top-3-telegram-channels-for-crypto-traders-in-2021-8385f4411ff4">密码电报信号</a> | <a class="ae nu" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="fc73" class="mm mn ht kz b la mz ld na lg nb lk nc lo nd ls mr ms mt mu dt translated"><a class="ae nu" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a> | <a class="ae nu" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度最佳加密交易所</a></li><li id="74a1" class="mm mn ht kz b la mz ld na lg nb lk nc lo nd ls mr ms mt mu dt translated"><a class="ae nu" rel="noopener" href="/coinmonks/best-crypto-apis-for-developers-5efe3a597a9f">开发者最佳加密API</a></li><li id="973f" class="mm mn ht kz b la mz ld na lg nb lk nc lo nd ls mr ms mt mu dt translated">最佳<a class="ae nu" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">密码借贷平台</a></li><li id="0352" class="mm mn ht kz b la mz ld na lg nb lk nc lo nd ls mr ms mt mu dt translated"><a class="ae nu" rel="noopener" href="/coinmonks/free-crypto-signals-48b25e61a8da">免费加密信号</a> | <a class="ae nu" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a></li><li id="a5ef" class="mm mn ht kz b la mz ld na lg nb lk nc lo nd ls mr ms mt mu dt translated">杠杆代币的终极指南</li></ul></div></div>    
</body>
</html>