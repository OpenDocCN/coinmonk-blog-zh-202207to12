<html>
<head>
<title>CSC School:CRC Interface #10</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CSC学校:CRC接口#10</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/csc-school-crc-interface-10-dbc771fad7b9?source=collection_archive---------50-----------------------#2022-12-29">https://medium.com/coinmonks/csc-school-crc-interface-10-dbc771fad7b9?source=collection_archive---------50-----------------------#2022-12-29</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="70e7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们现在已经熟悉了CRC标准，但是我们如何使用Solidity来实现CRC标准呢？</p><p id="b6c0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在本部分中，我们将了解CRC标准的接口。</p><blockquote class="jo"><p id="12c2" class="jp jq ht bd jr js jt ju jv jw jx jn ek translated">交易新手？试试<a class="ae jy" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a>或者<a class="ae jy" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">在<a class="ae jy" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最好的密码交易所</a>上复制交易</a></p></blockquote><h2 id="b395" class="jz ka ht bd kb kc kd ke kf kg kh ki kj jb kk kl km jf kn ko kp jj kq kr ks kt dt translated">CRC-20</h2><p id="1b53" class="pw-post-body-paragraph iq ir ht is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hm dt translated">下面是CRC20的基本界面，描述了CRC20合同的功能和事件签名，并对每个给定的功能进行了说明:</p><pre class="kz la lb lc fq ld le lf bn lg lh bi"><span id="ed1e" class="li ka ht le b be lj lk l ll lm">contract CRC20 {<br/>event Transfer(<br/>address indexed from,<br/>address indexed to,<br/>uint256 value<br/>);<br/>event Approval(<br/>address indexed owner,<br/>address indexed spender,<br/>uint256 value<br/>); function totalSupply() public view returns(uint256);<br/>function balanceOf(address who) public view returns(uint256);<br/>function transfer(address to, uint256 value) public returns(bool);<br/>function allowance(address owner, address spender)<br/>public view returns (uint256);<br/>function transferFrom(address from, address to, uint256 value)<br/>public returns (bool);<br/>function approve(address spender, uint256 value)<br/>public returns (bool);<br/>}</span></pre><p id="332f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">以下是CRC-20智能合同接口的功能和组件。</p><h2 id="a889" class="jz ka ht bd kb kc ln ke kf kg lo ki kj jb lp kl km jf lq ko kp jj lr kr ks kt dt translated">总供应量</h2><p id="4634" class="pw-post-body-paragraph iq ir ht is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hm dt translated">功能<strong class="is hu"> totalSupply </strong>是公共的，因此所有人都可以访问。它显示当前流通的令牌总数。由于此<strong class="is hu"> totalSupply </strong>功能标有视图修改器，因此它不会消耗气体。此外，每当铸造新的令牌时，它都会更新内部令牌值totalSupply。</p><pre class="kz la lb lc fq ld le lf bn lg lh bi"><span id="a494" class="li ka ht le b be lj lk l ll lm">// its value is increased when new tokens are minted<br/>uint256 totalSupply_;// access the value of totalSupply_<br/>function totalSupply() public view returns (uint256) {<br/>return totalSupply_;<br/>}</span></pre><h2 id="46d5" class="jz ka ht bd kb kc ln ke kf kg lo ki kj jb lp kl km jf lq ko kp jj lr kr ks kt dt translated">平衡f</h2><p id="4115" class="pw-post-body-paragraph iq ir ht is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hm dt translated"><strong class="is hu"> balanceOf </strong>是另一个公共视图修改器，它让每个人都可以访问它，并且是无气体的。它获取CSC地址，并将令牌返回到分配的地址。</p><pre class="kz la lb lc fq ld le lf bn lg lh bi"><span id="fe6f" class="li ka ht le b be lj lk l ll lm">// Updated when tokens are minted or transferred<br/>mapping(address =&gt; uint256) balances;// Returns tokens held by the address passed as _owner<br/>function balanceOf(address _owner)<br/>public view returns (uint256 balance) {<br/>return balances[_owner];<br/>}</span></pre><h2 id="64c0" class="jz ka ht bd kb kc ln ke kf kg lo ki kj jb lp kl km jf lq ko kp jj lr kr ks kt dt translated">转移</h2><p id="2e4e" class="pw-post-body-paragraph iq ir ht is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hm dt translated">功能<strong class="is hu">转移</strong>不同于上述两个功能，因为它需要fas，因此导致CSC智能合同发生重大变化。应相应令牌持有者的请求，它将令牌从一个地址传输到另一个地址。</p><pre class="kz la lb lc fq ld le lf bn lg lh bi"><span id="60eb" class="li ka ht le b be lj lk l ll lm">function transfer(address _to, uint256 _value)<br/>public returns (bool) { // Check for blank addresses<br/>require(_to != address(0)); // Check to ensure valid transfer<br/>require(_value &lt;= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance.<br/>balances[msg.sender] = balances[msg.sender].sub(_value);<br/>balances[_to] = balances[_to].add(_value);<br/>// Event transfer defined in the CRC 20 interface above<br/>Transfer(msg.sender, _to, _value); return true;<br/>}</span></pre><h2 id="11d9" class="jz ka ht bd kb kc ln ke kf kg lo ki kj jb lp kl km jf lq ko kp jj lr kr ks kt dt translated">津贴、批准和调动自</h2><p id="a760" class="pw-post-body-paragraph iq ir ht is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hm dt translated">最后一个功能允许、批准和转移来自支持高级功能，如授权其他地址代表各自持有者使用令牌。</p><h2 id="6021" class="jz ka ht bd kb kc ln ke kf kg lo ki kj jb lp kl km jf lq ko kp jj lr kr ks kt dt translated">CRC-721</h2><p id="3322" class="pw-post-body-paragraph iq ir ht is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hm dt translated">为了了解CRC-721是如何工作的，让我们看看它在这里添加的接口:</p><pre class="kz la lb lc fq ld le lf bn lg lh bi"><span id="e914" class="li ka ht le b be lj lk l ll lm">contract CRC721 {<br/>event Transfer(<br/>address indexed _from,<br/>address indexed _to,<br/>uint256 _tokenId<br/>); event Approval(<br/>address indexed _owner,<br/>address indexed _approved,<br/>uint256 _tokenId<br/>); function balanceOf(address _owner)<br/>public view returns (uint256 _balance); function ownerOf(uint256 _tokenId)public view returns (address _owner); function transfer(address _to, uint256 _tokenId) public; function approve(address _to, uint256 _tokenId) public; function takeOwnership(uint256 _tokenId) public;<br/>}</span></pre><h2 id="701e" class="jz ka ht bd kb kc ln ke kf kg lo ki kj jb lp kl km jf lq ko kp jj lr kr ks kt dt translated">平衡f</h2><p id="182a" class="pw-post-body-paragraph iq ir ht is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hm dt translated">在下面的代码片段中，ownedTokens表示特定地址的令牌id的完整列表。鉴于，<strong class="is hu"> balanceOf </strong>函数返回该地址的令牌数。</p><pre class="kz la lb lc fq ld le lf bn lg lh bi"><span id="0ca1" class="li ka ht le b be lj lk l ll lm">mapping (address =&gt; uint256[]) private ownedTokens;function balanceOf(address _owner) public view returns (uint256) {<br/>return ownedTokens[_owner].length;<br/>}</span></pre><h2 id="e0c0" class="jz ka ht bd kb kc ln ke kf kg lo ki kj jb lp kl km jf lq ko kp jj lr kr ks kt dt translated">所有者</h2><p id="7662" class="pw-post-body-paragraph iq ir ht is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hm dt translated">映射令牌所有者获取令牌并输出该ID的所有者。但是，因为它的可见性被设置为私有，所以通过使用<strong class="is hu"> ownerOf </strong>函数，您可以将该映射的值设置为公共的。它还需要在返回值之前对零地址进行检查。</p><pre class="kz la lb lc fq ld le lf bn lg lh bi"><span id="3a05" class="li ka ht le b be lj lk l ll lm">mapping (uint256 =&gt; address) private tokenOwner;function ownerOf(uint256 _tokenId) public view returns (address) {<br/>address owner = tokenOwner[_tokenId];<br/>require(owner != address(0));<br/>return owner;<br/>}</span></pre><h2 id="643b" class="jz ka ht bd kb kc ln ke kf kg lo ki kj jb lp kl km jf lq ko kp jj lr kr ks kt dt translated">转移</h2><p id="f667" class="pw-post-body-paragraph iq ir ht is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hm dt translated">这个<strong class="is hu">转移</strong>函数接受新所有者的地址作为被转移令牌的<strong class="is hu"> _to </strong>参数和<strong class="is hu"> _tokenId </strong>，还要注意它只能被令牌的所有者调用。它必须包括检查转移是否通过转移所需的批准检查的逻辑。然后是从当前所有者那里删除令牌的所有权并将其添加到新所有者拥有的令牌列表中的逻辑。</p><pre class="kz la lb lc fq ld le lf bn lg lh bi"><span id="8ee2" class="li ka ht le b be lj lk l ll lm">modifier onlyOwnerOf(uint256 _tokenId) {<br/>require(ownerOf(_tokenId) == msg.sender);<br/>_;<br/>}function transfer(address _to, uint256 _tokenId)<br/>public onlyOwnerOf(_tokenId) {<br/>// Logic to clear approval for token transfer // Logic to remove token from current token owner // Logic to add Token to new token owner<br/>}</span></pre><h2 id="da13" class="jz ka ht bd kb kc ln ke kf kg lo ki kj jb lp kl km jf lq ko kp jj lr kr ks kt dt translated">赞同</h2><p id="9195" class="pw-post-body-paragraph iq ir ht is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hm dt translated"><strong class="is hu"> Approve </strong>是另一个地址声明给定令牌ID所有权的另一个函数。它受到修饰符only OwnerOf的限制，这解释了只有令牌所有者才能出于明确的原因访问该函数。</p><pre class="kz la lb lc fq ld le lf bn lg lh bi"><span id="ad8b" class="li ka ht le b be lj lk l ll lm">mapping (uint256 =&gt; address) private tokenApprovals;modifier onlyOwnerOf(uint256 _tokenId) {<br/>require(ownerOf(_tokenId) == msg.sender);<br/>_;<br/>}function approvedFor(uint256 _tokenId)<br/>public view returns (address) {<br/>return tokenApprovals[_tokenId];<br/>}function approve(address _to, uint256 _tokenId)<br/>public onlyOwnerOf(_tokenId) {<br/>address owner = ownerOf(_tokenId);<br/>require(_to != owner); if (approvedFor(_tokenId) != 0 || _to != 0) {<br/>tokenApprovals[_tokenId] = _to; // Event initialised in the interface above<br/>Approval(owner, _to, _tokenId);<br/>}<br/>}</span></pre><h2 id="1df1" class="jz ka ht bd kb kc ln ke kf kg lo ki kj jb lp kl km jf lq ko kp jj lr kr ks kt dt translated">所有权</h2><p id="ad20" class="pw-post-body-paragraph iq ir ht is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hm dt translated">函数<strong class="is hu"> takeOwnership </strong>接受_tokenId，并对消息发送者应用相同的检查。如果他通过了类似于传递函数的检查逻辑，他必须声明<strong class="is hu"> following _tokenID </strong>的所有权。</p><pre class="kz la lb lc fq ld le lf bn lg lh bi"><span id="5acd" class="li ka ht le b be lj lk l ll lm">function isApprovedFor(address _owner, uint256 _tokenId)<br/>internal view returns (bool) {<br/>return approvedFor(_tokenId) == _owner;<br/>}function takeOwnership(uint256 _tokenId) public {<br/>require(isApprovedFor(msg.sender, _tokenId)); // Logic to clear approval for token transfer // Logic to remove token from current token owner // Logic to add Token to new token owner<br/>}</span></pre><h2 id="9861" class="jz ka ht bd kb kc ln ke kf kg lo ki kj jb lp kl km jf lq ko kp jj lr kr ks kt dt translated">ERC-1155</h2><h2 id="1351" class="jz ka ht bd kb kc ln ke kf kg lo ki kj jb lp kl km jf lq ko kp jj lr kr ks kt dt translated">批量转移</h2><p id="044c" class="pw-post-body-paragraph iq ir ht is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hm dt translated">批量传输与常规CRC-20传输非常相似。让我们看看CRC-20的转移函数:</p><pre class="kz la lb lc fq ld le lf bn lg lh bi"><span id="6fa8" class="li ka ht le b be lj lk l ll lm">// CRC-20<br/>function transferFrom(address from, address to, uint256 value) external returns (bool);<br/>// CRC-1155<br/>function safeBatchTransferFrom(<br/>address _from,<br/>address _to,<br/>uint256[] calldata _ids,<br/>uint256[] calldata _values,<br/>bytes calldata _data<br/>) external;</span></pre><p id="d24f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">CRC-1155的不同之处在于将令牌值作为数组和id数组进行传递。传输结果是这样的:</p><ul class=""><li id="5dab" class="ls lt ht is b it iu ix iy jb lu jf lv jj lw jn lx ly lz ma dt translated">将200个id为5的代币从<strong class="is hu">_从</strong>转移到<strong class="is hu">_到。</strong></li><li id="5f7c" class="ls lt ht is b it mb ix mc jb md jf me jj mf jn lx ly lz ma dt translated">将300个id为7的代币从<strong class="is hu">_从</strong>转移到<strong class="is hu">_到。</strong></li><li id="e69e" class="ls lt ht is b it mb ix mc jb md jf me jj mf jn lx ly lz ma dt translated">将3个id为15的代币从<strong class="is hu">_从</strong>转移到<strong class="is hu">_到。</strong></li></ul><p id="0d22" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">除了利用CRC-1155的函数作为<strong class="is hu"> transferFrom </strong>，no transfer之外，您可以通过将表单地址设置为调用函数的地址来利用它作为常规传输。</p><h2 id="dc47" class="jz ka ht bd kb kc ln ke kf kg lo ki kj jb lp kl km jf lq ko kp jj lr kr ks kt dt translated">批量平衡</h2><p id="bd9b" class="pw-post-body-paragraph iq ir ht is b it ku iv iw ix kv iz ja jb kw jd je jf kx jh ji jj ky jl jm jn hm dt translated">相应的CRC-20 <strong class="is hu"> balanceOf </strong>调用同样具有其支持批处理的伙伴功能。提醒一下，这是CRC-20版本:</p><pre class="kz la lb lc fq ld le lf bn lg lh bi"><span id="ea6e" class="li ka ht le b be lj lk l ll lm">// CRC-20<br/>function balanceOf(address owner) external view returns (uint256);<br/>// CRC-1155<br/>function balanceOfBatch(<br/>address[] calldata _owners,<br/>uint256[] calldata _ids<br/>) external view returns (uint256[] memory);</span></pre><p id="5d35" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">对于balance调用来说更简单，我们可以在一个调用中检索多个余额。我们传递所有者数组，后面是令牌id数组。<br/>例如，给定<strong class="is hu"> _ids=[3，6，13] </strong>和<strong class="is hu"> _owners=[0xbeef…，0x1337…，0x1111…]，</strong>返回值将为</p><pre class="kz la lb lc fq ld le lf bn lg lh bi"><span id="cbd9" class="li ka ht le b be lj lk l ll lm">[balanceOf(0xbeef...),balanceOf(0x1337...),balanceOf(0x1111...)]</span></pre><h2 id="8ad9" class="jz ka ht bd kb kc ln ke kf kg lo ki kj jb lp kl km jf lq ko kp jj lr kr ks kt dt translated">批量审批</h2><pre class="kz la lb lc fq ld le lf bn lg lh bi"><span id="3470" class="li ka ht le b be lj lk l ll lm">// CRC-1155<br/>function setApprovalForAll(<br/>address _operator,<br/>bool _approved<br/>) external;<br/>function isApprovedForAll(<br/>address _owner,<br/>address _operator<br/>) external view returns (bool);</span></pre><p id="db72" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这里的批准与CRC-20略有不同。您需要使用setApprovalForAll将操作员设置为批准或未批准，而不是批准特定的金额。</p><h2 id="e78e" class="jz ka ht bd kb kc ln ke kf kg lo ki kj jb lp kl km jf lq ko kp jj lr kr ks kt dt translated">接收挂钩</h2><pre class="kz la lb lc fq ld le lf bn lg lh bi"><span id="4794" class="li ka ht le b be lj lk l ll lm">function onCRC1155BatchReceived(<br/>address _operator,<br/>address _from,<br/>uint256[] calldata _ids,<br/>uint256[] calldata _values,<br/>bytes calldata _data<br/>) external returns(bytes4);</span></pre><p id="8eba" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">CRC-1155仅支持智能合约的接收挂钩。钩子函数必须返回一个预定义的神奇字节4值，如下所示:</p><pre class="kz la lb lc fq ld le lf bn lg lh bi"><span id="baaf" class="li ka ht le b be lj lk l ll lm">bytes4(keccak256("onCRC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))</span></pre><p id="3d03" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">一旦接收契约返回这个值，我们就认为契约现在可以接受传输，并且它知道如何管理CRC-1155令牌。就这么定了！</p><blockquote class="jo"><p id="ff6a" class="jp jq ht bd jr js jt ju jv jw jx jn ek translated">加入Coinmonks <a class="ae jy" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae jy" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>了解加密交易和投资</p></blockquote><h1 id="fc22" class="mg ka ht bd kb mh mi mj kf mk ml mm kj mn mo mp km mq mr ms kp mt mu mv ks mw dt translated">另外，阅读</h1><ul class=""><li id="067c" class="ls lt ht is b it ku ix kv jb mx jf my jj mz jn lx ly lz ma dt translated"><a class="ae jy" href="https://coincodecap.com/ascendex-margin-trading" rel="noopener ugc nofollow" target="_blank"> AscendEx保证金交易</a> | <a class="ae jy" href="https://coincodecap.com/bitfinex-staking" rel="noopener ugc nofollow" target="_blank"> Bitfinex赌注</a> | <a class="ae jy" href="https://coincodecap.com/bitflyer-review" rel="noopener ugc nofollow" target="_blank"> bitFlyer点评</a></li><li id="838a" class="ls lt ht is b it mb ix mc jb md jf me jj mf jn lx ly lz ma dt translated"><a class="ae jy" href="https://coincodecap.com/sparrow-exchange-review" rel="noopener ugc nofollow" target="_blank">麻雀交换评论</a> | <a class="ae jy" href="https://coincodecap.com/nash-exchange-review" rel="noopener ugc nofollow" target="_blank">纳什交换评论</a></li><li id="06e5" class="ls lt ht is b it mb ix mc jb md jf me jj mf jn lx ly lz ma dt translated"><a class="ae jy" href="https://coincodecap.com/uphold-card-review" rel="noopener ugc nofollow" target="_blank">支持卡审核</a> | <a class="ae jy" href="https://coincodecap.com/trust-wallet-vs-metamask" rel="noopener ugc nofollow" target="_blank">信任钱包vs元掩码</a></li><li id="908a" class="ls lt ht is b it mb ix mc jb md jf me jj mf jn lx ly lz ma dt translated"><a class="ae jy" href="https://coincodecap.com/traderwagon-review" rel="noopener ugc nofollow" target="_blank"> TraderWagon回顾</a> | <a class="ae jy" href="https://coincodecap.com/kraken-vs-gemini-vs-bityard" rel="noopener ugc nofollow" target="_blank">北海巨妖vs双子vs比特亚德</a></li></ul></div></div>    
</body>
</html>