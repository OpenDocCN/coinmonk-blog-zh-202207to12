<html>
<head>
<title>Learn Solidity lesson 25. Function modifiers.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习第25课固体。功能修饰符。</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/learn-solidity-lesson-25-function-modifiers-944310154219?source=collection_archive---------4-----------------------#2022-08-18">https://medium.com/coinmonks/learn-solidity-lesson-25-function-modifiers-944310154219?source=collection_archive---------4-----------------------#2022-08-18</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/5ea7d0aae91752ad4f79bebc6061f1a9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_6uv7dv50m6IjKVMfI6LWA.jpeg"/></div></div></figure><p id="77d5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">修饰符用于以声明的方式改变函数的行为。它们允许我们在不同的函数中重用代码块，并使它们更具可读性。</p><p id="e7a4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们来看一个经典的例子。在契约中，希望某个函数只由一个特定的地址调用是很常见的，这个地址通常被命名为<em class="jz">所有者</em>。使用修饰符，我们可以如下声明这样一个函数。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="f41b" class="kj kk ht kf b fv kl km l kn ko">function foo() public onlyOwner {...}</span></pre><p id="da59" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">修饰符<code class="eh kp kq kr kf b">onlyOwner</code>的使用在函数声明中明确了它只能被所有者调用</p><p id="a1ba" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">为了声明修饰符，我们使用关键字<strong class="jd hu"> mofidier </strong>，如下例所示。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="4e1c" class="kj kk ht kf b fv kl km l kn ko">modifier onlyOwner() {<br/>   require(msg.sender == owner);<br/>   _;<br/>}</span></pre><p id="7151" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">通过上面的声明，函数体<code class="eh kp kq kr kf b">foo</code>将只在语句<code class="eh kp kq kr kf b">require(msg.sender == owner)</code>之后执行。更准确地说，函数体将包含在修饰符中标识符<code class="eh kp kq kr kf b">_</code>的位置。</p><p id="1cbf" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在函数<code class="eh kp kq kr kf b">foo</code>中使用修饰符<code class="eh kp kq kr kf b">onlyOwner</code>相当于如下声明函数。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="07d5" class="kj kk ht kf b fv kl km l kn ko">function foo() public {<br/>   require(msg.sender==owner);<br/>   ... body of the function ...<br/>}</span></pre><p id="6abd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在同一个函数中可以使用几个修饰符。例如，如果我们声明修饰符<code class="eh kp kq kr kf b">onlyOwner</code>和<code class="eh kp kq kr kf b">notPaused</code>，下面的函数是完全合法的。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="d828" class="kj kk ht kf b fv kl km l kn ko">function bar() public onlyOwner notPause {}</span></pre><p id="d824" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们再看一个使用修饰语的例子。</p><h1 id="84cd" class="ks kk ht bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo dt translated">无入口</h1><p id="89a9" class="pw-post-body-paragraph jb jc ht jd b je lp jg jh ji lq jk jl jm lr jo jp jq ls js jt ju lt jw jx jy hm dt translated">使用修饰符的另一个例子是防止称为<em class="jz">重入</em>的攻击。当一个合同调用另一个合同，而另一个合同又以恶意的方式重新进入原始合同时，就会发生这种情况。</p><p id="1ff4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">有几种方法可以防止这种类型的攻击，使用修饰符是其中之一。让我们看看下面的代码。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="0bf1" class="kj kk ht kf b fv kl km l kn ko">bool isLocked;</span><span id="6bda" class="kj kk ht kf b fv lu km l kn ko">modifier noReentrancy() <br/>   require(isLocked == false);<br/>   isLocked = true;<br/>   _;<br/>   isLocked = false;<br/>}</span></pre><p id="ffc0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在上面的代码中，函数体将被夹在语句<code class="eh kp kq kr kf b">isLocked = true </code>和<code class="eh kp kq kr kf b">isLocked = false</code>之间。它所做的是在执行过程中锁定函数调用，以避免重入。</p><p id="6910" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">您可以在修饰符的任何地方包含标识符<code class="eh kp kq kr kf b">_</code>。甚至可以在修饰符中多次包含标识符<code class="eh kp kq kr kf b">_</code>，每个<code class="eh kp kq kr kf b">_</code>都会被函数体替换。下面的修饰符复制了函数体。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="afca" class="kj kk ht kf b fv kl km l kn ko">modifier duplicate() {<br/>   _;<br/>   _;<br/>}</span></pre><p id="01e8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">例如，让我们看看下面的函数，它使用了修饰符<code class="eh kp kq kr kf b">duplicate</code>。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="c0e3" class="kj kk ht kf b fv kl km l kn ko">function count() public duplicate {<br/>   someCounter++;<br/>}</span></pre><p id="0460" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">上述函数将增加计数器两次，因为语句<code class="eh kp kq kr kf b">someCounter++</code>将被复制。</p><h1 id="11b2" class="ks kk ht bd kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo dt translated">修改器中的参数</h1><p id="f8e6" class="pw-post-body-paragraph jb jc ht jd b je lp jg jh ji lq jk jl jm lr jo jp jq ls js jt ju lt jw jx jy hm dt translated">修饰符可以有参数和访问状态变量。让我们看一个使用带参数的修饰符的例子。</p><p id="72bf" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们看一个使用带参数的修饰符的例子。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="eb38" class="kj kk ht kf b fv kl km l kn ko">uint8 status = 0;</span><span id="7b7a" class="kj kk ht kf b fv lu km l kn ko">modifier inStatus(uint8 _status) {<br/>   require(status==_status);<br/>   _;<br/>}</span><span id="6a43" class="kj kk ht kf b fv lu km l kn ko">function statusZero() public inStatus(0) {}<br/>function statusOne() public inStatus(1) {}</span></pre><p id="ec5f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">上面的例子使用枚举器会更加易读，但是让我们保持简单。修饰符<code class="eh kp kq kr kf b">inStatus</code>有一个参数<code class="eh kp kq kr kf b">_status</code>，它必须等于状态变量<code class="eh kp kq kr kf b">status</code>。</p><p id="d729" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">因此，功能<code class="eh kp kq kr kf b">statusZero</code>只能在状态等于<code class="eh kp kq kr kf b">0</code>时调用，而功能<code class="eh kp kq kr kf b">statusOne</code>只能在状态等于<code class="eh kp kq kr kf b">1</code>时调用。使用参数可以自定义修改器，如下例所示。</p><p id="5b87" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">感谢阅读！</strong></p><p id="d491" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎对本文提出意见和建议。</p><p id="fa02" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎任何投稿。<a class="ae lv" href="http://www.buymeacoffee.com/jpmorais" rel="noopener ugc nofollow" target="_blank">www.buymeacoffee.com/jpmorais</a>。</p><blockquote class="lw"><p id="7453" class="lx ly ht bd lz ma mb mc md me mf jy ek translated">交易新手？尝试<a class="ae lv" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae lv" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>