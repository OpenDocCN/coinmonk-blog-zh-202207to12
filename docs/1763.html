<html>
<head>
<title>Learn Solidity lesson 16. Memory and Storage revisited.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习第16课坚固性。记忆和存储再探。</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/learn-solidity-lesson-16-memory-and-storage-revisited-5bf0d1c45bb9?source=collection_archive---------6-----------------------#2022-08-05">https://medium.com/coinmonks/learn-solidity-lesson-16-memory-and-storage-revisited-5bf0d1c45bb9?source=collection_archive---------6-----------------------#2022-08-05</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/26bcaebbb3805fc6244f435640730918.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lJr1goSfjzYmYleQ8V8XXQ.jpeg"/></div></div></figure><p id="94cc" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在，我们有了新的工具来更详细地研究内存中的值和存储中的值之间的差异。让我们抓住机会，用我们已经学过的一些类型写一个契约。</p><p id="984a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们首先创建一个结构来存储关于怪物游戏角色的信息。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="0ef8" class="ki kj ht ke b fv kk kl l km kn">struct Monster {<br/>   string name;<br/>   uint8 force;<br/>}</span></pre><p id="74c7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">游戏参与者，也就是网络账号，可以拥有一个怪物。存储此类信息的最佳数据结构是映射。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="d663" class="ki kj ht ke b fv kk kl l km kn">mapping(address =&gt; Monster) public monsters;</span></pre><p id="7da1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">由于变量<code class="eh ko kp kq ke b">monsters</code>是公共的，我们不需要显式地编写一个函数来检索给定地址所拥有的怪物。谢谢你，坚实。</p><p id="19b4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们先写一个函数来创建一个新的怪物。它将属于发起交易的账户，并且只有<code class="eh ko kp kq ke b">1</code>的强度。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="7fe8" class="ki kj ht ke b fv kk kl l km kn">function createMonster(string calldata _name) public {<br/>   monsters[msg.sender] = Monster(_name, 1);<br/>}</span></pre><p id="16bd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在我们写一个函数来改变怪物的力量。最简单的方法是直接在存储器中改变值，如下面的函数所示。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="e575" class="ki kj ht ke b fv kk kl l km kn">function changeForceStorage(address _address, uint8 _newForce) public {<br/>   Monster storage  monster = monsters[_address];<br/>   monster.force = _newForce;<br/>}</span></pre><p id="02af" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在函数内部声明的变量<code class="eh ko kp kq ke b">monster</code>是一个指向存储器中一个值的指针。它不会在存储中创建新的变量，因为不可能在运行中创建新的存储变量。所有状态变量都是在部署时创建的。</p><p id="ad2a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">因为它是一个指针，所以不可能直接给它分配一个怪物。不允许使用下面的代码。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="5b10" class="ki kj ht ke b fv kk kl l km kn">Monster storage monster = monsters[_address];<br/>monster = Monster("Paul",3);</span></pre><p id="ad0a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">用怪物来代替指针是不可能的，但是我们可以使用指针来改变一个怪物变量的字段，就像我们在下面的代码行中所做的那样。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="40ac" class="ki kj ht ke b fv kk kl l km kn">monster.force = _newForce;</span></pre><p id="f370" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">另一种改变怪物强度的方法是在内存中创建一个新的怪物，并在某个时候在内存中替换它。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="e304" class="ki kj ht ke b fv kk kl l km kn">Monster memory monster = monsters[_address];<br/>monster.force = _newForce;<br/>monsters[_address] = monster;</span></pre><p id="22cd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这第二种方法在气体方面更昂贵，因为它在将对象存储到存储器之前在存储器中创建它。但是，在将该对象永久存储在存储中之前，协定可能希望对其进行其他操作，因此这将是理想的方法。</p><h1 id="c9b6" class="kr kj ht bd ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln dt translated">内存和存储之间的引用类型</h1><p id="2798" class="pw-post-body-paragraph jb jc ht jd b je lo jg jh ji lp jk jl jm lq jo jp jq lr js jt ju ls jw jx jy hm dt translated">引用类型的值是那些保存一个指向值实际存储位置的指针的值。该数组是引用类型值。让我们在下面的代码中看到这一点。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="1b6b" class="ki kj ht ke b fv kk kl l km kn">function memoryToMemory() public pure returns (uint) {</span><span id="8895" class="ki kj ht ke b fv lt kl l km kn">   uint[3] memory array1 = [uint(1),2,3];<br/>   uint[3] memory array2 = array1;</span><span id="f412" class="ki kj ht ke b fv lt kl l km kn">   array1[0] = 4;<br/>   return(array2[0]);<br/>}</span></pre><p id="0f08" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们有两个数组，都在内存中。首先我们创建变量<code class="eh ko kp kq ke b">array1</code>，包含3个元素<code class="eh ko kp kq ke b">[1,2,3]</code>。当我们声明<code class="eh ko kp kq ke b">array2 </code>为<code class="eh ko kp kq ke b"> array1</code>时，<code class="eh ko kp kq ke b">array2</code>接收与<code class="eh ko kp kq ke b">array1</code>相同的指针。这意味着值<code class="eh ko kp kq ke b">[1,2,3]</code>对于变量<code class="eh ko kp kq ke b">array1</code>和<code class="eh ko kp kq ke b">array2.</code>是相同的</p><p id="ba6e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当改变<code class="eh ko kp kq ke b">array1</code>的值时，<code class="eh ko kp kq ke b">array2</code>的值也会改变，因为它们都指向内存中的相同位置。这是引用类型变量的典型行为。</p><p id="33d7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们现在做一些类似的，但完全不同的事情。让我们看看下面的代码。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="831d" class="ki kj ht ke b fv kk kl l km kn">uint[3] array1 = [uint(1),2,3];<br/>    <br/>function storageToMemory() public view returns (uint, uint) {<br/>   uint[3] memory array2 = array1;<br/>   array2[0] = 4;<br/>   return(array1[0], array2[0]);<br/>}<br/>// return: 1, 4</span></pre><p id="e5af" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">同样，我们有两个数组。但是现在<code class="eh ko kp kq ke b">array1</code>在内存中，而<code class="eh ko kp kq ke b">array2</code>在内存中。当<code class="eh ko kp kq ke b">array2</code>接收<code class="eh ko kp kq ke b">array1</code>时，它现在接收的是<code class="eh ko kp kq ke b">array1</code>的副本，而不再是它的指针。</p><p id="92ff" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这是因为存储和内存是不同的存储位置。变量不能共享同一个对象，因为每个对象都需要在它的存储位置:一个在内存中，一个在存储器中。</p><p id="2b26" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当混合使用内存和存储时，你必须对引用类型的变量小心一点。但是，稍微反思一下就会发现，上述行为越自然越好。</p><p id="b066" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">感谢阅读！</strong></p><p id="fce4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎对本文提出意见和建议。</p><p id="015b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎任何投稿。<a class="ae lu" href="http://www.buymeacoffee.com/jpmorais" rel="noopener ugc nofollow" target="_blank">www.buymeacoffee.com/jpmorais</a></p><blockquote class="lv"><p id="c055" class="lw lx ht bd ly lz ma mb mc md me jy ek translated"><em class="mf">加入Coinmonks </em> <a class="ae lu" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank"> <em class="mf">电报频道</em> </a> <em class="mf">和</em> <a class="ae lu" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> <em class="mf"> Youtube频道</em> </a> <em class="mf">获取每日</em> <a class="ae lu" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank"> <em class="mf">加密新闻</em> </a></p></blockquote><h1 id="8318" class="kr kj ht bd ks kt ku kv kw kx ky kz la lb mg ld le lf mh lh li lj mi ll lm ln dt translated">另外，阅读</h1><ul class=""><li id="c9d7" class="mj mk ht jd b je lo ji lp jm ml jq mm ju mn jy mo mp mq mr dt translated"><a class="ae lu" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a> | <a class="ae lu" rel="noopener" href="/coinmonks/crypto-tax-software-ed4b4810e338">加密税务软件</a></li><li id="8114" class="mj mk ht jd b je ms ji mt jm mu jq mv ju mw jy mo mp mq mr dt translated"><a class="ae lu" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">网格交易</a> | <a class="ae lu" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">加密硬件钱包</a></li><li id="496b" class="mj mk ht jd b je ms ji mt jm mu jq mv ju mw jy mo mp mq mr dt translated"><a class="ae lu" rel="noopener" href="/coinmonks/top-3-telegram-channels-for-crypto-traders-in-2021-8385f4411ff4">密码电报信号</a> | <a class="ae lu" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="948f" class="mj mk ht jd b je ms ji mt jm mu jq mv ju mw jy mo mp mq mr dt translated"><a class="ae lu" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a> | <a class="ae lu" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">最佳加密交易所</a></li><li id="d8ae" class="mj mk ht jd b je ms ji mt jm mu jq mv ju mw jy mo mp mq mr dt translated"><a class="ae lu" rel="noopener" href="/coinmonks/best-crypto-apis-for-developers-5efe3a597a9f">开发人员的最佳加密API</a></li></ul></div></div>    
</body>
</html>