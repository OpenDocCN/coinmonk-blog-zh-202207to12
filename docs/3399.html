<html>
<head>
<title>Journey through Cairo V — Implicit Arguments</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开罗之旅V —隐含论点</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/journey-through-cairo-v-implicit-arguments-fd8c3609b2?source=collection_archive---------5-----------------------#2022-09-09">https://medium.com/coinmonks/journey-through-cairo-v-implicit-arguments-fd8c3609b2?source=collection_archive---------5-----------------------#2022-09-09</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/9a71db6005a5c5a00f5af1990345ab69.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fUl7yt9SYXqAOhpW6vMmyA.png"/></div></div></figure><p id="ca6b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">再次欢迎来到我们系列的第五篇文章<strong class="jd hu">【开罗之旅】</strong>。在我们的上一篇文章中，我们解释了Cairo中的存储，并详细介绍了如何使用Cairo的存储实现映射。</p><p id="9c86" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">今天，我们将通过<strong class="jd hu">隐性论点</strong>走一走，看看它们在开罗是如何运作的。像往常一样，如果你只是中途加入，努力检查之前的文章，以更好地理解和流动这个系列。</p><p id="8dac" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">本教程中使用的所有代码片段都使用了Cairo-lang v0.9.0中的旧Cairo语法，因为在撰写本文时，我们的Starklings练习中也使用了这些语法。</p><h2 id="0986" class="kb kc ht bd kd ke kf kg kh ki kj kk kl jm km kn ko jq kp kq kr ju ks kt ku kv dt translated">隐含的论点</h2><p id="7dae" class="pw-post-body-paragraph jb jc ht jd b je kw jg jh ji kx jk jl jm ky jo jp jq kz js jt ju la jw jx jy hm dt translated">Cairo函数采用两种类型的参数:在<strong class="jd hu"> `(` </strong>和<strong class="jd hu"> `)` </strong>之间提供的显式参数，以及在<strong class="jd hu"> `{` </strong>和<strong class="jd hu"> `}` </strong>之间提供的隐式参数。</p><p id="efd8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">两者之间的主要区别在于，虽然显式参数在函数体内使用，并且不能在函数体外访问，但隐式参数会被需要它们的其他函数调用所继承。</p><p id="2ff9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们来看看我们上一篇关于<a class="ae jz" rel="noopener" href="/coinmonks/journey-through-cairo-iv-a-deep-dive-into-cairos-storage-with-starklings-d7e3549470ff">存储</a>的文章中的这个函数:</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="e76a" class="kb kc ht lg b fv lk ll l lm ln">@externalfunc update_id{</span><span id="7af3" class="kb kc ht lg b fv lo ll l lm ln">      syscall_ptr : felt*,</span><span id="0d79" class="kb kc ht lg b fv lo ll l lm ln">      pedersen_ptr : HashBuiltin*,</span><span id="cefe" class="kb kc ht lg b fv lo ll l lm ln">      range_check_ptr</span><span id="420f" class="kb kc ht lg b fv lo ll l lm ln">    }(_number: felt):</span><span id="9b57" class="kb kc ht lg b fv lo ll l lm ln">    id.write(_number)</span><span id="aec5" class="kb kc ht lg b fv lo ll l lm ln">end</span></pre><p id="4374" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">正如我们在这里看到的，这个函数接受三个隐式参数:</p><ol class=""><li id="da74" class="lp lq ht jd b je jf ji jj jm lr jq ls ju lt jy lu lv lw lx dt translated">syscall_ptr —该参数使Cairo函数能够进行系统启用的调用。</li><li id="a593" class="lp lq ht jd b je ly ji lz jm ma jq mb ju mc jy lu lv lw lx dt translated">pedersen_ptr —此参数用于计算pedersen哈希。</li><li id="473e" class="lp lq ht jd b je ly ji lz jm ma jq mb ju mc jy lu lv lw lx dt translated">range_check_ptr —该参数用于整数比较。</li></ol><p id="06dd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">你可能想知道，当我们既不计算任何散列函数，甚至不进行任何整数比较时，为什么我们需要传递所有这些参数？这是因为我们试图写入的存储变量需要这些隐式参数来计算这个变量的实际内存地址。这在简单的变量中可能不需要，比如我们之前看到的<code class="eh md me mf lg b">id</code>存储变量，但是对于像<code class="eh md me mf lg b">balance</code>这样的存储映射，计算彼得森散列是<code class="eh md me mf lg b">read()</code>和<code class="eh md me mf lg b">write()</code>所做的一部分，这就是为什么调用这些存储变量的父函数必须清楚地声明这些隐式参数。</p><p id="df86" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">为了进一步理解这一点，让我们深入一些<strong class="jd hu">starlings</strong>练习！</p><p id="f61e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">implicit _ arguments 01 . cairo</strong></p><figure class="lb lc ld le fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mg"><img src="../Images/9522e9b286bca35ec442e84cb94d4989.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YPWQTqe4ZL5futrHKsuY-w.png"/></div></div></figure><p id="a8f2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这个练习要求我们修复<strong class="jd hu"> implicit_sum </strong>函数以使测试通过。</p><p id="fe7f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">从测试中我们可以看到，<strong class="jd hu"> test_sum </strong>函数调用了我们的<strong class="jd hu"> implicit_sum </strong>函数，并向它传递了<strong class="jd hu"> a </strong>和<strong class="jd hu"> b </strong>参数，而是隐式地传递了它。</p><p id="4744" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">要使用这些参数，我们还必须在我们的<strong class="jd hu"> implicit_sum </strong>函数中将它们指定为隐式参数，这样Cairo就会被告知这些参数可以在函数调用之间传递。</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="0c24" class="kb kc ht lg b fv lk ll l lm ln">func implicit_sum{a: felt, b: felt}() -&gt; (result: felt):</span><span id="6961" class="kb kc ht lg b fv lo ll l lm ln">   return (a + b)</span><span id="33e2" class="kb kc ht lg b fv lo ll l lm ln">end</span></pre><figure class="lb lc ld le fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mg"><img src="../Images/798719bc77ea50f7cf6ac8553d0c4a01.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Jk3kKU2JxzGE_VKRSV_Cfw.png"/></div></div></figure><p id="0bf5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在第10行完成了这些之后，让我们检查一下我们的测试是否通过。</p><figure class="lb lc ld le fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mh"><img src="../Images/32294912f4df7d5f08240dd55d064fcd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*DhLwSTBQOgSqb8fTQXvG-Q.png"/></div></div></figure><p id="3279" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">是啊！确实如此</p><p id="6e74" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">隐式_参数02.cairo </strong></p><figure class="lb lc ld le fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mi"><img src="../Images/5d63668f98147f1cdc631353e448cf63.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-b0GLv0_OeC7FwaTpeXsaw.png"/></div></div></figure><p id="88d4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在本练习中，我们需要修复<strong class="jd hu"> child_function_1 </strong>和<strong class="jd hu"> child_function_2 </strong>，使测试通过，但不改变函数体。</p><p id="3197" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">从练习中我们可以看到，父函数有两个隐式参数<strong class="jd hu"> a </strong>和<strong class="jd hu"> b </strong></p><p id="9857" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">child_function_1使用隐式参数a，child_function_2使用隐式参数b。为了完成这个练习，我们需要在函数签名中指定每个函数使用的隐式参数。</p><p id="b80a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">对于<strong class="jd hu">子功能1 </strong>:</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="f9c3" class="kb kc ht lg b fv lk ll l lm ln">func child_function_1{a: felt}() -&gt; (result : felt):</span><span id="816a" class="kb kc ht lg b fv lo ll l lm ln">  return (2 * a)</span><span id="d8ce" class="kb kc ht lg b fv lo ll l lm ln">end</span></pre><p id="0cd7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">对于<strong class="jd hu">子功能2 </strong>:</p><pre class="lb lc ld le fq lf lg lh li aw lj dt"><span id="0470" class="kb kc ht lg b fv lk ll l lm ln">func child_function_2{b: felt}() -&gt; (result : felt):</span><span id="6fff" class="kb kc ht lg b fv lo ll l lm ln">  return (b + 3)</span><span id="6a6c" class="kb kc ht lg b fv lo ll l lm ln">end</span></pre><figure class="lb lc ld le fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mi"><img src="../Images/31ef25c7ee4cd664f6a11e20083467bf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Gd6aJD5EyAnwCEUhROEj1g.png"/></div></div></figure><p id="3b96" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在让我们检查测试是否通过。</p><figure class="lb lc ld le fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mj"><img src="../Images/e05f567e90860c8974fd2a35044906cd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*c8Z9l9ByUq4lh-fBzWnR2g.png"/></div></div></figure><p id="f1ae" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">瞧啊。确实如此</p><p id="fc52" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">隐式_参数03.cairo </strong></p><figure class="lb lc ld le fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mk"><img src="../Images/07cab1c9d93e3950924c3ab87ccfe891.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fKo-0efCKh86WIF9wR9kag.png"/></div></div></figure><p id="49e8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">根据Starklings的说法，隐式参数的真正好处是它们被任何使用它们的函数隐式返回，这是该语言的一个非常强大的功能，因为它有助于可读性，让开发人员在后续的函数调用中省略隐式参数。</p><p id="2fba" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在本练习中，我们需要修复<strong class="jd hu">黑盒</strong>函数以使测试通过。</p><p id="5fe7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这很容易做到，因为我们只需要分配参数，<strong class="jd hu"> secret </strong>来匹配单词“very secret！”Cairo会自动返回参数，不需要显式返回。</p><figure class="lb lc ld le fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mk"><img src="../Images/a3b6cabd2426766363e59d8ef5dad26b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5SgNzLioHNWsP2sqqZjzIQ.png"/></div></div></figure><p id="ed71" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在让我们检查一下我们是否通过了测试。</p><figure class="lb lc ld le fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mj"><img src="../Images/ff93c3eab0348c30c25d84f780652a0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nAZKovGcL04q2WHmOfGBMw.png"/></div></div></figure><p id="f5b4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">是啊。我们做到了。</p><h1 id="882d" class="ml kc ht bd kd mm mn mo kh mp mq mr kl ms mt mu ko mv mw mx kr my mz na ku nb dt translated">结论</h1><p id="383e" class="pw-post-body-paragraph jb jc ht jd b je kw jg jh ji kx jk jl jm ky jo jp jq kz js jt ju la jw jx jy hm dt translated">我们已经走过了这段旅程的一半，现在我相信你已经熟悉了开罗在更广阔的视野中是如何运作的。</p><p id="7c7e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们刚刚在开罗讨论了隐含的论点，以及它们在你写合同时对你的帮助。</p><p id="1366" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">和往常一样，如果你从这篇文章中获得了价值，请与他人分享。</p><p id="7fc4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">你也可以在以下社交场合与我联系，尤其是在Twitter上，我在那里分享我在开罗的小发现！</p><p id="40bd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">推特:<a class="ae jz" href="https://twitter.com/0xdarlington?source=about_page-------------------------------------" rel="noopener ugc nofollow" target="_blank">https://twitter.com/0xdarlington</a></p><p id="5510" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">领英:<a class="ae jz" href="https://www.linkedin.com/in/nnamdarlington?source=about_page-------------------------------------" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/nnamdarlington</a></p><p id="9abf" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">github:【https://github.com/Darlington02 T2】</p><blockquote class="nc"><p id="414a" class="nd ne ht bd nf ng nh ni nj nk nl jy ek translated">交易新手？试试<a class="ae jz" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a>或<a class="ae jz" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>