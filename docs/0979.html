<html>
<head>
<title>Learn Solidity lesson 6. Function visibility and mutability.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习第六课“坚实”。函数的可见性和可变性。</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/learn-solidity-lesson-6-function-visibility-and-mutability-7f16db2897db?source=collection_archive---------5-----------------------#2022-07-20">https://medium.com/coinmonks/learn-solidity-lesson-6-function-visibility-and-mutability-7f16db2897db?source=collection_archive---------5-----------------------#2022-07-20</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/4a1d602cfdc026a970aa6453704da799.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YtMgldyS68de4DVKz7Hczg.jpeg"/></div></div></figure><p id="3ca6" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">像变量一样，函数也有可见性。除了<em class="jz">公有</em>、<em class="jz">私有</em>、<em class="jz">内部</em>之外，函数还可以有<strong class="jd hu">外部</strong>可见性。对于变量来说，<em class="jz">私有</em>和<em class="jz">内部</em>的区别是一样的:内部函数由子契约继承，而私有函数则不是。两者都可以通过契约访问。</p><p id="50e1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在的新奇之处在于公共函数和外部函数之间的区别。正如我们所看到的，两者都可以通过事务从契约外部访问。但是，不能从协定内部访问外部函数。</p><p id="3696" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们看看下面的代码:</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="104f" class="kj kk ht kf b fv kl km l kn ko">contract Sum {<br/>   uint private x;<br/>   uint public y;<br/>    <br/>   function setY(uint _y) public {<br/>      externalSetY(_y);<br/>   }    <br/>   function externalSetY(uint _y) external {<br/>      y = _y;<br/>   }<br/>}</span></pre><p id="52f8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">名为<em class="jz">外部安全性</em>的新函数已经创建，具有<em class="jz">外部</em>可见性。该函数可以由事务调用，但不能由契约直接调用。当试图这样做时，编译器会显示一个错误，如下图所示。</p><figure class="ka kb kc kd fq iu fe ff paragraph-image"><div class="fe ff kp"><img src="../Images/3c09ad694fa085096be70994d86c3cb7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1256/format:webp/1*LeVGLOTVh076ziGj6TGZ_A.png"/></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">External functions cannot be invoked by the contract.</figcaption></figure><p id="d326" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">有一种方法可以从契约中调用函数<em class="jz"> setY </em>。将语句<em class="jz">外部安全性(_y) </em>(第9行)替换为下面的语句。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="f829" class="kj kk ht kf b fv kl km l kn ko">this.externalSetY(_y);</span></pre><p id="06d2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这可能看起来很混乱，所以让我们把事情搞清楚。契约可以从其他契约中调用函数，只要这些函数是公共的或外部的。为了从其他契约中调用函数，我们使用下面的结构:<strong class="jd hu">【契约地址】。【T21功能】。</strong></p><p id="422f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">关键字<strong class="jd hu"> this </strong>表示契约的地址，所以我们调用函数<em class="jz"> externalSetY </em>就好像它属于另一个契约一样。也就是说，我们在外部调用函数<em class="jz"> externalSetY </em>(即使它是同一个契约的一部分)。</p><p id="3e77" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">有区别吗？谢谢关心。是的有。当我们通过一个契约调用另一个契约的功能时，我们称之为内部事务。使用<em class="jz"> this.externalSetY </em>，生成了一个内部事务，它的执行路径不同于契约本身的函数调用。</p><h1 id="90ab" class="ku kk ht bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">不改变世界状态的函数</h1><p id="6e6a" class="pw-post-body-paragraph jb jc ht jd b je lr jg jh ji ls jk jl jm lt jo jp jq lu js jt ju lv jw jx jy hm dt translated">区块链的状态通过函数的执行、通过事务来改变，但是并不是每个函数调用都需要通过事务来完成。我们已经在公共变量中见过这种情况，它的编译器为变量创建了一个<em class="jz"> getter </em>函数。</p><p id="dd57" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">可以显式地构造不改变世界状态的函数，并且可以通过调用来调用。这种请求可以是匿名的，并且不花费任何费用。这相当于只是读取一个数据库，而不改变任何东西。</p><p id="12b4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们创建一个新函数，它将变量<em class="jz"> x </em>和<em class="jz"> y </em>相加，并返回值。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="b6e6" class="kj kk ht kf b fv kl km l kn ko">function Sum() public view returns (uint) {<br/>   return x + y;<br/>}</span></pre><p id="9c61" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">函数<em class="jz"> Sum </em>返回一个正整数，如<em class="jz"> returns (uint) </em>所示。退货通过<strong class="jd hu">退货</strong>关键字指定。</p><p id="3bc2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">为了表示函数不会改变区块链的状态，可以使用两个关键字:<strong class="jd hu"> view </strong>和<strong class="jd hu"> pure </strong>。是函数的<strong class="jd hu">可变性</strong>。可变性为<em class="jz">视图</em>或<em class="jz">纯</em>的函数是通过调用而不是事务来调用的。</p><p id="ac1d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">可变性<em class="jz">视图</em>表明该函数不会改变区块链的状态，但是它可以读取状态变量。可变性<em class="jz"> pure </em>表示函数既不会改变也不会读取状态变量。</p><p id="a1dd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">纯函数的一个例子如下。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="a0e6" class="kj kk ht kf b fv kl km l kn ko">function pureSum(uint _x, uint _y) public pure returns (uint) {<br/>   return _x + _y;<br/>}</span></pre><h1 id="57a2" class="ku kk ht bd kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq dt translated">第六集。函数的返回</h1><p id="1e8f" class="pw-post-body-paragraph jb jc ht jd b je lr jg jh ji ls jk jl jm lt jo jp jq lu js jt ju lv jw jx jy hm dt translated">函数可以返回多个参数。有两种方法可以表明函数将返回什么。使用关键字<em class="jz">显式返回</em>，或者命名返回变量。</p><p id="5668" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们看看下面函数中的第二个方法。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="0606" class="kj kk ht kf b fv kl km l kn ko">function pureSumAlternative(uint _x, uint _y) public pure returns (uint z) {<br/>   z = _x + _y;<br/>}</span></pre><p id="d527" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">返回参数现在有一个标识符，<em class="jz"> z </em>，并且<em class="jz"> z </em>的值在函数体中被显式赋值。</p><p id="6d47" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">函数<em class="jz"> pureSum </em>和<em class="jz">pure sum alternation</em>是公共的，因此可以通过调用来访问它们(它们不改变世界状态)。Remix为我们构造了这些调用，可以在选项卡'<em class="jz">Deploy&amp;run transactions</em>中执行，如下图所示。</p><figure class="ka kb kc kd fq iu fe ff paragraph-image"><div class="fe ff lw"><img src="../Images/b71ee37675829b39bb8b0ed381b17c06.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*9nZ9Izvu8w94K6lXpxuUxA.png"/></div><figcaption class="kq kr fg fe ff ks kt bd b be z ek">Executing a call in Remix. The parameters must be separated by commas.</figcaption></figure><p id="5b5f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当声明返回参数的标识符时，它会显示在return中，如上图所示。</p><p id="5b38" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果函数返回一个以上的变量，有两种方法来声明返回。第一种是使用<strong class="jd hu">元组</strong>；用逗号分隔变量，如下例所示。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="4912" class="kj kk ht kf b fv kl km l kn ko">function returnMultiple() public view returns (uint, uint) {<br/>   return (x + y, x * y);<br/>   }</span></pre><p id="bcc8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">另一种方法是声明返回变量的标识符，然后分别给它们赋值。请参见下面的示例。</p><pre class="ka kb kc kd fq ke kf kg kh aw ki dt"><span id="5de8" class="kj kk ht kf b fv kl km l kn ko">function returnMultiple() public view returns (uint _sum, uint _mult) {<br/>   _sum = x + y;<br/>   _mult = x * y;<br/>}</span></pre><p id="a113" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这两种方法的区别在于，在后者中，参数标识符与其值一起返回。</p><p id="87ea" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">感谢阅读！</strong></p><blockquote class="lx"><p id="962e" class="ly lz ht bd ma mb mc md me mf mg jy ek translated">交易新手？尝试<a class="ae mh" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae mh" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>