<html>
<head>
<title>Dissecting the Ethereum Networking Stack: Node Discovery</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">剖析以太坊网络堆栈:节点发现</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/dissecting-the-ethereum-networking-stack-node-discovery-4b3f7895f83f?source=collection_archive---------3-----------------------#2022-10-14">https://medium.com/coinmonks/dissecting-the-ethereum-networking-stack-node-discovery-4b3f7895f83f?source=collection_archive---------3-----------------------#2022-10-14</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="1508" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在过去的几天里，我有机会使用一些传统的(咳咳！)tcpdump等工具。我从这个练习中学到的一件事是，Eth n/w堆栈正在不断地工作和升级，有许多EIP(改进建议)在四处流动。</p><p id="124f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">如您所知，最近的“合并”实际上并不意味着部署新的Eth网络。这纯粹是以前Eth n/w的升级。换句话说，Eth1现在被称为智能合同和n/w协议驻留和运行的“执行层”，而Eth2被称为“共识层”，它确保n/w的参与者按照激励结构和共识规则(PoW to PoS)行事。</p><p id="0caa" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这篇博客中，我们将关注三件事</p><ul class=""><li id="306d" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw dt translated">以太网网络堆栈的快速概述</li><li id="e206" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw dt translated">基于devp2p的以太坊节点/对等体发现</li><li id="7b2c" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw dt translated">Tcpdump跟踪以观察数据包级别的详细信息并验证堆栈行为</li></ul><p id="c72a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">所以基本上，一个以太坊客户端(例如geth)有两个位于同一节点的主要层/客户端，每个都有自己的网络堆栈和子协议。</p><ol class=""><li id="b4d3" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn kc ju jv jw dt translated">执行层</li><li id="7e5d" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn kc ju jv jw dt translated">共识层</li></ol><p id="bef4" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">执行层发生了什么？</strong></p><ul class=""><li id="d243" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw dt translated">这是EVM居住的地方</li><li id="7307" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw dt translated">负责事务构建、执行和状态管理</li><li id="be2e" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw dt translated">还通过对等体之间的加密通信在p2p网络上发送“八卦”交易</li></ul><p id="e0d3" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">共识层发生了什么？</strong></p><ul class=""><li id="aad4" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw dt translated">负责维护共识链(信标链)并处理从其他对等方接收的共识块(信标块)和证明</li></ul><p id="9649" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">现在，这两个层面何时/如何相互作用？</strong></p><ul class=""><li id="4ad7" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw dt translated">每个信标块包含一个执行有效载荷。该负载包含执行和验证负载所需的事务和其他数据的列表</li><li id="8776" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw dt translated">为了检查这个有效性条件，共识层通过本地RPC连接将有效负载发送到执行层</li><li id="39fc" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw dt translated">执行层组装执行块、验证前置条件、执行事务和验证后置条件。结果被发送回共识层</li><li id="3620" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw dt translated">执行层将验证数据传递回共识层，即现在被视为已验证的块(本地RPC连接)</li><li id="5234" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw dt translated">共识层将块添加到其自己的区块链的头部，并对其进行证明，通过网络广播证明(共识p2p)</li></ul><p id="65f1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我喜欢官方<a class="ae kd" href="https://ethereum.org/en/developers/docs/networking-layer/" rel="noopener ugc nofollow" target="_blank">以太坊文档</a>中对这一流程的如下表述</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div class="fe ff ke"><img src="../Images/be60eac5047f95192d0e76e1b82efa29.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/0*hfaBVVpxO3hr9I_j.png"/></div></figure><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div class="fe ff ke"><img src="../Images/8e4c258d3716940f08cf8d896b68a3f0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1380/format:webp/0*9fLh1zWePlpkGz9k.png"/></div></figure><p id="dc80" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，执行层n/w协议分为两个堆栈，这两个堆栈并行运行</p><ol class=""><li id="33b9" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn kc ju jv jw dt translated">节点发现—允许新节点通过UDP找到要连接的对等节点</li><li id="dff6" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn kc ju jv jw dt translated">信息交换—使节点能够通过以下方式交换信息</li></ol><p id="1ce5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">这是高级硬件架构的样子</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="fe ff km"><img src="../Images/6492f5989b9b2e7510612292f27ee110.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tyE85u1O_-srtgbbe0EQtA.png"/></div></div><figcaption class="kr ks fg fe ff kt ku bd b be z ek">The Eth client (node) sits on top of this stack</figcaption></figure><p id="305a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在这篇博客中，我们将详细研究“discv4节点发现”</p><p id="30de" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">什么是“节点发现”,我们为什么需要它？</strong></p><ul class=""><li id="06de" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw dt translated">在n/w中寻找其他对等体进行数据交换和通信的过程。它是由运行在p2p网络上的客户端软件实现的。在我们的例子中，它是Eth客户机之一(下面的例子中使用了gETh)</li><li id="4578" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw dt translated">客户端使用引导机制连接到一小组bootnodes，这些bootnodes被硬编码到客户端中</li><li id="18cb" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw dt translated">Bootnode的唯一职责是向一组对等体引入一个新节点。它不参与同步链之类的链任务。仅在客户端首次启动时使用</li></ul><p id="320f" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">探索是如何在幕后进行的？</strong></p><ul class=""><li id="dad9" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw dt translated">使用了修改形式的<a class="ae kd" rel="noopener" href="/coinmonks/a-brief-overview-of-kademlia-and-its-use-in-various-decentralized-platforms-da08a7f72b8f"> Kademlia </a>，其中每个节点共享分布式哈希表中的节点列表</li><li id="78c2" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw dt translated">每个节点在其表中都有一个最近节点的列表。这种接近度不是“地理上的”，而是由节点ID的相似性定义的(使用XOR来确定接近度。更多详情<a class="ae kd" rel="noopener" href="/coinmonks/a-brief-overview-of-kademlia-and-its-use-in-various-decentralized-platforms-da08a7f72b8f">此处</a></li><li id="6d93" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw dt translated">发现过程通过UDP进行。与TCP不同，UDP没有任何额外的开销，如错误检查、重新传输等。这使得发现很快。</li><li id="00e7" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw dt translated">在较高的层次上，该过程从客户端使用bootnode执行PING/PONG开始。一旦连接，它从该节点获得节点/邻居列表，并继续遍历该列表，直到足够数量的对等体被添加到对等体列表中</li><li id="b985" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw dt translated">启动客户端→连接到bootnode (Ping/Pong ) →绑定到bootnode (Ping/Pong) →查找邻居(FindNode) →绑定到邻居-&gt;交换信息</li></ul><p id="d4ac" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们现在一步一步地打破这整个过程。我使用了最新的gth客户端和wireshark来捕捉这些痕迹。此外，您必须在wireshark上安装这个<a class="ae kd" href="https://github.com/bcsecorg/ethereum_devp2p_wireshark_dissector" rel="noopener ugc nofollow" target="_blank">以太坊剖析器插件</a>来解码devp2p流量</p><ol class=""><li id="d8aa" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn kc ju jv jw dt translated">一旦客户机启动，bootnodes就会从硬编码列表中识别出来。因为我是在goerli测试网上运行gEth的，所以这里列出了与goerli相关的引导节点。你可以在这里找到完整的列表<a class="ae kd" href="https://github.com/ethereum/go-ethereum/blob/master/params/bootnodes.go" rel="noopener ugc nofollow" target="_blank"/></li></ol><pre class="kf kg kh ki fq kv kw kx ky aw kz dt"><span id="6d0c" class="la lb ht kw b fv lc ld l le lf">// GoerliBootnodes are the enode URLs of the P2P bootstrap nodes running on the // Görli test network.</span><span id="ff5d" class="la lb ht kw b fv lg ld l le lf">var GoerliBootnodes = []string{</span><span id="ef48" class="la lb ht kw b fv lg ld l le lf">// Upstream bootnodes  "enode://011f758e6552d105183b1761c5e2dea0111bc20fd5f6422bc7f91e0fabbec9a6595caf6239b37feb773dddd3f87240d99d859431891e4a642cf2a0a9e6cbb98a@51.141.78.53:30303",  "enode://176b9417f511d05b6b2cf3e34b756cf0a7096b3094572a8f6ef4cdcb9d1f9d00683bf0f83347eebdf3b81c3521c2332086d9592802230bf528eaf606a1d9677b@13.93.54.137:30303",  "enode://46add44b9f13965f7b9875ac6b85f016f341012d84f975377573800a863526f4da19ae2c620ec73d11591fa9510e992ecc03ad0751f53cc02f7c7ed6d55c7291@94.237.54.114:30313",  "enode://b5948a2d3e9d486c4d75bf32713221c2bd6cf86463302339299bd227dc2e276cd5a1c7ca4f43a0e9122fe9af884efed563bd2a1fd28661f3b5f5ad7bf1de5949@18.218.250.66:30303",</span><span id="fa96" class="la lb ht kw b fv lg ld l le lf">// Ethereum Foundation bootnode  "enode://a61215641fb8714a373c80edbfa0ea8878243193f57c96eeb44d0bc019ef295abd4e044fd619bfc4c59731a73fb79afe84e9ab6da0c743ceb479cbb6d263fa91@3.11.147.67:30303",</span><span id="109f" class="la lb ht kw b fv lg ld l le lf">// Goerli Initiative bootnodes  "enode://d4f764a48ec2a8ecf883735776fdefe0a3949eb0ca476bd7bc8d0954a9defe8fea15ae5da7d40b5d2d59ce9524a99daedadf6da6283fca492cc80b53689fb3b3@46.4.99.122:32109",  "enode://d2b720352e8216c9efc470091aa91ddafc53e222b32780f505c817ceef69e01d5b0b0797b69db254c586f493872352f5a022b4d8479a00fc92ec55f9ad46a27e@88.99.70.182:30303",</span><span id="4763" class="la lb ht kw b fv lg ld l le lf">}</span></pre><p id="d014" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">2.我们的节点尝试连接到bootnodes，但是只从其中两个节点得到响应</p><p id="21ec" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">启动节点—94.237.53.114</strong></p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="fe ff lh"><img src="../Images/24c5062096d4a63aa2f8398dac2026a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*T0P4g2b64Z7r7X-n"/></div></div></figure><p id="fdab" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">PING和FindNode UDP请求以ICMP目的地不可达响应结束。路由器/代理显然阻止了这种流量。代理还会重置端口30303上的TCP SYN请求。</p><p id="8ad2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">启动节点—51.141.78.53</strong></p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="fe ff lh"><img src="../Images/6611f38f37eb85f4d7de12460edb8f26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zt1q1ht-tzCOez5u"/></div></div></figure><p id="1b04" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">所有的TCP SYNs都在北/w的某个地方被丢弃。我们的节点一直在重新传输SYN数据包，运气不好</p><p id="ef25" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">【13.93.54.137 T2】Bootnode——T3</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="fe ff lh"><img src="../Images/2baa411362a373824466f5d31935e0e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_zxg7lshKvy-ErqB"/></div></div></figure><p id="ee80" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">对Devp2p的PING和FindNode UDP请求没有响应。路由器/代理显然阻止了这种流量。所有TCP SYNs也在北w的某个地方被丢弃。继续。</p><p id="4108" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">【3.11.147.67 T4】boot nodes</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="fe ff lh"><img src="../Images/3782dfd2489c56a6929918510acc5af7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7FWq6dI7Uwyi0d1A"/></div></div></figure><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="fe ff lh"><img src="../Images/74ab9555462fd09741d18155e648c4bb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gsPv-wxZadtHZMM6"/></div></div></figure><p id="6e47" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">很明显，同样的问题。</p><p id="1b6d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">启动节点——18.218.250.66和88.99.70.182</strong></p><p id="a92c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最后，我们可以看到我们的节点是如何连接到n/w中的对等节点的。</p><p id="bb19" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">启动客户端→连接到bootnode (Ping/Pong ) →绑定到bootnode (Ping/Pong) →查找邻居(FindNode) →绑定到邻居</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="fe ff lh"><img src="../Images/3d98e941910d418bcf0cf4f3ea1943d9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*gYJxEZxrqepbKp-G"/></div></div></figure><p id="40d7" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">客户端(geth)将通过遵循相同的机制(connect/bond/find_neighbors)继续搜索节点，直到所有传出的对等槽都被填满。</p><p id="621c" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">注意</p><ul class=""><li id="b343" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw dt translated">使用以下公式计算这些插槽的数量:<em class="li"> maxpeers * dialRatio。maxpeers和dial ratio的</em>默认值分别为25和13。</li><li id="4fe9" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw dt translated">当达到期望的对等体数量时，geth将停止查找。但是，仍然会有发现流量。这是因为发现系统需要维护才能保持工作。此外，节点也可能失去对等连接，然后需要重新填充该插槽。有关插槽和超时的具体值的更多详细信息，请查看这里的go代码<a class="ae kd" href="https://github.com/ethereum/go-ethereum/blob/master/p2p/server.go#L50" rel="noopener ugc nofollow" target="_blank"/></li></ul><p id="1424" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，让我们更进一步。在发现过程中到底交换了什么？</p><p id="caec" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们举个工作例子。我们的节点能够从bootnode中识别出一个邻居列表(如上面最后的截图所示)。现在，它试图绑定到一个邻居(143.244.60.51)并获得另一个邻居列表(它不断迭代，直到达到最大对等点)</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="fe ff lh"><img src="../Images/267170298f196f033e0acce6c336b27a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*nIa60ixyKxNEQ26X"/></div></div></figure><p id="ec24" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">放大有效载荷和字段</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="fe ff lh"><img src="../Images/038d2ad9e722583772bd6231d7cf938a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*XDuQSi8lmIJ7xpe2"/></div></div></figure><ul class=""><li id="fab2" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw dt translated">我们可以清楚地看到，从我们的节点10.128.0.20向启动节点143.244.60.51发送了PING命令。该PING包括关于新节点、启动节点和到期时间戳的散列信息</li></ul><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="fe ff lh"><img src="../Images/e94ad6d97835fbd49bc374daf98b7c4f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IeuqyJZJlhlsX0EZ"/></div></div></figure><ul class=""><li id="372e" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw dt translated">bootnode 143.244.60.51向我们的节点10.128.0.20发送回了一个包含PING哈希(6 cf 6d 111948 bbe 5 e 212 ebc 9401 c 7936 B3 B2 df 53 e 7699 B1 ddf 9830 c 460 affd 70 e)的^乒乓。</li></ul><p id="9b7d" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">由于PING和PONG散列已经匹配，我们的节点和对等体之间的连接被验证，它们被称为“绑定”。</p><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="fe ff lh"><img src="../Images/c23d20d5a4eaebdb57df347b6ab97dfd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*tIsb_SWsrH8ULZNu"/></div></div></figure><figure class="kf kg kh ki fq kj fe ff paragraph-image"><div role="button" tabindex="0" class="kn ko di kp bf kq"><div class="fe ff lh"><img src="../Images/3e78aa764b6909e93631c99682b34952.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*MWqI83W3MOSotc-h"/></div></div></figure><p id="1cbd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">一旦绑定，我们的节点向143.244.60.51发送一个查找节点请求。143.244.60.51返回的数据包括我们的节点可以进一步连接的对等体列表。数据被截断成两个UDP数据包。一个包含14个邻居，另一个包含4个。</p><p id="15b2" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在，我们的节点开始与它们中的每一个进行乒乓交换。成功的乒乓将我们的节点与其邻居联系在一起，实现了消息交换。同样，这种情况会一直发生，直到达到maxpeer*dial_ratio限制。此外，如果这些邻居之一离线，对等插槽需要被填满。所以这个过程又重复了一遍。</p><p id="c6c5" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后，客户端开始通过端口30303启动与相应节点的TCP连接，并交换状态信息。关于这一点和节点寻址方案的更多信息将在以后的文章中讨论。</p><p id="610b" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在回到探索号上来，有一些未解的问题</p><ul class=""><li id="de69" class="jo jp ht is b it iu ix iy jb jq jf jr jj js jn jt ju jv jw dt translated">为什么geth试图通过发送FIND_NODE和启动陈旧的TCP连接来连接节点，而它显然没有得到任何初始ping的响应。这不会让北/w变得不必要的多嘴多舌吗？</li><li id="cfe8" class="jo jp ht is b it jx ix jy jb jz jf ka jj kb jn jt ju jv jw dt translated">UDP数据包似乎超过1000字节。我知道有一个1280字节的最大数据包大小的固定限制，到目前为止，它在所有测试的网络中都工作正常。然而，互联网上的许多传统路由器仍然不能很好地处理较大的UDP数据包。通常，最安全的选项是512字节。然而，现代路由器可以处理更大的数据包。</li></ul><p id="f9cf" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">最后，有趣的是，这还不是全部。Eth客户端基于<a class="ae kd" href="https://eips.ethereum.org/EIPS/eip-1459" rel="noopener ugc nofollow" target="_blank"> EIP-1459 </a>执行另一个基于DNS的并行发现过程。这是一种备份发现机制，客户端可以利用这种机制，尤其是在限制性网络策略可能使基于discv4的节点失败并阻止节点加入DHT的情况下。更多关于这一点和以太坊节点寻址方案(ENR)在一个单独的职位。</p><blockquote class="lj"><p id="6604" class="lk ll ht bd lm ln lo lp lq lr ls jn ek translated">交易新手？试试<a class="ae kd" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a>或者<a class="ae kd" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>