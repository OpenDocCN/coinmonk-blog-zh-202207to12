<html>
<head>
<title>CRC20 Token Deployment</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">CRC20令牌部署</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/crc20-token-deployment-96f3ce0c5762?source=collection_archive---------19-----------------------#2022-12-01">https://medium.com/coinmonks/crc20-token-deployment-96f3ce0c5762?source=collection_archive---------19-----------------------#2022-12-01</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><p id="6022" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">也许您的项目出于任何目的需要一个令牌(例如:投票权、治理、传统支持的稳定硬币等)，CRC20是coinex智能链上可替换令牌的CSC标准。在本教程中，我们将看看CRC20标准及其实施。</p><figure class="jp jq jr js fq jt fe ff paragraph-image"><div role="button" tabindex="0" class="ju jv di jw bf jx"><div class="fe ff jo"><img src="../Images/ad5f5886c590e06e022a359764163a8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*x0L4Tz25CV7a9RDg2bZXIA.png"/></div></div></figure><h2 id="b80a" class="ka kb ht bd kc kd ke kf kg kh ki kj kk jb kl km kn jf ko kp kq jj kr ks kt ku dt translated">CRC20</h2><p id="6fb2" class="pw-post-body-paragraph iq ir ht is b it kv iv iw ix kw iz ja jb kx jd je jf ky jh ji jj kz jl jm jn hm dt translated">CRC20是可替换令牌的coinex智能链标准。CSC与以太坊完全兼容，因此CRC20与ERC20相同。</p><div class="la lb fm fo lc ld"><a href="https://eips.ethereum.org/EIPS/eip-20" rel="noopener  ugc nofollow" target="_blank"><div class="le ab ej"><div class="lf ab lg cl cj lh"><h2 class="bd hu fv z el li eo ep lj er et hs dt translated">EIP-20:令牌标准</h2><div class="lk l"><h3 class="bd b fv z el li eo ep lj er et ek translated">令牌的标准接口。以下标准允许实现令牌的标准API</h3></div><div class="ll l"><p class="bd b gc z el li eo ep lj er et ek translated">eips.ethereum.org</p></div></div></div></a></div><p id="c1a1" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">在本教程中，我们将使用ERC20的OpenZeppelin实现:</p><div class="la lb fm fo lc ld"><a href="https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/token/ERC20" rel="noopener  ugc nofollow" target="_blank"><div class="le ab ej"><div class="lf ab lg cl cj lh"><h2 class="bd hu fv z el li eo ep lj er et hs dt translated">open zeppelin-contracts/contracts/token/er C20 at master open zeppelin/open zeppelin-contracts</h2><div class="lk l"><h3 class="bd b fv z el li eo ep lj er et ek translated">有关ERC20令牌的概述以及如何创建令牌合同的演练，请阅读我们的ERC20指南。有一个…</h3></div><div class="ll l"><p class="bd b gc z el li eo ep lj er et ek translated">github.com</p></div></div><div class="lm l"><div class="ln l lo lp lq lm lr jy ld"/></div></div></a></div><p id="309a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">首先，我们需要为我们的项目创建一个目录，所以我终端类型:</p><pre class="jp jq jr js fq ls lt lu bn lv lw bi"><span id="c9ea" class="lx kb ht lt b be ly lz l ma mb">mkdir CRC20<br/>cd CRC20</span></pre><p id="fb46" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">然后创建一个名为crc20.sol的文件，如下所示:</p><pre class="jp jq jr js fq ls lt lu bn lv lw bi"><span id="4acd" class="lx kb ht lt b be ly lz l ma mb">touch crc20.sol</span></pre><p id="e9b0" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">克隆Openzeppelin github repo并将Openzeppelin ERC20.sol代码粘贴到此处:</p><pre class="jp jq jr js fq ls lt lu bn lv lw bi"><span id="ee33" class="lx kb ht lt b be ly lz l ma mb">// SPDX-License-Identifier: MIT<br/>// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)<br/><br/>pragma solidity ^0.8.0;<br/><br/>import "./IERC20.sol";<br/>import "./extensions/IERC20Metadata.sol";<br/>import "../../utils/Context.sol";<br/><br/><br/>contract ERC20 is Context, IERC20, IERC20Metadata {<br/>    mapping(address =&gt; uint256) private _balances;<br/><br/>    mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;<br/><br/>    uint256 private _totalSupply;<br/><br/>    string private _name;<br/>    string private _symbol;<br/><br/><br/>    constructor(string memory name_, string memory symbol_,uint256 totalSupply_) {<br/>        _name = name_;<br/>        _symbol = symbol_;<br/>        _totalSupply = totalSupply_;<br/>      <br/>    }<br/><br/>    /**<br/>     * @dev Returns the name of the token.<br/>     */<br/>    function name() public view virtual override returns (string memory) {<br/>        return _name;<br/>    }<br/><br/>    function symbol() public view virtual override returns (string memory) {<br/>        return _symbol;<br/>    }<br/><br/>    function decimals() public view virtual override returns (uint8) {<br/>        return 18;<br/>    }<br/><br/>    /**<br/>     * @dev See {IERC20-totalSupply}.<br/>     */<br/>    function totalSupply() public view virtual override returns (uint256) {<br/>        return _totalSupply;<br/>    }<br/><br/>    /**<br/>     * @dev See {IERC20-balanceOf}.<br/>     */<br/>    function balanceOf(address account) public view virtual override returns (uint256) {<br/>        return _balances[account];<br/>    }<br/><br/><br/>    function transfer(address to, uint256 amount) public virtual override returns (bool) {<br/>        address owner = _msgSender();<br/>        _transfer(owner, to, amount);<br/>        return true;<br/>    }<br/><br/>    /**<br/>     * @dev See {IERC20-allowance}.<br/>     */<br/>    function allowance(address owner, address spender) public view virtual override returns (uint256) {<br/>        return _allowances[owner][spender];<br/>    }<br/><br/><br/>    function approve(address spender, uint256 amount) public virtual override returns (bool) {<br/>        address owner = _msgSender();<br/>        _approve(owner, spender, amount);<br/>        return true;<br/>    }<br/><br/><br/>    function transferFrom(<br/>        address from,<br/>        address to,<br/>        uint256 amount<br/>    ) public virtual override returns (bool) {<br/>        address spender = _msgSender();<br/>        _spendAllowance(from, spender, amount);<br/>        _transfer(from, to, amount);<br/>        return true;<br/>    }<br/><br/><br/>    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {<br/>        address owner = _msgSender();<br/>        _approve(owner, spender, allowance(owner, spender) + addedValue);<br/>        return true;<br/>    }<br/><br/><br/>    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {<br/>        address owner = _msgSender();<br/>        uint256 currentAllowance = allowance(owner, spender);<br/>        require(currentAllowance &gt;= subtractedValue, "ERC20: decreased allowance below zero");<br/>        unchecked {<br/>            _approve(owner, spender, currentAllowance - subtractedValue);<br/>        }<br/><br/>        return true;<br/>    }<br/><br/><br/>    function _transfer(<br/>        address from,<br/>        address to,<br/>        uint256 amount<br/>    ) internal virtual {<br/>        require(from != address(0), "ERC20: transfer from the zero address");<br/>        require(to != address(0), "ERC20: transfer to the zero address");<br/><br/>        _beforeTokenTransfer(from, to, amount);<br/><br/>        uint256 fromBalance = _balances[from];<br/>        require(fromBalance &gt;= amount, "ERC20: transfer amount exceeds balance");<br/>        unchecked {<br/>            _balances[from] = fromBalance - amount;<br/>            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by<br/>            // decrementing then incrementing.<br/>            _balances[to] += amount;<br/>        }<br/><br/>        emit Transfer(from, to, amount);<br/><br/>        _afterTokenTransfer(from, to, amount);<br/>    }<br/><br/><br/>    function _mint(address account, uint256 amount) internal virtual {<br/>        require(account != address(0), "ERC20: mint to the zero address");<br/><br/>        _beforeTokenTransfer(address(0), account, amount);<br/><br/>        _totalSupply += amount;<br/>        unchecked {<br/>            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.<br/>            _balances[account] += amount;<br/>        }<br/>        emit Transfer(address(0), account, amount);<br/><br/>        _afterTokenTransfer(address(0), account, amount);<br/>    }<br/><br/>    function _burn(address account, uint256 amount) internal virtual {<br/>        require(account != address(0), "ERC20: burn from the zero address");<br/><br/>        _beforeTokenTransfer(account, address(0), amount);<br/><br/>        uint256 accountBalance = _balances[account];<br/>        require(accountBalance &gt;= amount, "ERC20: burn amount exceeds balance");<br/>        unchecked {<br/>            _balances[account] = accountBalance - amount;<br/>            // Overflow not possible: amount &lt;= accountBalance &lt;= totalSupply.<br/>            _totalSupply -= amount;<br/>        }<br/><br/>        emit Transfer(account, address(0), amount);<br/><br/>        _afterTokenTransfer(account, address(0), amount);<br/>    }<br/><br/>    function _approve(<br/>        address owner,<br/>        address spender,<br/>        uint256 amount<br/>    ) internal virtual {<br/>        require(owner != address(0), "ERC20: approve from the zero address");<br/>        require(spender != address(0), "ERC20: approve to the zero address");<br/><br/>        _allowances[owner][spender] = amount;<br/>        emit Approval(owner, spender, amount);<br/>    }<br/><br/><br/>    function _spendAllowance(<br/>        address owner,<br/>        address spender,<br/>        uint256 amount<br/>    ) internal virtual {<br/>        uint256 currentAllowance = allowance(owner, spender);<br/>        if (currentAllowance != type(uint256).max) {<br/>            require(currentAllowance &gt;= amount, "ERC20: insufficient allowance");<br/>            unchecked {<br/>                _approve(owner, spender, currentAllowance - amount);<br/>            }<br/>        }<br/>    }<br/><br/><br/>    function _beforeTokenTransfer(<br/>        address from,<br/>        address to,<br/>        uint256 amount<br/>    ) internal virtual {}<br/><br/><br/>    function _afterTokenTransfer(<br/>        address from,<br/>        address to,<br/>        uint256 amount<br/>    ) internal virtual {}<br/>}</span></pre><p id="8f27" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated"><strong class="is hu">注意:</strong>我删除了注释以减少代码行。</p><p id="07fd" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">可通过以下方式更改名称、符号和总供应量:</p><pre class="jp jq jr js fq ls lt lu bn lv lw bi"><span id="ed53" class="lx kb ht lt b be ly lz l ma mb">_name = "My Token";<br/>_symbol = "TKN";<br/>_totalSupply = 1000000;</span></pre><p id="a3bb" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">当你编译你的代码时，它会创建ABI文件。我们已经在之前的教程中讨论过ABI，它看起来是这样的:</p><pre class="jp jq jr js fq ls lt lu bn lv lw bi"><span id="5def" class="lx kb ht lt b be ly lz l ma mb">ABI = '[{"constant":true,"inputs":[],"name":"name","outputs":[{"name":"","type":"string"}],"payable":false,"type":"function","stateMutability":"view"},{"constant":false,"inputs":[{"name":"_spender","type":"address"},{"name":"_value","type":"uint256"}],"name":"approve","outputs":[{"name":"","type":"bool"}],"payable":false,"type":"function","stateMutability":"nonpayable"},{"constant":true,"inputs":[],"name":"totalSupply","outputs":[{"name":"","type":"uint256"}],"payable":false,"type":"function","stateMutability":"view"},{"constant":false,"inputs":[{"name":"_from","type":"address"},{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transferFrom","outputs":[{"name":"","type":"bool"}],"payable":false,"type":"function","stateMutability":"nonpayable"},{"constant":true,"inputs":[],"name":"decimals","outputs":[{"name":"","type":"uint8"}],"payable":false,"type":"function","stateMutability":"view"},{"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"","type":"uint256"}],"payable":false,"type":"function","stateMutability":"view"},{"constant":true,"inputs":[],"name":"symbol","outputs":[{"name":"","type":"string"}],"payable":false,"type":"function","stateMutability":"view"},{"constant":false,"inputs":[{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transfer","outputs":[{"name":"","type":"bool"}],"payable":false,"type":"function","stateMutability":"nonpayable"},{"constant":true,"inputs":[{"name":"_owner","type":"address"},{"name":"_spender","type":"address"}],"name":"allowance","outputs":[{"name":"","type":"uint256"}],"payable":false,"type":"function","stateMutability":"view"},{"inputs":[{"name":"_totalSupply","type":"uint256"}],"payable":false,"type":"constructor","stateMutability":"nonpayable"},{"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"owner","type":"address"},{"indexed":true,"name":"spender","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Approval","type":"event"}]'</span></pre><p id="cdb6" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">让我们在CSC网络上部署我们的智能合同。我们可以用松露、安全帽或混音来做。我用Remix是因为它对初学者非常友好，而且重量轻，不需要安装任何东西。</p><div class="la lb fm fo lc ld"><a rel="noopener follow" target="_blank" href="/coinmonks/introduction-to-smart-contract-development-and-dapp-development-on-csc-part2-13f253c60c13"><div class="le ab ej"><div class="lf ab lg cl cj lh"><h2 class="bd hu fv z el li eo ep lj er et hs dt translated">CSC上的智能合约开发和Dapp开发简介-第2部分</h2><div class="lk l"><h3 class="bd b fv z el li eo ep lj er et ek translated">嘿嘿嘿！</h3></div><div class="ll l"><p class="bd b gc z el li eo ep lj er et ek translated">medium.com</p></div></div><div class="lm l"><div class="mc l lo lp lq lm lr jy ld"/></div></div></a></div><p id="c71a" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">现在是时候使用我们的dapp与我们的智能合约进行交互了。</p><pre class="jp jq jr js fq ls lt lu bn lv lw bi"><span id="0183" class="lx kb ht lt b be ly lz l ma mb">const Web3 = require('web3');<br/>const w3 = new Web3("https://testnet-rpc.coinex.net");<br/><br/>const crc20_abi = "Past Your Smart Contract ABI Here"<br/>const contranctAddress = "Paste Smart Contract Address Here";<br/>const crcContract = new web3.eth.Contract(crc20_abi, contranctAddress);<br/><br/>// get total supply of crc20 token<br/>crcContract.methods.totalSupply().call();<br/>//1000000<br/><br/>// get name of crc20 token<br/>const name = crcContract.methods.name().call();<br/>//My Token<br/><br/>// get symbol of crc20 token<br/>const symbol = crcContract.methods.symbol().call()<br/>//TKN<br/><br/>// get decimals of crc20 token<br/>const decimals = crcContract.methods.decimals().call()<br/>//18</span></pre><p id="4e77" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">恭喜你！</p><p id="ee41" class="pw-post-body-paragraph iq ir ht is b it iu iv iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn hm dt translated">我们在coinex智能链上部署了可替换令牌，在接下来的教程中，我们将进一步讨论crc20令牌。</p><blockquote class="md"><p id="3146" class="me mf ht bd mg mh mi mj mk ml mm jn ek translated">交易新手？试试<a class="ae mn" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a>或者<a class="ae mn" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p><p id="debb" class="me mf ht bd mg mh mi mj mk ml mm jn ek translated">加入Coinmonks <a class="ae mn" href="https://t.me/coincodecap" rel="noopener ugc nofollow" target="_blank">电报频道</a>和<a class="ae mn" href="https://www.youtube.com/c/coinmonks/videos" rel="noopener ugc nofollow" target="_blank"> Youtube频道</a>获取每日<a class="ae mn" href="http://coincodecap.com/" rel="noopener ugc nofollow" target="_blank">加密新闻</a></p></blockquote><h2 id="15d6" class="ka kb ht bd kc kd mo kf kg kh mp kj kk jb mq km kn jf mr kp kq jj ms ks kt ku dt translated">另外，阅读</h2><ul class=""><li id="20fb" class="mt mu ht is b it kv ix kw jb mv jf mw jj mx jn my mz na nb dt translated"><a class="ae mn" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a> | <a class="ae mn" rel="noopener" href="/coinmonks/crypto-tax-software-ed4b4810e338">加密税务软件</a></li><li id="723e" class="mt mu ht is b it nc ix nd jb ne jf nf jj ng jn my mz na nb dt translated"><a class="ae mn" href="https://coincodecap.com/grid-trading" rel="noopener ugc nofollow" target="_blank">网格交易</a> | <a class="ae mn" rel="noopener" href="/coinmonks/the-best-cryptocurrency-hardware-wallets-of-2020-e28b1c124069">加密硬件钱包</a></li><li id="874f" class="mt mu ht is b it nc ix nd jb ne jf nf jj ng jn my mz na nb dt translated"><a class="ae mn" rel="noopener" href="/coinmonks/top-3-telegram-channels-for-crypto-traders-in-2021-8385f4411ff4">密码电报信号</a> | <a class="ae mn" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a></li><li id="f33b" class="mt mu ht is b it nc ix nd jb ne jf nf jj ng jn my mz na nb dt translated"><a class="ae mn" rel="noopener" href="/coinmonks/crypto-exchange-dd2f9d6f3769">最佳加密交易所</a> | <a class="ae mn" rel="noopener" href="/coinmonks/bitcoin-exchange-in-india-7f1fe79715c9">印度最佳加密交易所</a></li><li id="47a8" class="mt mu ht is b it nc ix nd jb ne jf nf jj ng jn my mz na nb dt translated"><a class="ae mn" rel="noopener" href="/coinmonks/best-crypto-apis-for-developers-5efe3a597a9f">面向开发人员的最佳加密API</a></li><li id="b359" class="mt mu ht is b it nc ix nd jb ne jf nf jj ng jn my mz na nb dt translated">最佳<a class="ae mn" rel="noopener" href="/coinmonks/top-5-crypto-lending-platforms-in-2020-that-you-need-to-know-a1b675cec3fa">密码借贷平台</a></li><li id="3c98" class="mt mu ht is b it nc ix nd jb ne jf nf jj ng jn my mz na nb dt translated"><a class="ae mn" rel="noopener" href="/coinmonks/free-crypto-signals-48b25e61a8da">免费加密信号</a> | <a class="ae mn" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a></li><li id="9487" class="mt mu ht is b it nc ix nd jb ne jf nf jj ng jn my mz na nb dt translated">杠杆代币的终极指南</li></ul></div></div>    
</body>
</html>