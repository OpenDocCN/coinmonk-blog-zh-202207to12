<html>
<head>
<title>Learn Solidity lesson 33. Interfaces.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习第33课坚固性。接口。</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/learn-solidity-lesson-33-interfaces-ad41323beee2?source=collection_archive---------4-----------------------#2022-10-22">https://medium.com/coinmonks/learn-solidity-lesson-33-interfaces-ad41323beee2?source=collection_archive---------4-----------------------#2022-10-22</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/dcfecde461a094accc6db02073e7df33.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ghVAvXsJSU7oYvCUVKnsnw.jpeg"/></div></div></figure><p id="ce32" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">接口类似于抽象契约，但是没有实现任何功能，也没有声明状态变量。在面向对象的编程语言中，接口就像蓝图，一系列要实现的功能，但是没有它们的实现。</p><p id="51d9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">接口在Solidity中被广泛使用有两个主要原因。描述要实现的标准，例如ERC-20(令牌)和ERC-721(不可替换令牌)。此外，契约的接口提供了用于与之交互的ABI。</p><p id="3df6" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们更深入地研究一下Solidity中的接口。为了声明一个接口，我们使用关键字<strong class="jd hu"> interface </strong>，后跟接口的名称。接口不能从协定继承，但可以从其他接口继承。</p><p id="ee94" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们看看下面的代码。这是完全有效的。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="fd7d" class="ki kj ht ke b fv kk kl l km kn">//SPDX-License-Identifier: MIT<br/>pragma solidity ^0.8.7;</span><span id="f32a" class="ki kj ht ke b fv ko kl l km kn">interface Foo {}</span><span id="f5f7" class="ki kj ht ke b fv ko kl l km kn">interface Bar is Foo{}</span></pre><p id="669d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在接口中，我们可以声明函数头和事件，以及结构和可枚举数。不支持构造函数、状态变量和修饰符。</p><h1 id="db61" class="kp kj ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">接口的一些规则</h1><p id="0075" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">坚固性需要一些创建接口的规则。官方文件说，这些规则中的一些可能会在未来终止，但目前我们应该坚持它们。</p><p id="fe61" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">每个函数都必须具有外部可见性，即使它在实现该接口的协定中被声明为public。以下陈述是有效的。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="99b3" class="ki kj ht ke b fv kk kl l km kn">function toBeImplemented() external returns (uint);</span></pre><p id="5022" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">将<em class="lr">外部</em>可见性替换为<em class="lr">公共</em>将导致编译器抛出错误。同样，将函数声明为内部或私有也没有意义:<em class="lr">内部和私有</em>函数是契约实现的一部分，而不是它的接口。</p><p id="da00" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">没有必要声明接口中的函数是虚拟的，因为接口中的所有函数都是隐式虚拟的。同样，在实现时也没有必要使用关键字<em class="lr"> override </em>。</p><p id="dd4a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如前所述，在一个接口中声明结构和枚举是可能的。下面的代码完全有效。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="12d7" class="ki kj ht ke b fv kk kl l km kn">interface Foo {</span><span id="ce3e" class="ki kj ht ke b fv ko kl l km kn">   enum MyEnum{ First, Second}</span><span id="6157" class="ki kj ht ke b fv ko kl l km kn">   struct MyStruct{ uint first; string second;}</span><span id="4fee" class="ki kj ht ke b fv ko kl l km kn">   function toBeImplemented() external returns (uint);</span><span id="b274" class="ki kj ht ke b fv ko kl l km kn">}</span></pre><h1 id="447b" class="kp kj ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">ERC-20标准接口</h1><p id="1024" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">ERC-20标准是以太网上最广泛使用的可替换令牌标准。事实上，我们知道的大多数加密货币都是ERC 20代币。其标准在2015年末作为一项提案提交，以改进以太坊网络20号EIP-20。可以在<br/><a class="ae ls" href="http://eips.ethereum.org/EIPS/eip-20" rel="noopener ugc nofollow" target="_blank">eips.ethereum.org/EIPS/eip-20</a>找到。</p><p id="24bc" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">ERC-20标准最广泛使用的实现之一是由OpenZeppelin实现的。代码如下。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="1657" class="ki kj ht ke b fv kk kl l km kn">interface IERC20 {</span><span id="b8dd" class="ki kj ht ke b fv ko kl l km kn">function totalSupply() external view returns (uint256);</span><span id="0780" class="ki kj ht ke b fv ko kl l km kn">function balanceOf(address who) external view returns (uint256);</span><span id="9263" class="ki kj ht ke b fv ko kl l km kn">function allowance(address owner, address spender) external view returns (uint256);</span><span id="bab6" class="ki kj ht ke b fv ko kl l km kn">function transfer(address to, uint256 value) external returns (bool);</span><span id="5a08" class="ki kj ht ke b fv ko kl l km kn">function approve(address spender, uint256 value) external returns (bool);</span><span id="ec8f" class="ki kj ht ke b fv ko kl l km kn">function transferFrom(address from, address to, uint256 value) external returns (bool);</span><span id="0895" class="ki kj ht ke b fv ko kl l km kn">event Transfer(<br/>    address indexed from,<br/>    address indexed to,<br/>    uint256 value<br/>  );</span><span id="a3e1" class="ki kj ht ke b fv ko kl l km kn">event Approval(<br/>    address indexed owner,<br/>    address indexed spender,<br/>    uint256 value<br/>  );<br/>}</span></pre><p id="f2b6" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">正如我们所看到的，这个接口只有函数和事件。所有函数都是外部的，没有标记为虚拟的。</p><h1 id="cc14" class="kp kj ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">实现和使用接口</h1><p id="82aa" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">接口是作为子契约实现的，需要重写接口中的所有函数。让我们看一个例子。我们从下面这个简单契约的接口开始，它将向数组中添加值。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="b7fa" class="ki kj ht ke b fv kk kl l km kn">interface IStoreUint {<br/>   function addUint(uint _item) external;<br/>   function getUint(uint _index) external view returns (uint); <br/>}</span></pre><p id="35af" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在让我们在同一个文件中实现这个接口。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="3864" class="ki kj ht ke b fv kk kl l km kn">contract StoreUint is IStoreUint {</span><span id="6859" class="ki kj ht ke b fv ko kl l km kn">uint[] items;</span><span id="c4c9" class="ki kj ht ke b fv ko kl l km kn">function addUint(uint _item) public {<br/>   items.push(_item);<br/>}</span><span id="ac25" class="ki kj ht ke b fv ko kl l km kn">function getUint(uint _index) public view returns (uint) {<br/>    return items[_index];<br/>}<br/>}</span></pre><p id="aed2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">请注意，我们不使用override关键字来覆盖所有函数。以这种方式使用，接口就像一个模式，一种契约的蓝图。</p><p id="100f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">接口的第二个功能是允许向实现这种接口的协定发送调用。</p><p id="b9ee" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">假设契约部署在某个地址，比如说<code class="eh lt lu lv ke b">0xd9145CCE52D386f254917e481eB44e9943F39138</code>。现在，我们想通过另一个契约来执行<code class="eh lt lu lv ke b">addUint()</code>方法。为此，我们可以创建接口的一个实例，如下所示。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="ed56" class="ki kj ht ke b fv kk kl l km kn">IStoreUint storeUint = IStoreUint(0xd9...9138);</span></pre><p id="9ef0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在我们可以从另一个契约中执行该契约的方法。下面，遗嘱执行人合同的完整代码。</p><pre class="jz ka kb kc fq kd ke kf kg aw kh dt"><span id="b183" class="ki kj ht ke b fv kk kl l km kn">contract AddUints {</span><span id="0ed9" class="ki kj ht ke b fv ko kl l km kn">   function addUintInOtherContract(uint _item) public {<br/>      IStoreUint storeUint = IStoreUint(0xd914...9138);<br/>      storeUint.addUint(_item);<br/>   }</span><span id="8e79" class="ki kj ht ke b fv ko kl l km kn">}</span></pre><p id="7f01" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">使用契约<code class="eh lt lu lv ke b">StoreUint</code>，而不是它的接口，可以获得相同的结果。但是接口总是更小，我们经常希望向实现相同接口但实现不同的契约发送调用。</p><p id="c07f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">感谢阅读！</strong></p><p id="712a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎对本文提出意见和建议。</p><p id="d651" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎任何投稿。<a class="ae ls" href="http://www.buymeacoffee.com/jpmorais" rel="noopener ugc nofollow" target="_blank">www.buymeacoffee.com/jpmorais</a>。</p><blockquote class="lw"><p id="b6eb" class="lx ly ht bd lz ma mb mc md me mf jy ek translated">交易新手？尝试<a class="ae ls" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae ls" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>