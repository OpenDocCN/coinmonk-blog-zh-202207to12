<html>
<head>
<title>Learn Solidity lesson 34. Call, staticcall and delegatecall</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习第34课固体。调用、静态调用和委托调用</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/call-staticcall-and-delegatecall-1f0e1853340?source=collection_archive---------0-----------------------#2022-11-11">https://medium.com/coinmonks/call-staticcall-and-delegatecall-1f0e1853340?source=collection_archive---------0-----------------------#2022-11-11</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/1da494d0af5b8799aa1db9d486728ca6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hf7QwDiim0EXw7nL4S9ALg.jpeg"/></div></div></figure><p id="f321" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">EVM有3个操作码可以在Solidity中直接调用:<strong class="jd hu">调用</strong>、<strong class="jd hu">委托调用</strong>和<strong class="jd hu">静态调用</strong>。它们都用于向其他契约发送调用，目的是调用函数或只是向该契约发送以太网。</p><p id="846c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">最近，使用<em class="jz">调用</em>方法向任意地址发送以太成为推荐方式。使用<em class="jz">调用</em>和<em class="jz">转移</em>的主要区别在于<em class="jz">调用</em>将所有气体转发到地址，可以是一个合同的地址。正因为如此，要使用<em class="jz">呼叫</em>发送以太，你必须小心重入问题。</p><p id="8fd7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">顾名思义，重入是目标契约重新进入原契约的一种方式。重入方法可以被恶意使用，就像著名的TheDAO项目黑客事件中发生的那样。在其中，黑客使用重入从原始合同中提取乙醚，而不改变合同中的帐户余额。</p><h1 id="b983" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">打电话</h1><p id="3f49" class="pw-post-body-paragraph jb jc ht jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">我们来看看如何在solidity中使用<em class="jz">调用</em>方法。首先，我们创建一个将被另一个调用的契约。要调用的合同将被命名为<code class="eh ld le lf lg b">Called</code>。</p><pre class="lh li lj lk fq ll lg lm bn ln lo bi"><span id="3316" class="lp kb ht lg b be lq lr l ls lt">contract Called {<br/><br/>  uint public number;<br/><br/>  function increment() public {<br/>    number++;<br/>  }<br/>}</span></pre><p id="aaf0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">必须部署此合同。在我们的示例中，部署是针对<code class="eh ld le lf lg b">0xd9145CCE52D386f254917e481eB44e9943F39138</code>的。现在让我们写一份合同，合同的名字叫<code class="eh ld le lf lg b">Called</code>。它的名字将是<code class="eh ld le lf lg b">Caller</code>。</p><pre class="lh li lj lk fq ll lg lm bn ln lo bi"><span id="d606" class="lp kb ht lg b be lq lr l ls lt">contract Caller {<br/><br/>address public called = 0xd9145CCE52D386f254917e481eB44e9943F39138; <br/>    <br/>function callCalled() public returns(bool, bytes memory) {<br/>        <br/>    (bool success,bytes memory data) = called.call(abi.encodeWithSignature("increment()"));<br/>    <br/>    return (success, data);<br/>}<br/><br/>}</span></pre><p id="137c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在<code class="eh ld le lf lg b">Caller</code>契约中，我们首先创建一个状态变量，它将存储要调用的契约的地址。从地址来看，我们使用的方法<em class="jz">叫做</em>。<strong class="jd hu">调用</strong>(<em class="jz">有效载荷】</em>)。让我们来谈谈有效载荷。</p><p id="2bb5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">调用的有效负载必须包含要调用的函数的签名，4个字节，加上由ABI编码的函数参数。这可以使用<strong class="jd hu"> abi </strong>对象的<strong class="jd hu"> encodeWithSignature </strong>方法来完成。在我们的函数中，没有参数。</p><p id="3e6b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><em class="jz">调用</em>方法返回一对值:一个通知函数是否成功执行的布尔值，以及一个包含函数返回的字节类型的值，也是ABI编码的。</p><figure class="lh li lj lk fq iu fe ff paragraph-image"><div class="fe ff lu"><img src="../Images/ccaddc6fdcd72be21aebaac99fce24b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:982/format:webp/1*PeJw4QvolqVRepcBg__FlA.png"/></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">The return of the call.</figcaption></figure><p id="639d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">调用的结果可以在上图中看到。布尔值为<code class="eh ld le lf lg b">true</code>，表示交易成功。bytes类型的变量为空，因为该函数不返回任何内容。</p><h1 id="fdff" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">带参数和返回的函数</h1><p id="4dff" class="pw-post-body-paragraph jb jc ht jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">让我们稍微修改一下要调用的函数。现在它将接收一个参数并返回变量<code class="eh ld le lf lg b">number</code>的新值。</p><pre class="lh li lj lk fq ll lg lm bn ln lo bi"><span id="404d" class="lp kb ht lg b be lq lr l ls lt">function increment(uint _increment) public returns (uint) {<br/>  number = number + _increment;<br/>  return number;<br/>}</span></pre><p id="97ee" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">请注意，您需要再次部署合同，因为<code class="eh ld le lf lg b">Called</code>在<code class="eh ld le lf lg b">Caller</code>的地址必须更改。该地址目前正被直接写入代码中，但也可以保存在一个变量中。这就是我们如何编写可升级合同，不同之处在于我们使用<strong class="jd hu">委托调用</strong>而不是<em class="jz">调用</em>。我们很快就会看到<em class="jz">委派电话</em>的情况。</p><p id="5101" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们也改变一下<code class="eh ld le lf lg b">Caller</code>中的调用函数。</p><pre class="lh li lj lk fq ll lg lm bn ln lo bi"><span id="58b5" class="lp kb ht lg b be lq lr l ls lt">function callCalled() public returns(bool, bytes memory) {<br/>  (bool success,bytes memory data) = called.call(abi.encodeWithSignature("increment(uint256)",2));<br/>  return (success, data);<br/>}</span></pre><p id="7183" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在我们需要传递参数给<em class="jz">调用</em>函数。在我们的示例中，参数直接在代码中传递，编码如下:</p><pre class="lh li lj lk fq ll lg lm bn ln lo bi"><span id="ea78" class="lp kb ht lg b be lq lr l ls lt">abi.encodeWithSignature("increment(uint256)",2)</span></pre><p id="8166" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><em class="jz"> encodeWithSignature </em>方法接受任意数量的参数，我们必须传递调用该函数所需的所有参数。</p><figure class="lh li lj lk fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff lz"><img src="../Images/3169f8e5ef11d8a34e12a406e362f4d1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vsZX9GtKC5GAWVnSXjo13A.png"/></div></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">The return of a call from a function that has a return.</figcaption></figure><p id="026a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在上图中，我们看到函数的返回类型为bytes。该回报由合约的ABI编码。我们也可以解码返回。让我们在下面的函数中看到这一点。</p><pre class="lh li lj lk fq ll lg lm bn ln lo bi"><span id="5b0d" class="lp kb ht lg b be lq lr l ls lt">function callCalled() public returns(bool, uint) {<br/>  (bool success,bytes memory data) = called.call(abi.encodeWithSignature("increment(uint256)",2)); <br/>  uint decoded = abi.decode(data, (uint256));<br/>  return (success, decoded);<br/>}</span></pre><p id="c5e3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">为了解码返回，我们使用<strong class="jd hu"> <em class="jz"> abi </em> </strong>对象的<strong class="jd hu"> decode </strong>方法。它需要两个参数:要解码的字节类型的变量和包含字节将被解码的类型的元组。</p><figure class="lh li lj lk fq iu fe ff paragraph-image"><div class="fe ff ma"><img src="../Images/9893e1e01510b0dd7d7eb3eeb6023f5f.png" data-original-src="https://miro.medium.com/v2/resize:fit:924/format:webp/1*Ekd-k6N-S78V3R84VatsAg.png"/></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">We can decode the return into its types.</figcaption></figure><p id="6c29" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在上图中，我们看到使用<em class="jz">解码</em>方法解码的返回结果。</p><h1 id="2eb6" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">发送以太网</h1><p id="163a" class="pw-post-body-paragraph jb jc ht jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">如前所述，目前推荐的发送以太网到另一个地址的方法是使用<em class="jz">调用</em>。使用<em class="jz">调用</em>时，可以显示要发送的值和要发送的气体量。</p><p id="7302" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">指示要发送的值是常见的，但不建议指示要发送的气体量。要将以太发送到一个地址，无论是否是合同，我们使用如下的<em class="jz">调用</em>方法。</p><pre class="lh li lj lk fq ll lg lm bn ln lo bi"><span id="fb3a" class="lp kb ht lg b be lq lr l ls lt">address.call{value: 1 ether}("")</span></pre><p id="6309" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在上面的例子中，1 Ether的值被发送到地址<em class="jz">地址</em>，其有效载荷为空。如果我们还想调用一个函数，也可以发送一个有效载荷。</p><p id="1a36" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">为了定义要输送的气体量，我们使用<em class="jz">气体</em>属性，如下所示:</p><pre class="lh li lj lk fq ll lg lm bn ln lo bi"><span id="e005" class="lp kb ht lg b be lq lr l ls lt">address.call{value: 1 ether, gas: 10000}("")</span></pre><h1 id="63b4" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">静态调用</h1><p id="e8b8" class="pw-post-body-paragraph jb jc ht jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated"><strong class="jd hu"> Staticcall </strong>是一个类似于<em class="jz">调用</em>的方法，但是它不允许改变区块链的状态。这意味着我们不能使用<em class="jz"> staticcall </em>，例如，如果被调用的函数改变了某个状态变量。</p><p id="46db" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在下图中，我们将方法<em class="jz">调用</em>替换为<em class="jz">静态调用</em>。通过这样做，编译器给我们一个警告，函数<code class="eh ld le lf lg b">callSetNumber</code>可以声明为<em class="jz">视图</em>，因为<em class="jz"> staticcall </em>不允许改变区块链的状态。</p><figure class="lh li lj lk fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mb"><img src="../Images/a98c51650a271d16ef0dd607b6801368.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XATPgi84m6Y2HtKauZwMLA.png"/></div></div><figcaption class="lv lw fg fe ff lx ly bd b be z ek">The staticcall method does not allow changing the state of the blockchain.</figcaption></figure><p id="0b8f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果我们使用<em class="jz"> staticcall </em>来调用一个改变区块链状态的函数，这个函数调用将不会成功。</p><p id="6710" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们可以使用<em class="jz"> staticcall </em>来读取状态变量。以下代码行完全有效。</p><pre class="lh li lj lk fq ll lg lm bn ln lo bi"><span id="692c" class="lp kb ht lg b be lq lr l ls lt">(, bytes memory data) = called.staticcall(abi.encodeWithSignature("number()"));</span></pre><p id="9cdb" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">和<em class="jz">调用</em>一样，<em class="jz"> staticcall </em>返回两个值。一个布尔值，指示调用是否成功，以及一个bytes类型的值，它是调用的返回。由于<em class="jz"> staticcall </em>不会改变区块链的状态，所以只有当我们想要检索某个值时，执行这个方法才有意义；也就是说，当我们期待一些回报的时候。</p><h1 id="dbc1" class="ka kb ht bd kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx dt translated">委派电话</h1><p id="9bcc" class="pw-post-body-paragraph jb jc ht jd b je ky jg jh ji kz jk jl jm la jo jp jq lb js jt ju lc jw jx jy hm dt translated">也有可能在另一个契约中执行一个函数，但是这样会改变调用契约的状态变量。为此，使用方法<strong class="jd hu"> delegatecall </strong>。</p><p id="7825" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们创建一个将被调用的契约，命名为<code class="eh ld le lf lg b">Called</code>。</p><pre class="lh li lj lk fq ll lg lm bn ln lo bi"><span id="2711" class="lp kb ht lg b be lq lr l ls lt">contract Called {<br/><br/>  uint public number;<br/><br/>  function setNumber(uint _number) public {<br/>    number = _number;<br/>  }<br/>}</span></pre><p id="f99c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">让我们现在写合同，将调用<code class="eh ld le lf lg b">Called</code>，命名为<code class="eh ld le lf lg b">Caller</code>。</p><pre class="lh li lj lk fq ll lg lm bn ln lo bi"><span id="4a95" class="lp kb ht lg b be lq lr l ls lt">contract Caller {<br/><br/>  uint public number;<br/>  address public called = 0xd9145CCE52D386f254917e481eB44e9943F39138;<br/>  <br/>  function callSetNumber(uint _number) public {<br/>    called.delegatecall(abi.encodeWithSignature("setNumber(uint256)",_number));<br/>  }<br/>}</span></pre><p id="e6b9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh ld le lf lg b">callSetNumber</code>函数将调用<code class="eh ld le lf lg b">Called</code>上的<code class="eh ld le lf lg b">setNumber</code>函数，这将改变<code class="eh ld le lf lg b">number</code>变量。然而，它将改变契约<code class="eh ld le lf lg b">Caller</code>的变量<code class="eh ld le lf lg b">number</code>，而不是定义该函数的契约的变量<code class="eh ld le lf lg b">number</code>。</p><p id="41be" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">与<em class="jz">调用</em>一样，<em class="jz"> delegatecall </em>也返回两个值。第一个是布尔值，表示事务是否成功，第二个是bytes类型，表示函数的返回(如果出现任何返回)。</p><p id="56cd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在上面的例子中，我们在两个契约中使用了相同的状态变量名称，<em class="jz">号</em>，但这不是必须的。变量的名字并不重要，重要的是它在存储中的位置。我们需要理解这一点。</p><p id="114e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">使用<em class="jz"> delegatecall </em>，在调用契约的存储器中执行。因此，我们需要确保两个合同的变量正确配对。</p><p id="616e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">以太坊的存储由一系列32字节的容器组成，每个容器可以包含一个或多个状态变量。在调用契约中，变量<code class="eh ld le lf lg b">number</code>占用第一个容器，而变量<code class="eh ld le lf lg b">called</code>部分占用第二个容器。</p><p id="f3f4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当我们调用函数<code class="eh ld le lf lg b">setNumber</code>时，它改变第一个容器，而不管那里是哪个变量。因为调用契约中的变量是我们想要改变的变量，<code class="eh ld le lf lg b">number</code>，所以一切都按计划进行。</p><p id="784d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在我们来做个改变。让我们颠倒一下变量<code class="eh ld le lf lg b">number</code>和<code class="eh ld le lf lg b">called </code>的声明顺序，如下所示。</p><pre class="lh li lj lk fq ll lg lm bn ln lo bi"><span id="0a68" class="lp kb ht lg b be lq lr l ls lt">contract Caller {<br/><br/>  address public called = 0xd9145CCE52D386f254917e481eB44e9943F39138;<br/>  uint public number;<br/>  <br/>  function callSetNumber(uint _number) public {<br/>    called.delegatecall(abi.encodeWithSignature("setNumber(uint256)",_number));<br/>  }<br/>}</span></pre><p id="9c46" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh ld le lf lg b">setNumber</code>函数会一直改变第一个容器，但是现在变量<code class="eh ld le lf lg b">called</code>在第一个容器中，不再是<code class="eh ld le lf lg b">number</code>了。在执行<code class="eh ld le lf lg b">callSetNumber</code>的时候，会改变变量<code class="eh ld le lf lg b">called</code>，改变要调用的契约的地址，完全破解代码。</p><p id="d5c4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这就是为什么我们在使用<em class="jz"> delegatecall </em>时要小心的原因。需要确切地知道正在做什么，理想的情况是将两个契约中的变量配对，调用契约和被调用契约。</p><p id="b26e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">感谢阅读！</strong></p><p id="6d9e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎对本文提出意见和建议。</p><p id="3ac5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎任何投稿。<a class="ae mc" href="http://www.buymeacoffee.com/jpmorais" rel="noopener ugc nofollow" target="_blank">www.buymeacoffee.com/jpmorais</a>。</p><blockquote class="md"><p id="def5" class="me mf ht bd mg mh mi mj mk ml mm jy ek translated">交易新手？尝试<a class="ae mc" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae mc" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>