<html>
<head>
<title>Learn Solidity lesson 29. OpenZeppelin’s implementation of the ERC20 token.</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学习第29课固体。OpenZeppelin对ERC20令牌的实现。</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/learn-solidity-lesson-29-openzeppelins-implementation-of-the-erc20-token-9739f7ff015a?source=collection_archive---------2-----------------------#2022-08-23">https://medium.com/coinmonks/learn-solidity-lesson-29-openzeppelins-implementation-of-the-erc20-token-9739f7ff015a?source=collection_archive---------2-----------------------#2022-08-23</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/fe4baf41e8c44bf0252f0e61effe1874.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zIkbw0CPDL17FpZ7OXhAVg.jpeg"/></div></div></figure><p id="4d8e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">OpenZeppelin是一家专门从事加密和安全的公司。它提供了一个智能合约的开源库，其可替换和不可替换的令牌实现是当今使用最广泛的。</p><p id="5d32" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">使用OpenZeppelin库实现ERC20令牌非常简单。在他们的网站上有一个名为<em class="jz">向导</em>的用户界面，它根据用户提供的信息编写合同代码。</p><figure class="kb kc kd ke fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff ka"><img src="../Images/aaeedd67939d50c3610d0ddf6202d322.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gexJa3U9Uwu8tPgsxXiaTA.png"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">You can easily create an ERC20 token using OpenZeppelin libraries.</figcaption></figure><p id="be13" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">用户界面如上图所示。目前，<em class="jz">向导</em>可以在地址<a class="ae kj" href="https://docs.openzeppelin.com/contracts/4.x/wizard" rel="noopener ugc nofollow" target="_blank">https://docs.openzeppelin.com/contracts/4.x/wizard</a>访问</p><p id="1615" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在这一课中，我们将更详细地了解OpenZeppelin的实现，以及一些基本的扩展。它以模块化方式实现了ERC20令牌的所有功能。因此，有可能只包含我们想要的扩展。</p><p id="a4ac" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们先从理解上图所示的合同开始，下面我来复制一下。</p><pre class="kb kc kd ke fq kk kl km kn aw ko dt"><span id="349b" class="kp kq ht kl b fv kr ks l kt ku">pragma solidity ^0.8.4;</span><span id="5806" class="kp kq ht kl b fv kv ks l kt ku">import "<a class="ae kj" href="http://twitter.com/openzeppelin/contracts" rel="noopener ugc nofollow" target="_blank">@openzeppelin/contracts</a>/token/ERC20/ERC20.sol";</span><span id="d719" class="kp kq ht kl b fv kv ks l kt ku">contract MyToken is ERC20 {<br/>   constructor() ERC20("MyToken", "MTK") {<br/>      _mint(msg.sender, 1000000 * 10 ** decimals());<br/>   }<br/>}</span></pre><p id="c1a4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">首先，我们从OpenZepellin库导入契约<code class="eh kw kx ky kl b">ERC20.sol</code>，使用关键字<code class="eh kw kx ky kl b">import</code>，后跟契约地址。Remix可以通过这个地址导入合同。我们将更详细地了解这个实现。</p><p id="7c42" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在合同声明中，我们使用关键字<code class="eh kw kx ky kl b">is</code>。这意味着契约<code class="eh kw kx ky kl b">MyToken</code>是契约<code class="eh kw kx ky kl b">ERC20</code>的子契约，它继承了它的一些变量和功能。我们将在以后的课程中进一步研究继承的问题。</p><p id="7051" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在子契约<code class="eh kw kx ky kl b">MyToken </code>的构造函数中，我们也运行父契约<code class="eh kw kx ky kl b">ERC20</code>的构造函数，并传递两个参数:<code class="eh kw kx ky kl b">MyToken</code>，令牌的名称，和<code class="eh kw kx ky kl b">MTK</code>，令牌符号。在构造函数中，我们调用函数<code class="eh kw kx ky kl b">_mint</code>，它负责生成新的令牌。该功能在母合同<code class="eh kw kx ky kl b">ERC20</code>中定义。我们来看看是怎么定义的。</p><pre class="kb kc kd ke fq kk kl km kn aw ko dt"><span id="33d3" class="kp kq ht kl b fv kr ks l kt ku">function _mint(address account, uint256 amount) internal virtual {</span><span id="12de" class="kp kq ht kl b fv kv ks l kt ku">   require(account != address(0), "ERC20: mint to the zero address");<br/>   _beforeTokenTransfer(address(0), account, amount);<br/>    <br/>   _totalSupply += amount;<br/>   unchecked {<br/>      _balances[account] += amount;<br/>   }<br/>   emit Transfer(address(0), account, amount);</span><span id="7435" class="kp kq ht kl b fv kv ks l kt ku">   _afterTokenTransfer(address(0), account, amount);<br/>}</span></pre><p id="63df" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">函数<code class="eh kw kx ky kl b">_mint </code>被声明为<code class="eh kw kx ky kl b">virtual</code>。我们还没有看到这意味着什么，但它与继承有关，并且对令牌构造没有太大影响。</p><p id="3316" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在<code class="eh kw kx ky kl b">_mint</code>函数中，调用了两个函数:<code class="eh kw kx ky kl b">_beforeTokenTransfer</code>和<code class="eh kw kx ky kl b">_afterTokenTransfer</code>。OpenZeppelin调用这些函数<em class="jz">钩子</em>,因为它们可以被改变以在令牌传输之前和之后提供功能。原则上，这样的函数被声明为空，我们不会在本课中更改它们。</p><p id="bdc4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh kw kx ky kl b">_mint</code>函数铸造令牌并将它们发送到给定的帐户。由于这些代币是凭空创造出来的，因此必须考虑到这一点，增加总供给。</p><p id="1fe7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">关键字<code class="eh kw kx ky kl b">unchecked</code>用于使某个账户不被检查溢出和下溢。它被OpenZeppelin用来减少气体的使用。</p><p id="3aaa" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">根据ERC20标准，每个令牌传输都必须发出一个<code class="eh kw kx ky kl b">Transfer</code>事件。由于令牌是凭空创建的，即没有发送方，因此发送方必须声明为地址零。</p><h1 id="6211" class="kz kq ht bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv dt translated">私有状态变量</h1><p id="c610" class="pw-post-body-paragraph jb jc ht jd b je lw jg jh ji lx jk jl jm ly jo jp jq lz js jt ju ma jw jx jy hm dt translated">在OpenZeppelin库中，状态变量被声明为私有的，这与我们在上一课中所做的不同。合同的第一行可以在下面看到。</p><pre class="kb kc kd ke fq kk kl km kn aw ko dt"><span id="9fef" class="kp kq ht kl b fv kr ks l kt ku">mapping(address =&gt; uint256) private _balances;<br/>mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;<br/>uint256 private _totalSupply;<br/>string private _name;<br/>string private _symbol;</span></pre><p id="843d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">所以我们不需要命名保存账户余额<code class="eh kw kx ky kl b">balanceOf</code>的状态变量。在OpenZeppelin的ERC20合约中，它被命名为<code class="eh kw kx ky kl b">_balances</code>。但是，返回这些信息的函数必须命名为<code class="eh kw kx ky kl b">balanceOf</code>。下面我们可以看到它的实现。</p><pre class="kb kc kd ke fq kk kl km kn aw ko dt"><span id="78bf" class="kp kq ht kl b fv kr ks l kt ku">function balanceOf(address account) public view virtual override returns (uint256) {<br/>   return _balances[account];<br/>}</span></pre><p id="20c1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">关键字<code class="eh kw kx ky kl b">override </code>到目前为止还没有被研究过，但是它也与继承有关，我们现在可以忽略它。</p><p id="5ecc" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">同样，除了返回变量<code class="eh kw kx ky kl b">_allowance</code>的<code class="eh kw kx ky kl b">allowance</code>函数之外，还需要声明外部(或公共)函数来返回合同的名称、符号和总供应量。这些函数的主体非常简单。例如，<code class="eh kw kx ky kl b">allowance</code>函数的构造如下。</p><pre class="kb kc kd ke fq kk kl km kn aw ko dt"><span id="ab85" class="kp kq ht kl b fv kr ks l kt ku">function allowance(address owner, address spender) public view virtual override returns (uint256) {<br/>   return _allowances[owner][spender];<br/>}</span></pre><p id="f835" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们应该注意的一个问题是定义令牌中小数位数的函数。OpenZeppelin契约内置了这个函数(毕竟它是强制的)。</p><pre class="kb kc kd ke fq kk kl km kn aw ko dt"><span id="50d5" class="kp kq ht kl b fv kr ks l kt ku">function decimals() public view virtual override returns (uint8) {<br/>   return 18;<br/>}</span></pre><p id="43dc" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果你想改变小数位数，你必须声明你自己的<code class="eh kw kx ky kl b">decimals</code>函数，覆盖上述函数。你不应该直接改变上面的函数。</p><p id="eff0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">重写函数是在子契约中声明一个同名的函数。在下图中，我们使用OpenZeppelin库在Remix中编写了一个令牌契约，覆盖了<code class="eh kw kx ky kl b">decimals</code>函数。</p><figure class="kb kc kd ke fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mb"><img src="../Images/66eef0b404929e6779a7966dbe2fde1b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*yQ3KF-TvAIdLcLg4tHXZgQ.png"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">To change the number of decimal places, we must declare our own decimals function.</figcaption></figure><p id="810a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">关于OpenZeppelin的ERC20令牌，我应该注意的另一个问题是，它没有给<code class="eh kw kx ky kl b">_totalSupply</code>变量赋值。如果我们想以初始供应开始合同，我们必须使用<code class="eh kw kx ky kl b">_mint </code>函数，正如我们在示例中所做的那样。</p><h1 id="ad98" class="kz kq ht bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv dt translated">转移和转移自</h1><p id="4b9c" class="pw-post-body-paragraph jb jc ht jd b je lw jg jh ji lx jk jl jm ly jo jp jq lz js jt ju ma jw jx jy hm dt translated"><code class="eh kw kx ky kl b">transfer </code>和<code class="eh kw kx ky kl b">transferFrom</code>函数都是传递函数，部分实现相同的逻辑:减少发送方余额和增加接收方余额。因此，OpenZeppelin库定义了一个名为<code class="eh kw kx ky kl b">_transfer</code>的通用内置函数。</p><pre class="kb kc kd ke fq kk kl km kn aw ko dt"><span id="5729" class="kp kq ht kl b fv kr ks l kt ku">function _transfer(address from, address to, uint256 amount) internal virtual {<br/>        <br/>   require(from != address(0), "ERC20: transfer from the zero address");<br/>   require(to != address(0), "ERC20: transfer to the zero address");</span><span id="ff25" class="kp kq ht kl b fv kv ks l kt ku">   _beforeTokenTransfer(from, to, amount);</span><span id="20e5" class="kp kq ht kl b fv kv ks l kt ku">   uint256 fromBalance = _balances[from];</span><span id="f6a2" class="kp kq ht kl b fv kv ks l kt ku">   require(fromBalance &gt;= amount, "ERC20: transfer amount exceeds balance");<br/>   unchecked {<br/>      _balances[from] = fromBalance - amount;<br/>      _balances[to] += amount;<br/>   }</span><span id="9305" class="kp kq ht kl b fv kv ks l kt ku">   emit Transfer(from, to, amount);<br/>   _afterTokenTransfer(from, to, amount);<br/>}</span></pre><p id="923e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">和<code class="eh kw kx ky kl b">_mint </code>函数一样，<code class="eh kw kx ky kl b">_transfer</code>函数也实现了<em class="jz">钩子</em>。基本上，它将令牌从<code class="eh kw kx ky kl b">from</code>帐户转移到<code class="eh kw kx ky kl b">to</code>帐户，而不检查权限。此类权限必须在调用<code class="eh kw kx ky kl b">_transfer</code>函数的函数中进行验证。</p><p id="177d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">例如，公共函数<code class="eh kw kx ky kl b">transfer</code>明确地定义了参数<code class="eh kw kx ky kl b">from</code>就是<code class="eh kw kx ky kl b">msg.sender</code>，正如我们在前一课中看到的。OpenZeppelin的实现如下。</p><pre class="kb kc kd ke fq kk kl km kn aw ko dt"><span id="28cd" class="kp kq ht kl b fv kr ks l kt ku">function transfer(address to, uint256 amount) public virtual override returns (bool) {<br/>   address owner = _msgSender();<br/>   _transfer(owner, to, amount);<br/>   return true;<br/>}</span></pre><p id="1e12" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在调用<code class="eh kw kx ky kl b">_transfer</code>函数之前，<code class="eh kw kx ky kl b">transferFrom</code>函数检查调用该函数的人是否有权代表<code class="eh kw kx ky kl b">from</code>账户转移令牌。它还改变<code class="eh kw kx ky kl b">_allowance</code>以贴现转账金额。在上一课中，我们看到了这种需要。OpenZeppelin的实现如下。</p><pre class="kb kc kd ke fq kk kl km kn aw ko dt"><span id="1629" class="kp kq ht kl b fv kr ks l kt ku">function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {<br/>   address spender = _msgSender();<br/>   _spendAllowance(from, spender, amount);<br/>   _transfer(from, to, amount);<br/>   return true;<br/>}</span></pre><p id="cbf7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">为了验证上面的函数实现了ERC20令牌中所需的内容，我们必须看到内置函数<code class="eh kw kx ky kl b">_spendAllowance</code>的实现。</p><pre class="kb kc kd ke fq kk kl km kn aw ko dt"><span id="1ea5" class="kp kq ht kl b fv kr ks l kt ku">function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {</span><span id="9a68" class="kp kq ht kl b fv kv ks l kt ku">   uint256 currentAllowance = allowance(owner, spender);<br/>   if (currentAllowance != type(uint256).max) {<br/>      require(currentAllowance &gt;= amount, "ERC20: insufficient allowance");<br/>      unchecked {<br/>      _approve(owner, spender, currentAllowance - amount);<br/>      }<br/>   }<br/>}</span></pre><p id="f0e7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">函数<code class="eh kw kx ky kl b">_spendAllowance</code>检查变量<code class="eh kw kx ky kl b">_allowance</code>是否允许传输。要求<code class="eh kw kx ky kl b">currentAllowance</code>大于或等于参数<code class="eh kw kx ky kl b">amount</code>。如果允许，它调用函数<code class="eh kw kx ky kl b">_approve</code>来改变变量<code class="eh kw kx ky kl b">_allowance</code>的值，减少使用的值。在上一课中，我们已经看到了这些过程。</p><p id="2e60" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">但是现在有了一种新的成分。注意在上面的函数中有一个条件，它检查<code class="eh kw kx ky kl b">_allowance</code>是否不同于<code class="eh kw kx ky kl b">type(uint256).max</code>。让我们明白这一点。</p><p id="062b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">表达式<code class="eh kw kx ky kl b">type(uint256).max</code>返回类型<em class="jz"> uint256 </em>的最大值，即2 ⁵⁶ — 1。如果津贴是在这个值，这意味着无限转让许可。当一个帐户允许另一个帐户代表其转移<code class="eh kw kx ky kl b">type(uint256).max</code>代币的价值时，这意味着该权限是无限的，并且不需要验证金额或减少转移的总额。</p><p id="5b14" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们还没有展示<code class="eh kw kx ky kl b">_approve</code>函数，但是它非常简单。</p><pre class="kb kc kd ke fq kk kl km kn aw ko dt"><span id="dd10" class="kp kq ht kl b fv kr ks l kt ku">function _approve(address owner, address spender, uint256 amount) internal virtual {<br/>   require(owner != address(0), "ERC20: approve from the zero address");<br/>   require(spender != address(0), "ERC20: approve to the zero address");</span><span id="d76e" class="kp kq ht kl b fv kv ks l kt ku">   _allowances[owner][spender] = amount;<br/>   emit Approval(owner, spender, amount);<br/>}</span></pre><p id="fa44" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh kw kx ky kl b">_approve </code>功能与上一课中的功能非常相似。唯一增加的是，它检查是否有任何地址是地址零，不允许这样。</p><h1 id="1fd3" class="kz kq ht bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv dt translated">新功能</h1><p id="1460" class="pw-post-body-paragraph jb jc ht jd b je lw jg jh ji lx jk jl jm ly jo jp jq lz js jt ju ma jw jx jy hm dt translated">OpenZeppelin实现包括一些ERC20标准没有定义的功能。其中两个用来更好的操纵变量<code class="eh kw kx ky kl b">_allowance</code> : <code class="eh kw kx ky kl b">increaseAllowance</code>和<code class="eh kw kx ky kl b">decreaseAllowance</code>。</p><p id="da22" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh kw kx ky kl b">increaseAllowance </code>功能用于增加一个账户允许另一个账户代其转账的金额。</p><pre class="kb kc kd ke fq kk kl km kn aw ko dt"><span id="8ba0" class="kp kq ht kl b fv kr ks l kt ku">function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {<br/>   address owner = _msgSender();<br/>   _approve(owner, spender, allowance(owner, spender) + addedValue);<br/>   return true;<br/>}</span></pre><p id="2f5f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh kw kx ky kl b">decreaseAllowance</code>功能具有相反的目的，减少一个账户允许另一个账户代表你转账的金额。</p><p id="51bd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">OpenZeppelin实现的最后一个函数是<code class="eh kw kx ky kl b">_burn</code>函数，它的作用是燃烧令牌。烧毁的代币从帐户余额中扣除，也从合同的总供应量中扣除。</p><pre class="kb kc kd ke fq kk kl km kn aw ko dt"><span id="16cd" class="kp kq ht kl b fv kr ks l kt ku">function _burn(address account, uint256 amount) internal virtual {<br/>   require(account != address(0), "ERC20: burn from the zero address");</span><span id="607e" class="kp kq ht kl b fv kv ks l kt ku">   _beforeTokenTransfer(account, address(0), amount);</span><span id="74a6" class="kp kq ht kl b fv kv ks l kt ku">   uint256 accountBalance = _balances[account];<br/>   require(accountBalance &gt;= amount, "ERC20: burn amount exceeds balance");<br/>    <br/>   unchecked {<br/>      _balances[account] = accountBalance - amount;<br/>      _totalSupply -= amount;<br/>   }</span><span id="9eb7" class="kp kq ht kl b fv kv ks l kt ku">   emit Transfer(account, address(0), amount);</span><span id="793e" class="kp kq ht kl b fv kv ks l kt ku">   _afterTokenTransfer(account, address(0), amount);<br/>}</span></pre><p id="c537" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh kw kx ky kl b">_burn </code>函数假设令牌被传输到地址零，因此<code class="eh kw kx ky kl b">Transfer</code>事件将地址零作为接收方。</p><h1 id="e217" class="kz kq ht bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv dt translated">可铸造和可燃烧的</h1><p id="bbfa" class="pw-post-body-paragraph jb jc ht jd b je lw jg jh ji lx jk jl jm ly jo jp jq lz js jt ju ma jw jx jy hm dt translated">OpenZeppelin实现可以创建可铸造和可燃烧的令牌。也就是说，可以通过铸造新代币或燃烧现有代币来改变其总供应量的代币。</p><p id="7032" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">为了使令牌可铸造，我们必须在契约中添加一个函数。</p><pre class="kb kc kd ke fq kk kl km kn aw ko dt"><span id="cf9d" class="kp kq ht kl b fv kr ks l kt ku">function mint(address to, uint256 amount) public onlyOwner {<br/>   _mint(to, amount);<br/>}</span></pre><p id="d0cd" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这个函数所做的就是将内置函数<code class="eh kw kx ky kl b">_mint</code>公开，只要调用这个函数的是契约的所有者<em class="jz">T21。这种验证由<code class="eh kw kx ky kl b">onlyOwner</code>修改器完成。</em></p><p id="b42e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh kw kx ky kl b">onlyOwner</code>修饰符由另一个OpenZeppelin库实现，该库必须被导入。</p><pre class="kb kc kd ke fq kk kl km kn aw ko dt"><span id="db23" class="kp kq ht kl b fv kr ks l kt ku">import "<a class="ae kj" href="http://twitter.com/openzeppelin/contracts" rel="noopener ugc nofollow" target="_blank">@openzeppelin/contracts</a>/access/Ownable.sol";</span></pre><p id="10a9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在导入之后，还需要定义正在讨论的契约，在本例中是MyToken，是<code class="eh kw kx ky kl b">Ownable</code>库的子库。</p><pre class="kb kc kd ke fq kk kl km kn aw ko dt"><span id="4cdf" class="kp kq ht kl b fv kr ks l kt ku">contract MyToken is ERC20, Ownable { ... }</span></pre><p id="938c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这个库我就不详细解释了，但是很简单。定义一个名为<code class="eh kw kx ky kl b">_owner</code>的状态变量，它将是负责部署契约的帐户。<code class="eh kw kx ky kl b">onlyOwner </code>修饰符只验证调用交易的账户与变量<code class="eh kw kx ky kl b">_owner</code>的地址相同。</p><p id="2c02" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">要使契约可燃烧，只需从OpenZeppelin导入一个库。</p><pre class="kb kc kd ke fq kk kl km kn aw ko dt"><span id="7d90" class="kp kq ht kl b fv kr ks l kt ku">import "<a class="ae kj" href="http://twitter.com/openzeppelin/contracts" rel="noopener ugc nofollow" target="_blank">@openzeppelin/contracts</a>/token/ERC20/extensions/ERC20Burnable.sol";</span></pre><p id="0b63" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这样的库实现了两个功能。第一个是公共函数<code class="eh kw kx ky kl b">burn</code>，它允许您从外部调用函数<code class="eh kw kx ky kl b">_burn</code>。</p><pre class="kb kc kd ke fq kk kl km kn aw ko dt"><span id="314a" class="kp kq ht kl b fv kr ks l kt ku">function burn(uint256 amount) public virtual {<br/>   _burn(_msgSender(), amount);<br/>}</span></pre><p id="44b7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">第二个是<code class="eh kw kx ky kl b">burnFrom</code>函数，它允许你从其他帐户刻录令牌，只要调用该函数的人有权限这样做。函数<code class="eh kw kx ky kl b">burnFrom</code>类似于<code class="eh kw kx ky kl b">transferFrom</code>，但它不是传输令牌，而是刻录令牌。</p><pre class="kb kc kd ke fq kk kl km kn aw ko dt"><span id="ac3f" class="kp kq ht kl b fv kr ks l kt ku">function burnFrom(address account, uint256 amount) public virtual {<br/>   _spendAllowance(account, _msgSender(), amount);<br/>   _burn(account, amount);<br/>}</span></pre><p id="0364" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">对于MyToken契约已知的这些函数，它需要是<code class="eh kw kx ky kl b">ERC20Burnable</code>库的子库。一份全新的可燃合同应定义如下。</p><pre class="kb kc kd ke fq kk kl km kn aw ko dt"><span id="bde9" class="kp kq ht kl b fv kr ks l kt ku">contract MyToken is ERC20, ERC20Burnable, Ownable {...}</span></pre><p id="2bfb" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">幸运的是，OpenZeppelin的向导工具为我们完成了所有的配置。下图显示了创建一个可铸造和可燃烧的ERC-20合同的最终结果。</p><figure class="kb kc kd ke fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mc"><img src="../Images/de86ad3173f0cbf81f7c6734e32ac5fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VluKRD1r0yxiYsSJu2me6A.png"/></div></div><figcaption class="kf kg fg fe ff kh ki bd b be z ek">A mintable and burnable ERC20 token contract built with the OpenZeppelin library.</figcaption></figure><p id="c148" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">感谢阅读！</strong></p><p id="6c03" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎对本文提出意见和建议。</p><p id="e78d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">欢迎任何投稿。<a class="ae kj" href="http://www.buymeacoffee.com/jpmorais" rel="noopener ugc nofollow" target="_blank">www.buymeacoffee.com/jpmorais</a>。</p><blockquote class="md"><p id="f941" class="me mf ht bd mg mh mi mj mk ml mm jy ek translated">交易新手？尝试<a class="ae kj" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae kj" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>