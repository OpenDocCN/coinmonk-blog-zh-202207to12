<html>
<head>
<title>Create Your Own Encrypted Password Manager Using a Solidity Smart Contract</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Solidity智能合同创建您自己的加密密码管理器</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/create-your-own-encrypted-password-manager-using-a-solidity-smart-contract-3a5ec71cae1?source=collection_archive---------5-----------------------#2022-11-28">https://medium.com/coinmonks/create-your-own-encrypted-password-manager-using-a-solidity-smart-contract-3a5ec71cae1?source=collection_archive---------5-----------------------#2022-11-28</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/a7c4d73f2cd827abaec3d5249e2359a1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*qA9Cg4OqKVitTOFF"/></div></div></figure><p id="b994" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">随着智能合约的使用增加，它在金融科技和通用系统中占据主导地位，我们需要了解这些公共链上个人信息的安全性，这一点至关重要。</p><p id="8f80" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">本指南绝不是生产就绪，但它将向您展示您需要了解如何在智能合同中存储加密数据的基础，使不良行为者更难从链中解密和泄露用户信息。</p><p id="a71e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">安装一个NodeJS环境，并在Src目录中设置一个名为Encrypt.js的简单脚本。</p><p id="8878" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在项目目录中打开一个新的终端窗口，并运行以下命令:</p><pre class="jz ka kb kc fq kd ke kf bn kg kh bi"><span id="3405" class="ki kj ht ke b be kk kl l km kn">npm i dotenv --save<br/>npm i crypto-js --save</span></pre><p id="b065" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">打开Encrypt.js，导入dotenv和crypto-js库，然后保存:</p><pre class="jz ka kb kc fq kd ke kf bn kg kh bi"><span id="c042" class="ki kj ht ke b be kk kl l km kn">require('dotenv').config();<br/><br/>const CryptoJS = require('crypto-js');</span></pre><p id="0ce2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在项目目录的顶层创建一个新文件，文件名为“”。env”。</p><p id="5c8a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">⚠️ <strong class="jd hu">确保如果使用这个项目的git库添加这个文件到你的. gitignore. </strong></p><p id="3777" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">将以下内容复制到您的新。env文件，设置您的密钥(这是用于加密和解密)一旦设置保存此文件:</p><pre class="jz ka kb kc fq kd ke kf bn kg kh bi"><span id="74da" class="ki kj ht ke b be kk kl l km kn">SECRET_KEY="YOURSECRETKEYGOESHERE"</span></pre><p id="1832" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">返回Encrypt.js并添加以下方法，该脚本现在应该如下所示:</p><pre class="jz ka kb kc fq kd ke kf bn kg kh bi"><span id="eb26" class="ki kj ht ke b be kk kl l km kn">require('dotenv').config();<br/><br/>const CryptoJS = require('crypto-js');<br/><br/>const encryptWithAES = (text) =&gt; {<br/>  const passphrase = process.env.SECRET_KEY;<br/>  return CryptoJS.AES.encrypt(text, passphrase).toString();<br/>}; export encryptWithAES;<br/><br/>const decryptWithAES = (ciphertext) =&gt; {<br/>  const passphrase = process.env.SECRET_KEY;<br/>  const bytes = CryptoJS.AES.decrypt(ciphertext, passphrase);<br/>  const originalText = bytes.toString(CryptoJS.enc.Utf8);<br/>  return originalText;<br/>}; export decryptWithAES;</span></pre><p id="bbf9" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">到目前为止，我们已经有了加密和解密文本的方法。环境文件。我们的下一步是创建保存我们数据的智能契约。</p><pre class="jz ka kb kc fq kd ke kf bn kg kh bi"><span id="58e5" class="ki kj ht ke b be kk kl l km kn">// SPDX-License-Identifier: MIT<br/>// PasswordManager <br/>pragma solidity 0.8.17;<br/><br/>import "@openzeppelin/contracts/access/Ownable.sol";<br/>import "@openzeppelin/contracts/utils/Address.sol";<br/>import "@openzeppelin/contracts/utils/Strings.sol";<br/><br/>contract PasswordManager is Ownable {<br/>    using Strings for uint256;<br/><br/>    struct MyAccounts {<br/>        string accountName;<br/>        string accountUsername;<br/>        string accountEmail;<br/>        string accountPassword;<br/>        uint256 id;<br/>    }<br/><br/>    MyAccounts[] private accounts;<br/><br/>    // ===== Check Caller Is User =====<br/>    modifier callerIsUser() {<br/>        require(tx.origin == msg.sender, "[Error] Function cannot be called by a contract");<br/>        _;<br/>    }<br/><br/>    // ===== Validate Entry Values =======<br/>    function checkValues(<br/>        string calldata accountName, <br/>        string calldata accountUsername, <br/>        string calldata accountEmail, <br/>        string calldata accountPassword<br/>    ) internal pure {<br/>        unchecked {<br/>            require(bytes(accountName).length &gt; 0, "[Error] Account Name Can't Be Blank");<br/>            require(bytes(accountUsername).length &gt; 0, "[Error] Account Userame Can't Be Blank");<br/>            require(bytes(accountEmail).length &gt; 0, "[Error] Account Email Can't Be Blank");<br/>            require(bytes(accountPassword).length &gt; 0, "[Error] Account Password Can't Be Blank");<br/>        }<br/>    }<br/><br/>    // ====== Get New ID =========<br/>    function generateID() internal view returns(uint256) {<br/>        unchecked {<br/>            return accounts.length + 1;<br/>        }<br/>    }<br/><br/>    // ===== Add New Account Record =======<br/>    function addNewAccount(<br/>        string calldata accountName, <br/>        string calldata accountUsername, <br/>        string calldata accountEmail, <br/>        string calldata accountPassword<br/>    ) public callerIsUser() onlyOwner {<br/>        checkValues(accountName, accountUsername, accountEmail, accountPassword);<br/>        accounts.push(MyAccounts(accountName, accountUsername, accountEmail, accountPassword, generateID()));<br/>    }<br/><br/>    // ===== Upate Account Record =======<br/>    function updateAccount(<br/>        uint256 recordID, <br/>        string calldata accountName, <br/>        string calldata accountUsername, <br/>        string calldata accountEmail, <br/>        string calldata accountPassword<br/>    ) public callerIsUser() onlyOwner {<br/>        checkValues(accountName, accountUsername, accountEmail, accountPassword);<br/>        accounts[recordID] = MyAccounts(accountName, accountUsername, accountEmail, accountPassword, recordID);<br/>    } <br/><br/>    // ===== Delete Account Record =======<br/>    function deleteAccount(<br/>        uint256 recordID<br/>    ) public callerIsUser() onlyOwner {<br/>        delete accounts[recordID];<br/>    } <br/><br/>    // ===== Get Account Record =======<br/>    function getAccountByID(<br/>        uint256 recordID<br/>    ) public view callerIsUser() onlyOwner returns (MyAccounts memory) {<br/>        return accounts[recordID];<br/>    } <br/><br/>    // ===== Get All Accounts ======<br/>    function allAccounts() public view callerIsUser() onlyOwner returns (MyAccounts[] memory) {<br/>        return accounts;<br/>    } <br/>}</span></pre><p id="2f49" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">使用remix或hardhat将此合同部署到testnet，一旦启用，我们可以使用ethers.js将我们的加密dapp连接到我们的合同。在Src目录中创建一个新文件，并将其命名为PasswordManager.js。</p><p id="4889" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在这个新文件中，我们首先需要使我们的加密和解密函数可用于管理器文件，将下面的部分复制到管理器文件中并保存。</p><pre class="jz ka kb kc fq kd ke kf bn kg kh bi"><span id="192f" class="ki kj ht ke b be kk kl l km kn">const { decryptWithAES, encryptWithAES } = require('./Encrypt.js');</span></pre><p id="4f5b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">保存PasswordManager.js并在src目录中创建一个名为abi.json的新文件。在该文件中，您将粘贴您的合同abi。如果使用上面的合同，它将如下所示:</p><pre class="jz ka kb kc fq kd ke kf bn kg kh bi"><span id="97e7" class="ki kj ht ke b be kk kl l km kn">[<br/> {<br/>  "anonymous": false,<br/>  "inputs": [<br/>   {<br/>    "indexed": true,<br/>    "internalType": "address",<br/>    "name": "previousOwner",<br/>    "type": "address"<br/>   },<br/>   {<br/>    "indexed": true,<br/>    "internalType": "address",<br/>    "name": "newOwner",<br/>    "type": "address"<br/>   }<br/>  ],<br/>  "name": "OwnershipTransferred",<br/>  "type": "event"<br/> },<br/> {<br/>  "inputs": [<br/>   {<br/>    "internalType": "string",<br/>    "name": "accountName",<br/>    "type": "string"<br/>   },<br/>   {<br/>    "internalType": "string",<br/>    "name": "accountUsername",<br/>    "type": "string"<br/>   },<br/>   {<br/>    "internalType": "string",<br/>    "name": "accountEmail",<br/>    "type": "string"<br/>   },<br/>   {<br/>    "internalType": "string",<br/>    "name": "accountPassword",<br/>    "type": "string"<br/>   }<br/>  ],<br/>  "name": "addNewAccount",<br/>  "outputs": [],<br/>  "stateMutability": "nonpayable",<br/>  "type": "function"<br/> },<br/> {<br/>  "inputs": [],<br/>  "name": "allAccounts",<br/>  "outputs": [<br/>   {<br/>    "components": [<br/>     {<br/>      "internalType": "string",<br/>      "name": "accountName",<br/>      "type": "string"<br/>     },<br/>     {<br/>      "internalType": "string",<br/>      "name": "accountUsername",<br/>      "type": "string"<br/>     },<br/>     {<br/>      "internalType": "string",<br/>      "name": "accountEmail",<br/>      "type": "string"<br/>     },<br/>     {<br/>      "internalType": "string",<br/>      "name": "accountPassword",<br/>      "type": "string"<br/>     },<br/>     {<br/>      "internalType": "uint256",<br/>      "name": "id",<br/>      "type": "uint256"<br/>     }<br/>    ],<br/>    "internalType": "struct PasswordManager.MyAccounts[]",<br/>    "name": "",<br/>    "type": "tuple[]"<br/>   }<br/>  ],<br/>  "stateMutability": "view",<br/>  "type": "function"<br/> },<br/> {<br/>  "inputs": [<br/>   {<br/>    "internalType": "uint256",<br/>    "name": "recordID",<br/>    "type": "uint256"<br/>   }<br/>  ],<br/>  "name": "deleteAccount",<br/>  "outputs": [],<br/>  "stateMutability": "nonpayable",<br/>  "type": "function"<br/> },<br/> {<br/>  "inputs": [<br/>   {<br/>    "internalType": "uint256",<br/>    "name": "recordID",<br/>    "type": "uint256"<br/>   }<br/>  ],<br/>  "name": "getAccountByID",<br/>  "outputs": [<br/>   {<br/>    "components": [<br/>     {<br/>      "internalType": "string",<br/>      "name": "accountName",<br/>      "type": "string"<br/>     },<br/>     {<br/>      "internalType": "string",<br/>      "name": "accountUsername",<br/>      "type": "string"<br/>     },<br/>     {<br/>      "internalType": "string",<br/>      "name": "accountEmail",<br/>      "type": "string"<br/>     },<br/>     {<br/>      "internalType": "string",<br/>      "name": "accountPassword",<br/>      "type": "string"<br/>     },<br/>     {<br/>      "internalType": "uint256",<br/>      "name": "id",<br/>      "type": "uint256"<br/>     }<br/>    ],<br/>    "internalType": "struct PasswordManager.MyAccounts",<br/>    "name": "",<br/>    "type": "tuple"<br/>   }<br/>  ],<br/>  "stateMutability": "view",<br/>  "type": "function"<br/> },<br/> {<br/>  "inputs": [],<br/>  "name": "owner",<br/>  "outputs": [<br/>   {<br/>    "internalType": "address",<br/>    "name": "",<br/>    "type": "address"<br/>   }<br/>  ],<br/>  "stateMutability": "view",<br/>  "type": "function"<br/> },<br/> {<br/>  "inputs": [],<br/>  "name": "renounceOwnership",<br/>  "outputs": [],<br/>  "stateMutability": "nonpayable",<br/>  "type": "function"<br/> },<br/> {<br/>  "inputs": [<br/>   {<br/>    "internalType": "address",<br/>    "name": "newOwner",<br/>    "type": "address"<br/>   }<br/>  ],<br/>  "name": "transferOwnership",<br/>  "outputs": [],<br/>  "stateMutability": "nonpayable",<br/>  "type": "function"<br/> },<br/> {<br/>  "inputs": [<br/>   {<br/>    "internalType": "uint256",<br/>    "name": "recordID",<br/>    "type": "uint256"<br/>   },<br/>   {<br/>    "internalType": "string",<br/>    "name": "accountName",<br/>    "type": "string"<br/>   },<br/>   {<br/>    "internalType": "string",<br/>    "name": "accountUsername",<br/>    "type": "string"<br/>   },<br/>   {<br/>    "internalType": "string",<br/>    "name": "accountEmail",<br/>    "type": "string"<br/>   },<br/>   {<br/>    "internalType": "string",<br/>    "name": "accountPassword",<br/>    "type": "string"<br/>   }<br/>  ],<br/>  "name": "updateAccount",<br/>  "outputs": [],<br/>  "stateMutability": "nonpayable",<br/>  "type": "function"<br/> }<br/>]</span></pre><p id="529e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">接下来我们需要导入。我们将用于链上交互的env文件和libs导入到我们的PasswordManager.js文件中，我们还将导入新的abi文件:</p><pre class="jz ka kb kc fq kd ke kf bn kg kh bi"><span id="384a" class="ki kj ht ke b be kk kl l km kn">require('dotenv').config();<br/><br/>const { decryptWithAES, encryptWithAES } = require('./Encrypt.js');<br/>const { ethers, providers } = require('ethers');<br/>const abi = require('./abi.json');</span></pre><p id="9162" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">接下来获取您部署的合同地址，并存储到PasswordManager.js中的一个常量中</p><pre class="jz ka kb kc fq kd ke kf bn kg kh bi"><span id="ef4a" class="ki kj ht ke b be kk kl l km kn">const contractAddress = "0xC36442b4a4522E871399CD717aBDD847Ab11FE88"</span></pre><p id="d166" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">保存文件，转到env并为您的钱包私钥(签署交易的那个)添加这一行，然后保存。</p><pre class="jz ka kb kc fq kd ke kf bn kg kh bi"><span id="d2e6" class="ki kj ht ke b be kk kl l km kn">SECRET_KEY="YOURSECRETKEYGOESHERE"<br/>PRIVATE_KEY="YOURWALLETPRIVATEKEYGOESHERE"</span></pre><p id="df62" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在回到我们的密码管理器文件，我们将添加我们的第一个契约方法调用:</p><pre class="jz ka kb kc fq kd ke kf bn kg kh bi"><span id="78a8" class="ki kj ht ke b be kk kl l km kn">const signer = new ethers.Wallet(<br/>    process.env.PRIVATE_KEY,<br/>    providers.getDefaultProvider('testnet')<br/>);<br/><br/>const contract = new ethers.Contract(contractAddress, abi, signer);<br/><br/>const addNewAccount = async (<br/>    accountName, <br/>    accountUsername,<br/>    accountEmail,<br/>    accountPassword<br/>) =&gt; {<br/>    const a = await contract.callStatic.addNewAccount(<br/>      accountName, <br/>      accountUsername,<br/>      accountEmail,<br/>      accountPassword<br/>    )<br/>    console.log(a);<br/>}<br/><br/>export addNewAccount;</span></pre><p id="8c66" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在我们将加密我们的输入，这可以用前端表单数据代替，但在这种情况下，我们将使用纯代码。</p><pre class="jz ka kb kc fq kd ke kf bn kg kh bi"><span id="59c4" class="ki kj ht ke b be kk kl l km kn">const encryptName = encryptWithAES("Facebook");<br/>const encryptUsername = encryptWithAES("Arkay92");<br/>const encryptEmail = encryptWithAES("arkay@gmail.com");<br/>const encryptPassword = encryptWithAES("Password!");</span></pre><p id="28a5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">最后，我们需要用加密的参数调用我们的方法:</p><pre class="jz ka kb kc fq kd ke kf bn kg kh bi"><span id="32e6" class="ki kj ht ke b be kk kl l km kn">addNewAccount(encryptName, encryptUsername, encryptEmail, encryptPassword);</span></pre><p id="c56e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这就是我们如何在chain上存储加密数据。要进行解密，我们只需在契约中查询我们想要的记录ID，并对返回的记录运行解密函数decryptWithAES()。</p><p id="fb02" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">PasswordManager.js的完整代码示例:</p><pre class="jz ka kb kc fq kd ke kf bn kg kh bi"><span id="fe61" class="ki kj ht ke b be kk kl l km kn">require('dotenv').config();<br/><br/>const { decryptWithAES, encryptWithAES } = require('./Encrypt.js');<br/>const { ethers, providers } = require('ethers');<br/>const abi = require('./abi.json');<br/><br/>const encryptName = encryptWithAES("Facebook");<br/>const encryptUsername = encryptWithAES("Arkay92");<br/>const encryptEmail = encryptWithAES("arkay@gmail.com");<br/>const encryptPassword = encryptWithAES("Password!");<br/><br/>const contractAddress = "0xC36442b4a4522E871399CD717aBDD847Ab11FE88";<br/><br/>const signer = new ethers.Wallet(<br/>    process.env.PRIVATE_KEY,<br/>    providers.getDefaultProvider('testnet')<br/>);<br/><br/>const contract = new ethers.Contract(contractAddress, abi, signer);<br/><br/>const addNewAccount = async (<br/>    accountName, <br/>    accountUsername,<br/>    accountEmail,<br/>    accountPassword<br/>) =&gt; {<br/>    const a = await contract.callStatic.addNewAccount(<br/>      accountName, <br/>      accountUsername,<br/>      accountEmail,<br/>      accountPassword<br/>    )<br/>    console.log(a);<br/>}<br/><br/>export addNewAccount;<br/><br/>addNewAccount(encryptName, encryptUsername, encryptEmail, encryptPassword);</span></pre><p id="e9bf" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们还可以做很多很多事情来使它更加安全、可扩展和可靠，但这是有趣的部分。去创作吧！</p><blockquote class="ko"><p id="bf6a" class="kp kq ht bd kr ks kt ku kv kw kx jy ek translated">交易新手？试试<a class="ae ky" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或者<a class="ae ky" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>