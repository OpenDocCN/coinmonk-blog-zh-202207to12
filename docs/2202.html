<html>
<head>
<title>Ciphershastra — Undead Puzzle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不死之谜</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/ciphershastra-undead-puzzle-e12cc6185198?source=collection_archive---------18-----------------------#2022-08-15">https://medium.com/coinmonks/ciphershastra-undead-puzzle-e12cc6185198?source=collection_archive---------18-----------------------#2022-08-15</a></blockquote><div><div class="eg hi hj hk hl hm"/><div class="hn ho hp hq hr"><figure class="ht hu fn fp hv hw ff fg paragraph-image"><div role="button" tabindex="0" class="hx hy di hz bf ia"><div class="ff fg hs"><img src="../Images/7537276fa100d13aeb8733c30a540f21.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*h9rae3rIMBMvvQt0Qf3-OQ.png"/></div></div><figcaption class="id ie fh ff fg if ig bd b be z el">Ciphershastra Challenge</figcaption></figure><div class=""/><figure class="fj fl jh ji jj hw ff fg paragraph-image"><div class="ff fg jg"><img src="../Images/50bf7988c854dbca9af87d7e0eb1caf2.png" data-original-src="https://miro.medium.com/v2/resize:fit:570/format:webp/1*sQGyrXsuoBxmNwbegLrN8g.png"/></div></figure><p id="8742" class="pw-post-body-paragraph jk jl ij jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">你可以在这里找到挑战:<a class="ae ki" href="https://ciphershastra.com/UnDeAD.html" rel="noopener ugc nofollow" target="_blank">https://ciphershastra.com/UnDeAD.html</a></p><p id="4b71" class="pw-post-body-paragraph jk jl ij jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">这个难题需要很多技巧来解决。我们唯一可用的外部函数是<code class="ei kj kk kl km b">deadOrAlive</code>函数。在这个函数中，我们必须满足几个检查，这样我们就可以在<code class="ei kj kk kl km b">UnDeAD</code>映射中将我们的散列地址设置为<code class="ei kj kk kl km b">true</code>，这证明我们已经通过了挑战。</p><h1 id="333e" class="kn ko ij bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated"><strong class="ak">死亡率</strong></h1><p id="85e1" class="pw-post-body-paragraph jk jl ij jm b jn ll jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd lp kf kg kh hn dt translated">我们发现的第一个检查是一个简单的网关，现在允许我们从同一个调用地址破解合同两次。下一个是对“死亡率”的检查。这个函数检查调用者地址在地址中是否有特定的模式。这个模式存储在<code class="ei kj kk kl km b">want</code>公共变量中。在查询它的时候，我们可以看到返回的字节是“0x0b100d”。这个模式需要出现在调用者的地址中才能通过检查。但是怎么做呢？这种检查表明，我们需要能够控制部署解决方案契约的地址。为了做到这一点，我们需要使用<code class="ei kj kk kl km b">CREATE2</code>操作码，该操作码通过使用部署的地址、部署的契约字节码和Salt作为生成最终部署地址的种子，在可预测的地址中部署契约。</p><p id="82e4" class="pw-post-body-paragraph jk jl ij jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">通过修改Salt，我们可以影响最终的部署地址。因此，我们只需要迭代Salt，直到找到包含所需模式的地址，从而强制执行第一次检查。</p><p id="8bec" class="pw-post-body-paragraph jk jl ij jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">在部署地址中查找生成特定模式的salt的脚本在<a class="ae ki" href="https://gist.github.com/robercano/scripts/utils/findAddress.ts" rel="noopener ugc nofollow" target="_blank">这里</a>可用。它将递增salt，直到找到地址中的模式，然后返回salt和生成的地址。</p><p id="a7ff" class="pw-post-body-paragraph jk jl ij jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">这在<a class="ae ki" href="https://gist.github.com/robercano/tasks/solveUndead.ts" rel="noopener ugc nofollow" target="_blank">解决方案脚本</a>中使用，以找到生成正确地址的salt。</p><p id="83f3" class="pw-post-body-paragraph jk jl ij jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">然后我们准备了一个<a class="ae ki" href="https://gist.github.com/robercano/contracts/solutions/UndeadSolutionFactory.sol" rel="noopener ugc nofollow" target="_blank">工厂契约</a>来部署解决方案契约。它将使用salt生成具有所需模式的地址，并部署契约。</p><h1 id="992b" class="kn ko ij bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated"><strong class="ak">还没死</strong></h1><p id="18d3" class="pw-post-body-paragraph jk jl ij jm b jn ll jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd lp kf kg kh hn dt translated">第三项检查(我们现在跳过第二项)要求解决方案契约在调用函数<code class="ei kj kk kl km b">deadYet()</code>时返回字符串<strong class="jm ik">“亡灵”</strong>的编码字节。契约将返回字节<code class="ei kj kk kl km b">0x556e44654144</code>，这些字节是<strong class="jm ik">“亡灵”</strong>的ascii码。这在可靠性合同中很容易做到，但正如我们将在下一节中看到的，由于第二次检查，这将变得复杂。</p><h1 id="d3d8" class="kn ko ij bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated"><strong class="ak">迷你合同</strong></h1><p id="0406" class="pw-post-body-paragraph jk jl ij jm b jn ll jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd lp kf kg kh hn dt translated">不死契约中的第二个检查强制解决方案契约只有15个字节的代码。如果我们在Solidity中创建契约并编译它，即使有大小优化，我们也会看到我们不能得到少于140字节的代码。这直接阻止了使用Solidity来创建解决方案契约。</p><p id="9801" class="pw-post-body-paragraph jk jl ij jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">我们可以创建它的另一种方法是使用Yul，EVM的汇编语言。一个最小的Yul合同应该是这样的:<a class="ae ki" href="https://gist.github.com/robercano/55516de38ba3a360e1050eea6b9f60c7" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/rober cano/55516 de 38 ba 3a 360 e 1050 eea6b 9f 60 c 7</a></p><p id="8988" class="pw-post-body-paragraph jk jl ij jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated"><code class="ei kj kk kl km b">code</code>部分负责将运行时复制到区块链中，然后<code class="ei kj kk kl km b">runtime</code>做两件事:检查调用中没有发送值，然后使用选择器将调用分派给正确的函数。<code class="ei kj kk kl km b">code</code>段不能跳过，但<code class="ei kj kk kl km b">runtime</code>段可以尽量减少。我们可以移除<code class="ei kj kk kl km b">callvalue()</code>检查，然后使用<code class="ei kj kk kl km b">default</code>用例返回所需的值。这意味着契约将返回任何函数调用所需的字节，就像我们已经定义了<code class="ei kj kk kl km b">fallback()</code>函数来返回字符串“亡灵”的字节一样。</p><p id="e5b4" class="pw-post-body-paragraph jk jl ij jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">最终的Yul合同如下所示:</p><pre class="lq lr ls lt fr lu km lv lw aw lx dt"><span id="ebbe" class="ly ko ij km b fw lz ma l mb mc">object "YulContract" {<br/>  code {<br/>    datacopy(0, dataoffset("runtime"), datasize("runtime"))<br/>    return (0, datasize("runtime"))<br/>  }<br/>  object "runtime" {<br/>    code {<br/>      mstore(0,  0x556e44654144) // UnDeAD<br/>      return(0, 0x20)<br/>    }<br/>  }<br/>}</span></pre><p id="6ecb" class="pw-post-body-paragraph jk jl ij jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">它将所需的字节存储在存储器地址0:</p><pre class="lq lr ls lt fr lu km lv lw aw lx dt"><span id="4eed" class="ly ko ij km b fw lz ma l mb mc">mstore(0, 0x556e44654144) // UnDeAD</span></pre><p id="d67b" class="pw-post-body-paragraph jk jl ij jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">然后从那里返回32 (0x20)字节(这正是不死契约所期望的):</p><pre class="lq lr ls lt fr lu km lv lw aw lx dt"><span id="2208" class="ly ko ij km b fw lz ma l mb mc">return(0, 0x20)</span></pre><p id="4b8a" class="pw-post-body-paragraph jk jl ij jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh hn dt translated">之前的Yul代码是在Remix中编译的，产生的字节码被复制到解决方案脚本中:</p><pre class="lq lr ls lt fr lu km lv lw aw lx dt"><span id="833b" class="ly ko ij km b fw lz ma l mb mc">0x600f80600d600039806000f3fe65556e4465414460005260206000f3</span></pre><h1 id="57c1" class="kn ko ij bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated"><strong class="ak">准备进攻！</strong></h1><p id="2daa" class="pw-post-body-paragraph jk jl ij jm b jn ll jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd lp kf kg kh hn dt translated">有了这一切，我们准备攻击亡灵契约。我们部署工厂契约，为当前部署者找到所需的salt，并为Yul契约找到给定的字节码。然后使用找到的Salt通过工厂部署解决方案契约，最后将部署的解决方案契约地址传递给亡灵契约验证提交。瞧啊！</p><h1 id="7523" class="kn ko ij bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">Github回购</h1><p id="3638" class="pw-post-body-paragraph jk jl ij jm b jn ll jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd lp kf kg kh hn dt translated">你可以在我的Github repo:<a class="ae ki" href="https://github.com/robercano/ciphershastra" rel="noopener ugc nofollow" target="_blank">https://github.com/robercano/ciphershastra</a>中找到这个解决方案以及其他密码破解挑战</p><h1 id="d96d" class="kn ko ij bd kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk dt translated">关于我</h1><p id="617f" class="pw-post-body-paragraph jk jl ij jm b jn ll jp jq jr lm jt ju jv ln jx jy jz lo kb kc kd lp kf kg kh hn dt translated">我叫罗伯特·卡诺，你可以在https://thesolidchain.com的<a class="ae ki" href="https://thesolidchain.com" rel="noopener ugc nofollow" target="_blank">找到我</a></p><blockquote class="md"><p id="fe51" class="me mf ij bd mg mh mi mj mk ml mm kh el translated">交易新手？试试<a class="ae ki" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">密码交易机器人</a>或<a class="ae ki" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>