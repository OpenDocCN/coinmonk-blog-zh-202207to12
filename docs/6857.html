<html>
<head>
<title>Part 1: Building a Complete API in Go to Interact with a P2P Escrow Smart Contract using go-ethereum Client &amp; GoFiber Framework</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">第1部分:在Go中构建一个完整的API，使用go-ethereum客户端和GoFiber框架与P2P托管智能契约进行交互</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/part-1-building-a-complete-api-in-go-to-interact-with-a-p2p-escrow-smart-contract-using-9cf1f681c860?source=collection_archive---------5-----------------------#2022-11-29">https://medium.com/coinmonks/part-1-building-a-complete-api-in-go-to-interact-with-a-p2p-escrow-smart-contract-using-9cf1f681c860?source=collection_archive---------5-----------------------#2022-11-29</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><div class=""/><figure class="fi fk ir is it iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff iq"><img src="../Images/094b4b7854f4ce57afc59360ad582edf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5a1o8w31T-WzODa3Su3FcQ.png"/></div></div></figure><p id="7bae" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这是本系列两篇文章的第一部分</p><ul class=""><li id="0bdb" class="jz ka ht jd b je jf ji jj jm kb jq kc ju kd jy ke kf kg kh dt translated">第1部分:项目概述、设置纤程、生成Go绑定、部署合同、添加get Escrow &amp; Wallet逻辑地址端点</li><li id="8524" class="jz ka ht jd b je ki ji kj jm kk jq kl ju km jy ke kf kg kh dt translated"><a class="ae kn" rel="noopener" href="/coinmonks/part-2-building-a-complete-api-in-go-to-interact-with-a-p2p-escrow-smart-contract-using-fa0514531032">第二部分:添加和结束P2P API端点</a></li></ul><p id="e2ed" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">你可以在<a class="ae kn" href="https://github.com/alofeoluwafemi/-smart-contract-api-go-ethereum" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上找到代码库作为参考。</p><p id="b31b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这里是API邮差集<a class="ae kn" href="https://www.getpostman.com/collections/362a5590ccf482592588" rel="noopener ugc nofollow" target="_blank">链接</a>供你导入。</p><h1 id="e26e" class="ko kp ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">介绍</h1><p id="1488" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated"><a class="ae kn" href="https://geth.ethereum.org/" rel="noopener ugc nofollow" target="_blank"> Go以太坊</a>是以太坊协议的官方Go实现。矿工可以使用它来运行以太坊节点，Dapp开发人员(如您)可以使用它的一些包来将您的智能合约编译为字节码，将其部署到网络，并使用它与您部署的智能合约进行交互。</p><p id="aadc" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><a class="ae kn" href="https://gofiber.io/" rel="noopener ugc nofollow" target="_blank"> Go Fiber framework </a>另一方面，它是一个构建在Fasthttp之上的Go web框架，fast http是Go最快的HTTP引擎。它与Node express framework的相似性和易用性使得它对新的go开发人员来说很有吸引力，可以用来为他们的项目构建API。就我个人而言，当我开始写Go lang时，我发现它很容易理解并很快上手。</p><h1 id="15b2" class="ko kp ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">你将学到什么</h1><p id="4490" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">对于本教程，我将使用现有的智能合同，这是PiggyFi 在<a class="ae kn" href="https://piggyfi.africa/" rel="noopener ugc nofollow" target="_blank"> Pay上满足P2P平台的第一稿之一，它是在我们参加的一次黑客马拉松中作为概念证明而编写的。你可以在这里</a><a class="ae kn" href="https://github.com/orignellc/piggyfi-contracts-poc" rel="noopener ugc nofollow" target="_blank">找到代码库</a>因为这个系列的目标不是关注构建一个智能契约，而是一个在go中与之交互的API，这个契约服务于我们的使用。</p><p id="4119" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">不要担心，我将在下面做一个智能合同的分解</p><h1 id="e628" class="ko kp ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">困难</h1><ul class=""><li id="75df" class="jz ka ht jd b je lm ji ln jm lr jq ls ju lt jy ke kf kg kh dt translated">初学✅</li><li id="3d67" class="jz ka ht jd b je ki ji kj jm kk jq kl ju km jy ke kf kg kh dt translated">中间✅</li></ul><h1 id="ea8c" class="ko kp ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">要求</h1><p id="509d" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">为了从本教程中获得最佳效果，需要对围棋有一些基本的了解。对于我选择的编辑器，我将使用<a class="ae kn" href="https://www.jetbrains.com/go/" rel="noopener ugc nofollow" target="_blank"> go-land </a>，在我看来这是目前最好的go-lang编辑器。</p><p id="d953" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">除了安装最新的<a class="ae kn" href="https://docs.soliditylang.org/en/v0.8.9/installing-solidity.html" rel="noopener ugc nofollow" target="_blank"> solidity编译器</a>和显然最新的<a class="ae kn" href="https://go.dev/doc/install" rel="noopener ugc nofollow" target="_blank"> go编译器</a>是一个要求。</p><p id="0fac" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">此外，确保从Goerli 处获得一些<a class="ae kn" href="https://goerlifaucet.com/" rel="noopener ugc nofollow" target="_blank">测试ETH，在部署和与智能合同交互时将需要支付天然气费。</a></p><h1 id="ca0c" class="ko kp ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">目录</h1><h2 id="78b3" class="lu kp ht bd kq lv lw lx ku ly lz ma ky jm mb mc lc jq md me lg ju mf mg lk mh dt translated">本文的第1部分包括</h2><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="d50f" class="mr kp ht mn b be ms mt l mu mv">- Project Overview<br/>- Setup Fiber, .env &amp; Install dependecies<br/>- Deploy Smart Contracts on Goeril Testnet<br/>- Generate Go Binding for Contracts<br/>- Build out API Endpoints<br/> - POST request to Deploy Contracts<br/>  - USDC<br/>  - Factory<br/> - GET request to get CustodianWalletLogic  Address<br/> - GET request to get Escrow Contract Address</span></pre><h2 id="e469" class="lu kp ht bd kq lv lw lx ku ly lz ma ky jm mb mc lc jq md me lg ju mf mg lk mh dt translated">本文的第2部分包括</h2><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="c2c7" class="mr kp ht mn b be ms mt l mu mv">- POST request to set USDC address on the Escrow contract<br/>- POST request to Deploy a new custodian wallet address<br/>- POST request to open a buy P2P order with USDC Balance<br/>- POST request to open a sell P2P order with USDC Balance<br/>- Handle Revert Errors in response<br/>- GET request to Get open orders for a vendor<br/>- GET request to Get order by ID </span></pre><h2 id="6d3e" class="lu kp ht bd kq lv lw lx ku ly lz ma ky jm mb mc lc jq md me lg ju mf mg lk mh dt translated">第三部分DIY(自己动手)🤓</h2><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="a4f6" class="mr kp ht mn b be ms mt l mu mv">- POST request to open a sell P2P order with USDC Balance<br/>- GET request to Get open orders for a vendor<br/>- GET request to Get order by ID<br/>- POST request to cancel P2P order</span></pre><h1 id="ba03" class="ko kp ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">项目概述</h1><p id="6192" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">Piggyfi智能合约的这个版本是一个简单的托管系统，用于在供应商和希望将菲亚特兑换成美元的客户之间进行P2P交易。</p><p id="c868" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu"> Factory: </strong>这个智能契约负责部署一个新的CustodianWalletProxy，它在每次新用户根据用户配置文件注册时充当供应商或客户的钱包。<br/><br/><strong class="jd hu">CustodianWalletProxy:</strong>这是作为钱包部署给每个用户的契约。它使用委托调用来使用CustodianWallet逻辑契约中的实际逻辑，除了回调方法和构造函数之外，它本身不包含任何有意义的函数。<br/> <strong class="jd hu">类型:</strong>这保存了代理和逻辑钱包契约之间共享的公共变量，以避免写得不好的代理契约常见的可怕的存储覆盖问题。<br/> <strong class="jd hu"> USDC: </strong>这个合同从来没有部署到生产中，它只是用来在测试环境中模仿USDC，给我们灵活性和对铸造的控制。在生产中，该地址将用于托管合同中的USDC。</p><h1 id="46ac" class="ko kp ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">设置光纤。环境和安装依赖项</h1><p id="3be4" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">如果你正在使用Goland IDE，创建一个新项目就像打开你的IDE一样简单，在菜单上点击<strong class="jd hu">文件&gt;新建&gt;项目</strong>。不要忘记把默认的名字<code class="eh mw mx my mn b">awesomeProject</code>改成你想要的名字，我用<code class="eh mw mx my mn b">go-ethereum-api</code>作为我的名字。</p><figure class="mi mj mk ml fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff mz"><img src="../Images/284a0c0939301b1fd2ed2ad5d51ea06b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*3SNyK9KoZkH63ao7.png"/></div></div></figure><p id="ed3c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">对于其他IDE，如VScode，创建您的项目主管，然后从终端运行下面的命令来生成您的<code class="eh mw mx my mn b">go.mod</code>文件。</p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="554f" class="mr kp ht mn b be ms mt l mu mv">go mod init github.com/GITHUB_USER_NAME/go-ethereum-api</span></pre><p id="4bca" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">记得用你的GitHub用户名替换<code class="eh mw mx my mn b">GITHUB_USER_NAME</code>。</p><p id="c94b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">下一步</strong>，运行安装纤维框架</p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="f5b8" class="mr kp ht mn b be ms mt l mu mv">go get github.com/gofiber/fiber/v2</span></pre><p id="8c4c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在，您想要创建一个<code class="eh mw mx my mn b">package main.go</code>文件并将下面的代码粘贴到其中。</p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="f465" class="mr kp ht mn b be ms mt l mu mv">package main<br/><br/>import (<br/> "github.com/gofiber/fiber/v2"<br/> "log"<br/>)<br/><br/>func main() {<br/> app := fiber.New()<br/><br/> app.Get("/", func(c *fiber.Ctx) error {<br/>  return c.SendString("Hello, World!")<br/> })<br/><br/> err := app.Listen(":3000")<br/><br/> if err != nil {<br/>  return<br/> }<br/><br/>}</span></pre><p id="311b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">从您的终端运行</p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="f14b" class="mr kp ht mn b be ms mt l mu mv">go run server.go</span></pre><p id="7a25" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">您应该会在终端中看到类似的内容，表明一切都运行良好。</p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="92af" class="mr kp ht mn b be ms mt l mu mv"> ┌───────────────────────────────────────────────────┐ <br/> │                   Fiber v2.37.0                   │ <br/> │               http://127.0.0.1:3000               │ <br/> │       (bound on host 0.0.0.0 and port 3000)       │ <br/> │                                                   │ <br/> │ Handlers ............. 2  Processes ........... 1 │ <br/> │ Prefork ....... Disabled  PID ............. 57556 │ <br/> └───────────────────────────────────────────────────┘</span></pre><p id="10f7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">访问<a class="ae kn" href="http://127.0.0.1:3000/" rel="noopener ugc nofollow" target="_blank"> http://127.0.0.1:3000 </a>你会看到<strong class="jd hu">你好，世界！不多，但是使用go Fiber建立一个HTTP服务器就那么快。</strong></p><p id="87cc" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在，让我们正确设置我们的应用程序结构，但在我们继续之前，安装以下依赖项。</p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="3951" class="mr kp ht mn b be ms mt l mu mv">go get github.com/joho/godotenv<br/>go get github.com/ethereum/go-ethereum</span></pre><h1 id="02df" class="ko kp ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">文件夹结构</h1><p id="f849" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">更新您的项目结构以匹配下图。别担心，一切很快就会有意义的。</p><figure class="mi mj mk ml fq iu fe ff paragraph-image"><div class="fe ff na"><img src="../Images/d995d792e0313532e2c8118f6249d400.png" data-original-src="https://miro.medium.com/v2/resize:fit:1028/format:webp/0*o2Jc5mULAF-1mzDK.png"/></div></figure><p id="d5fc" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">路由器:</strong>路由器包是定义所有路由的地方。在这里，我们定义了一个路由器接口，允许我们拥有不同类型的路由器，如API路由器、HTTP路由器等，这样就可以在接口上定义所有路由器都必须实现的方法，并且我们可以确保我们的路由器将以某种方式运行，正如您将在下面看到的<code class="eh mw mx my mn b">InstallRouter</code>方法的情况。</p><p id="003d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">pkg/router/router _ interface . go</strong></p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="73ce" class="mr kp ht mn b be ms mt l mu mv">package router<br/><br/>import "github.com/gofiber/fiber/v2"<br/><br/>type Router interface {<br/> InstallRouter(app *fiber.App)<br/>}</span></pre><p id="0ebf" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">pkg/router/API _ router . go</strong></p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="624e" class="mr kp ht mn b be ms mt l mu mv">package router<br/><br/>import (<br/>	"github.com/alofeoluwafemi/go-ethereum-api/app/controllers"<br/>	"github.com/gofiber/fiber/v2"<br/>	"github.com/gofiber/fiber/v2/middleware/limiter"<br/>)<br/><br/>type ApiRouter struct {<br/>}<br/><br/>func (h ApiRouter) InstallRouter(app *fiber.App) {<br/>	api := app.Group("/api/v1", limiter.New())<br/><br/>	api.Get("/", controllers.RenderHello)<br/>}<br/><br/>func NewApiRouter() *ApiRouter {<br/>	return &amp;ApiRouter{}<br/>}</span></pre><p id="220c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu"> pkg/router/setup.go </strong></p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="7ef9" class="mr kp ht mn b be ms mt l mu mv">package router<br/><br/>import (<br/>	"github.com/gofiber/fiber/v2"<br/>)<br/><br/>func InstallRouter(app *fiber.App) {<br/>	setup(app, NewApiRouter())<br/><br/>	//If no route was matched<br/>	app.Use(func(c *fiber.Ctx) error {<br/>		err := c.SendStatus(404)<br/>		panic(err)<br/>	})<br/>}<br/><br/>func setup(app *fiber.App, router ...Router) {<br/>	for _, r := range router {<br/>		r.InstallRouter(app)<br/>	}<br/>}</span></pre><p id="0fb3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">⚠️:记得用与你的<code class="eh mw mx my mn b">go.mod</code>对应的用户名替换导入中的GitHub用户名。</p><p id="2f7a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">您会注意到我们在路由中导入了控制器包，但是它不能被解析。接下来，让我们解决这个问题。</p><p id="03ef" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">控制器:</strong>控制器包的目的很简单，就是从路由包中抽象出逻辑，使事情变得简单。</p><p id="7d74" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">app/controllers/main _ controller . go</strong></p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="cfbd" class="mr kp ht mn b be ms mt l mu mv">package controllers<br/><br/>import "github.com/gofiber/fiber/v2"<br/><br/>func RenderHello(c *fiber.Ctx) error {<br/>	return c.Status(fiber.StatusOK).JSON(fiber.Map{<br/>		"message": "Hello from api",<br/>	})<br/>}</span></pre><p id="5441" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">env:</strong>env包是一个助手工具，它使用<code class="eh mw mx my mn b">godotenv</code>包来读取我们不想发布的环境变量，比如我们的私钥和Alchemy API密钥。</p><p id="fe09" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu"> pkg/env/env.go </strong></p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="d9ef" class="mr kp ht mn b be ms mt l mu mv">package env<br/><br/>import "github.com/joho/godotenv"<br/><br/>var Env map[string]string<br/><br/>func GetEnv(key, def string) string {<br/>	if val, ok := Env[key]; ok {<br/>		return val<br/>	}<br/>	return def<br/>}<br/><br/>func SetupEnvFile() {<br/>	envFile := ".env"<br/>	var err error<br/>	Env, err = godotenv.Read(envFile)<br/>	if err != nil {<br/>		panic(err)<br/>	}<br/><br/>}</span></pre><p id="e57e" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">bootstrap:</strong>bootstrap包就是你所说的app点火。它创建一个新的<strong class="jd hu">应用</strong>命名实例，注册路由器和中间件，如果你想在未来初始化你的数据库，你可以在这里这样做。</p><p id="47ea" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu"> bootstrap/bootstrap.go </strong></p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="76e6" class="mr kp ht mn b be ms mt l mu mv">package bootstrap<br/><br/>import (<br/>	"github.com/alofeoluwafemi/go-ethereum-api/pkg/env"<br/>	"github.com/alofeoluwafemi/go-ethereum-api/pkg/router"<br/>	"github.com/gofiber/fiber/v2"<br/>	"github.com/gofiber/fiber/v2/middleware/logger"<br/>	"github.com/gofiber/fiber/v2/middleware/recover"<br/>)<br/><br/>func NewApplication() *fiber.App {<br/>	env.SetupEnvFile()<br/>	app := fiber.New(fiber.Config{<br/>		AppName: "Go Ethereum API",<br/>		CaseSensitive: true,<br/>	})<br/><br/>	//Middleware<br/>	app.Use(recover.New())<br/>	app.Use(logger.New())<br/><br/>	//Setup routes<br/>	router.InstallRouter(app)<br/><br/>	return app<br/>}</span></pre><p id="b1c4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">最后在你的<code class="eh mw mx my mn b">main.go</code>里用这个取代一切。</p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="f53d" class="mr kp ht mn b be ms mt l mu mv">package main<br/><br/>import (<br/>"fmt"<br/>"github.com/alofeoluwafemi/go-ethereum-api/bootstrap"<br/>"github.com/alofeoluwafemi/go-ethereum-api/pkg/env"<br/>"log"<br/>)<br/><br/>func main() {<br/>	app := bootstrap.NewApplication()<br/>	log.Fatal(app.Listen(<br/>		fmt.Sprintf("%s:%s",<br/>			env.GetEnv("APP_HOST", "localhost"),<br/>			env.GetEnv("APP_PORT", "3000"),<br/>		)))<br/>}</span></pre><p id="62e1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">并在您的<code class="eh mw mx my mn b">.env</code>文件中更新细节以匹配以下内容。不要担心私钥和炼金术Api密钥，我们会及时更新它。</p><p id="a5d8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu">。环境</strong></p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="4c33" class="mr kp ht mn b be ms mt l mu mv">DEPLOYER_PRIVATE_KEY=0x0<br/>ALCHEMY_KEY=<br/>APP_HOST=localhost<br/>APP_PORT=3000</span></pre><p id="bdab" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">停止当前运行的<code class="eh mw mx my mn b">go run main.go</code>进程并重启。如果您访问我们唯一注册的路由<code class="eh mw mx my mn b">http://127.0.0.1:3000/api/v1</code>，您应该会看到JSON返回。</p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="ae29" class="mr kp ht mn b be ms mt l mu mv">{<br/>	"message": "Hello from api"<br/>}</span></pre><h1 id="eba4" class="ko kp ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">在Goeril Testnet上部署智能合同</h1><h1 id="3584" class="ko kp ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">克隆合同</h1><p id="9e2f" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">将Piggyfi智能合同库克隆到我们项目中的<code class="eh mw mx my mn b">smart-contracts</code>文件夹中。为此，请运行下面的命令。</p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="b014" class="mr kp ht mn b be ms mt l mu mv">git clone https://github.com/orignellc/piggyfi-contracts-poc.git smart-contracts</span></pre><p id="b4b8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">打开</p><h1 id="fb6c" class="ko kp ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">汇编合同</h1><p id="72ab" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">在smart-contracts目录中运行<code class="eh mw mx my mn b">npm install</code>,以获取openzeppelin依赖项，该依赖项包含我们的一些合同所引用的智能合同</p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="7a49" class="mr kp ht mn b be ms mt l mu mv">solc --abi smart-contracts/contracts/*.sol -o builds --bin --include-path smart-contracts/node_modules --base-path .</span></pre><p id="8c3b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh mw mx my mn b">--base-path</code>代表你自己源代码树的根，而<code class="eh mw mx my mn b">--include-path</code>允许你指定包含外部代码的额外位置。</p><p id="a622" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果你在<code class="eh mw mx my mn b">builds</code>文件夹中查看，你会看到生成的<code class="eh mw mx my mn b">.abi</code>和<code class="eh mw mx my mn b">.bin</code>文件列表。</p><h1 id="8574" class="ko kp ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">生成合同Go绑定</h1><p id="f3f3" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">阿比根是围棋以太坊附带的一个套装。它是一个源代码生成器，可以将以太坊契约定义转换成易于使用、编译时类型安全的Go包。</p><p id="d07b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">简单地说，为我们的智能契约生成一个go代码，这样我们就可以用go代码与契约进行交互。</p><p id="17ac" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">安装<strong class="jd hu"> abigen </strong></p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="c0e3" class="mr kp ht mn b be ms mt l mu mv">cd $GOPATH/src/github.com/ethereum/go-ethereum/<br/>make<br/>make devtools</span></pre><p id="8d47" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">一旦完成，如果你在命令行上运行<code class="eh mw mx my mn b">abigen</code>，你应该得到一个输出。</p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="23ee" class="mr kp ht mn b be ms mt l mu mv">Fatal: No destination package specified (--pkg)</span></pre><p id="9c50" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在我们已经安装了<code class="eh mw mx my mn b">abigen</code>工具。在<strong class="jd hu"> pkg </strong>文件夹中再创建两个新包，第一个是<code class="eh mw mx my mn b">go-binding</code>。</p><p id="27dc" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在里面，<code class="eh mw mx my mn b">go-binding</code>创建一个新文件<code class="eh mw mx my mn b">generate_binding.go</code>。这个文件将包含一个脚本，当我们运行它时，它将帮助我们生成go-binding，所以将下面的脚本复制并粘贴到文件中。这是不言自明的，但我会很快给它一些背景。</p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="0558" class="mr kp ht mn b be ms mt l mu mv">package main<br/><br/>import (<br/>	"fmt"<br/>	"io/ioutil"<br/>	"log"<br/>	"os/exec"<br/>	"strings"<br/>)<br/><br/>const (<br/>	buildDir  = "../../builds/"<br/>	targetDir = "../ethereum/"<br/>)<br/><br/>func main() {<br/>	contractNames := []string{"CustodianWalletLogic", "Factory", "Escrow", "USDC"}<br/><br/>	cmd := exec.Command("which","abigen")<br/>	err := cmd.Run()<br/><br/>	if err != nil {<br/>		log.Fatal("ethereum-abigen is not a command: ",err)<br/>	}<br/><br/>	for _, contractName := range contractNames {<br/>		buildFilename := buildDir + contractName<br/>		bindingFilename := targetDir + contractName + ".go"<br/>		cmd = exec.Command(<br/>			"abigen", fmt.Sprintf("--bin=%s.bin", buildFilename),<br/>			fmt.Sprintf("--abi=%s.abi", buildFilename),<br/>			fmt.Sprintf("--pkg=%s", contractName),<br/>			fmt.Sprintf("--out=%s", bindingFilename),<br/>		)<br/><br/>		err := cmd.Start()<br/>		if err != nil {<br/>			log.Fatalln(err)<br/>		}<br/>		log.Printf("Running... %s", cmd)<br/>		err =  cmd.Wait()<br/>		if err != nil {<br/>			log.Fatalln(err)<br/>		}<br/>		bindFile, err := ioutil.ReadFile(bindingFilename)<br/>		if err != nil {<br/>			log.Fatalln("Cannot open: ",bindingFilename, err)<br/>		}<br/><br/>		fileOutput := strings.Replace(string(bindFile), "package " + contractName, "package ethereum", 1)<br/>		err = ioutil.WriteFile(bindingFilename, []byte(fileOutput), 0644)<br/>		if err != nil {<br/>			log.Fatalln("Cannot write to: ",bindingFilename,err)<br/>		}<br/>	}<br/>}</span></pre><p id="eec4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">该脚本遍历提供的<code class="eh mw mx my mn b">contractNames</code>，将<code class="eh mw mx my mn b">.abi</code>和<code class="eh mw mx my mn b">.bin</code>附加到文件名，然后将它们作为选项传递给<code class="eh mw mx my mn b">abigen</code>命令的<code class="eh mw mx my mn b">--abi</code>和<code class="eh mw mx my mn b">--bin</code>，以生成go绑定。</p><p id="679c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在运行go文件之前，创建我前面提到的第二个包文件夹。取名<strong class="jd hu">以太坊</strong>，别忘了这个应该在<strong class="jd hu"> pkg </strong>之下。</p><p id="d6d5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">从您的终端，在您的项目根目录下运行以下命令。</p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="fd29" class="mr kp ht mn b be ms mt l mu mv">cd pkg/go-binding <br/>go run generate_binding.go</span></pre><p id="c0ab" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果一切顺利，您的输出应该是这样的。</p><figure class="mi mj mk ml fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff nb"><img src="../Images/c5676bae70aab62562fe0e2385b28401.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*eN5gcC9LJ7DLlJCf.png"/></div></div></figure><p id="f59a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">如果你打开以太坊包文件夹，你会看到你生成的go-binding。</p><figure class="mi mj mk ml fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff nc"><img src="../Images/24ff07053ecdaf874741daef49de5d1f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KwyP7EyB7J5dmoVo.png"/></div></div></figure><h1 id="fa92" class="ko kp ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">获取Alchemy API密钥</h1><p id="4637" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">Alchemy提供web3开发工具来构建和扩展您的Dapp。我们将使用他们的一项服务，允许您连接到区块链节点，在我们的情况下是<code class="eh mw mx my mn b">Goerli</code>。</p><p id="4350" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><a class="ae kn" href="https://dashboard.alchemy.com/" rel="noopener ugc nofollow" target="_blank">创建一个新账户</a>如果还没有，点击<strong class="jd hu"> +创建应用</strong>按钮，选择以太坊和Goerli。</p><figure class="mi mj mk ml fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff nd"><img src="../Images/b11c630353aac489ee3ea4033a4d8d9e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1fiigDiGRvXEReQ3.png"/></div></div></figure><p id="02b1" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">应用程序创建完成后，将会列出您当前拥有的应用程序列表。在你新创建的应用程序旁边，点击<strong class="jd hu">查看密钥</strong>并将密钥和URL复制到<code class="eh mw mx my mn b">.env</code>文件中，作为<strong class="jd hu"> ALCHEMY_KEY </strong>和<strong class="jd hu"> RPC_URL </strong>的值。</p><figure class="mi mj mk ml fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff ne"><img src="../Images/a562f562e2bfe92f30bf06f1b95ec134.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PlI20w3DmHIoji-c.png"/></div></div></figure><p id="4342" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在你的<code class="eh mw mx my mn b">.env</code>文件应该是这样的。</p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="5c08" class="mr kp ht mn b be ms mt l mu mv">DEPLOYER_PRIVATE_KEY=bef9e118a31a0af39585d7e82cae42a...  <br/>ALCHEMY_KEY=obEYiMcZIMHXZC...<br/>RPC_URL=https://eth-goerli.g.alchemy.com/v2/obEYiMcZIMHXZC...<br/>APP_HOST=localhost<br/>APP_PORT=3000</span></pre><h1 id="d68e" class="ko kp ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">创建包区块链</h1><p id="edf3" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">我们需要在<code class="eh mw mx my mn b">pkg</code>目录下创建一个区块链包，并在其中创建一个新的go文件<code class="eh mw mx my mn b">blockchain.go</code>。</p><figure class="mi mj mk ml fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff nf"><img src="../Images/b703042893f5acbd7e3b76e95889f588.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FB5IVVeIKyw8d6xY.png"/></div></div></figure><p id="aad7" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这个包抽象了我们如何连接到以太坊节点并与我们的智能合约通信的大部分内容，以避免代码重复并保持控制器精简。我将继续解释代码的每个部分，然后我们可以把它放在一起，看看它是如何运行的。</p><p id="04a6" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">首先，我们定义一个变量<code class="eh mw mx my mn b">CurrentConnection</code>，它将从这个包中导出。这个变量将保存一个<code class="eh mw mx my mn b">ClientConnection</code>的实例。</p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="cd5b" class="mr kp ht mn b be ms mt l mu mv">var CurrentConnection *ClientConnection</span></pre><p id="c18c" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">接下来我们定义<code class="eh mw mx my mn b">ClientConnection</code> struct，它保存了我们需要与以太坊节点通信的细节集合，比如RPC URL、调用请求选项等。以及节点连接本身的一个实例。</p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="1e7f" class="mr kp ht mn b be ms mt l mu mv">type ClientConnection struct {<br/>	RpcURL      string<br/>	SignerKey   string<br/>	Client      *ethclient.Client<br/>	NetworkId   *big.Int<br/>	NetworkName string<br/>	ctx         context.Context<br/>	callOpts    *bind.CallOpts<br/>	trxOpts     *bind.TransactOpts<br/>}</span></pre><p id="b9fe" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">上面的一些struct字段，比如<code class="eh mw mx my mn b">RpcURL</code>、<code class="eh mw mx my mn b">NetworkName</code>、<code class="eh mw mx my mn b">NetworkId</code>，是不言自明的，我将花时间更详细地描述其余的字段。</p><p id="f298" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><strong class="jd hu"> SignerKey: </strong>这将从环境文件中选取，它是不带<code class="eh mw mx my mn b">0x</code>前缀的智能合约部署者的私钥。<br/> <strong class="jd hu">客户端:</strong>它保存连接到以太坊炼金术节点的实例。<br/> <strong class="jd hu"> ctx: </strong>用于所有智能合约调用的上下文<br/> <strong class="jd hu"> callOpts: </strong>它是用于发出不改变状态的合约调用请求的选项集合。<br/> <strong class="jd hu"> trxOpts: </strong>是创建有效以太坊交易所需的授权数据的集合，引起状态变化。</p><p id="2027" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">然后我们用<code class="eh mw mx my mn b">New()</code>来创建一个新的连接，并在<code class="eh mw mx my mn b">ClientConnection</code>中设置字段。</p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="4fca" class="mr kp ht mn b be ms mt l mu mv">func New() {<br/>	clientCon := new(ClientConnection)<br/>	clientCon.RpcURL = env.GetEnv("RPC_URL", "")<br/><br/>	client, err := ethclient.Dial(clientCon.RpcURL)<br/>	defer client.Close()<br/>	if err != nil {<br/>		log.Fatalln("Could not connect to client: ", err)<br/>	}<br/><br/>	clientCon.Client = client<br/>	clientCon.SignerKey = env.GetEnv("DEPLOYER_PRIVATE_KEY", "")<br/>	clientCon.NetworkName = "Goerli"<br/>	clientCon.NetworkId = new(big.Int).SetInt64(5)<br/>	clientCon.ctx = context.Background()<br/><br/>	clientCon.setTransactOpts()<br/>	clientCon.setCallOpts()<br/><br/>	CurrentConnection = clientCon<br/>}</span></pre><p id="304b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">添加一个方法来从我们的私钥中提取公钥，公钥ECDSA。</p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="f4cd" class="mr kp ht mn b be ms mt l mu mv">func (clientCon *ClientConnection) extractSignerKeys() (*ecdsa.PrivateKey, standardcryto.PublicKey, *ecdsa.PublicKey, error) {<br/>	privateKey, err := crypto.HexToECDSA(clientCon.SignerKey)<br/>	if err != nil {<br/>		log.Fatalln("Invalid private key: ", err)<br/>	}<br/><br/>	publicKey := privateKey.Public()<br/>	publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey)<br/><br/>	if !ok {<br/>		log.Fatalln("cannot assert type: publicKey is not of type *ecdsa.PublicKey")<br/>	}<br/><br/>	return privateKey, publicKey, publicKeyECDSA, err<br/>}</span></pre><p id="d6af" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">添加另一个方法来获取传递给它的任何地址的下一个<code class="eh mw mx my mn b">Nonce</code>。我们主要并且可能只需要它来获取部署者地址的随机数。</p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="9d6a" class="mr kp ht mn b be ms mt l mu mv">func (clientCon *ClientConnection) nonceAt(address common.Address) uint64 {<br/><br/>	nonce, err := clientCon.Client.PendingNonceAt(clientCon.ctx, address)<br/><br/>	if err != nil {<br/>		log.Fatalln("Cannot get nonce: ", err)<br/>	}<br/><br/>	return nonce<br/>}</span></pre><p id="8ff5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">最后，我们需要在<code class="eh mw mx my mn b">ClientConnection</code>上设置<code class="eh mw mx my mn b">callOpts</code> <code class="eh mw mx my mn b">trxOpts</code>字段的方法。</p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="3538" class="mr kp ht mn b be ms mt l mu mv">func (clientCon *ClientConnection) setTransactOpts() *bind.TransactOpts {<br/>	signer, _, publicKeyECDSA, _ := clientCon.extractSignerKeys()<br/><br/>	from := crypto.PubkeyToAddress(*publicKeyECDSA)<br/><br/>	opts, err := bind.NewKeyedTransactorWithChainID(signer, clientCon.NetworkId)<br/>	if err != nil {<br/>		log.Fatalln("Error with NewKeyedTransactorWithChainID ", err)<br/>	}<br/><br/>	priorityFee, err := clientCon.Client.SuggestGasTipCap(clientCon.ctx)<br/>	if err != nil {<br/>		log.Fatalln("Cannot suggest Tip: ", err)<br/>	}<br/><br/>	opts.Nonce = new(big.Int).SetUint64(clientCon.nonceAt(from))<br/>	opts.GasTipCap = priorityFee<br/><br/>	clientCon.trxOpts = opts<br/><br/>	return opts<br/>}</span></pre><pre class="ng mm mn mo bn mp mq bi"><span id="7507" class="mr kp ht mn b be ms mt l mu mv">func (clientCon *ClientConnection) setCallOpts() *bind.CallOpts {<br/>	opts := new(bind.CallOpts)<br/>	return opts<br/>}</span></pre><p id="580f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">把这些放在一起。</p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="fa58" class="mr kp ht mn b be ms mt l mu mv">package blockchain<br/><br/>import (<br/>	"context"<br/>	standardcryto "crypto"<br/>	"crypto/ecdsa"<br/>	"github.com/alofeoluwafemi/go-ethereum-api/pkg/env"<br/>	"github.com/alofeoluwafemi/go-ethereum-api/pkg/ethereum"<br/>	"github.com/ethereum/go-ethereum/accounts/abi/bind"<br/>	"github.com/ethereum/go-ethereum/common"<br/>	"github.com/ethereum/go-ethereum/core/types"<br/>	"github.com/ethereum/go-ethereum/crypto"<br/>	"github.com/ethereum/go-ethereum/ethclient"<br/>	"log"<br/>	"math/big"<br/>)<br/><br/>var CurrentConnection *ClientConnection<br/><br/>type ClientConnection struct {<br/>	RpcURL      string<br/>	SignerKey   string<br/>	Client      *ethclient.Client<br/>	NetworkId   *big.Int<br/>	NetworkName string<br/>	ctx         context.Context<br/>	callOpts    *bind.CallOpts<br/>	trxOpts     *bind.TransactOpts<br/>}<br/><br/>func New() {<br/>	clientCon := new(ClientConnection)<br/>	clientCon.RpcURL = env.GetEnv("RPC_URL", "")<br/><br/>	client, err := ethclient.Dial(clientCon.RpcURL)<br/>	defer client.Close()<br/>	if err != nil {<br/>		log.Fatalln("Could not connect to client: ", err)<br/>	}<br/><br/>	clientCon.Client = client<br/>	clientCon.SignerKey = env.GetEnv("DEPLOYER_PRIVATE_KEY", "")<br/>	clientCon.NetworkName = "Goerli"<br/>	clientCon.NetworkId = new(big.Int).SetInt64(5)<br/>	clientCon.ctx = context.Background()<br/><br/>	clientCon.setTransactOpts()<br/>	clientCon.setCallOpts()<br/><br/>	CurrentConnection = clientCon<br/>}<br/><br/>func (clientCon *ClientConnection) nonceAt(address common.Address) uint64 {<br/><br/>	nonce, err := clientCon.Client.PendingNonceAt(clientCon.ctx, address)<br/><br/>	if err != nil {<br/>		log.Fatalln("Cannot get nonce: ", err)<br/>	}<br/><br/>	return nonce<br/>}<br/><br/>func (clientCon *ClientConnection) setTransactOpts() *bind.TransactOpts {<br/>	signer, _, publicKeyECDSA, _ := clientCon.extractSignerKeys()<br/><br/>	from := crypto.PubkeyToAddress(*publicKeyECDSA)<br/><br/>	opts, err := bind.NewKeyedTransactorWithChainID(signer, clientCon.NetworkId)<br/>	if err != nil {<br/>		log.Fatalln("Error with NewKeyedTransactorWithChainID ", err)<br/>	}<br/><br/>	priorityFee, err := clientCon.Client.SuggestGasTipCap(clientCon.ctx)<br/>	if err != nil {<br/>		log.Fatalln("Cannot suggest Tip: ", err)<br/>	}<br/><br/>	opts.Nonce = new(big.Int).SetUint64(clientCon.nonceAt(from))<br/>	opts.GasTipCap = priorityFee<br/><br/>	clientCon.trxOpts = opts<br/><br/>	return opts<br/>}<br/><br/>func (clientCon *ClientConnection) setCallOpts() *bind.CallOpts {<br/>	opts := new(bind.CallOpts)<br/>	return opts<br/>}<br/><br/>func (clientCon *ClientConnection) extractSignerKeys() (*ecdsa.PrivateKey, standardcryto.PublicKey, *ecdsa.PublicKey, error) {<br/>	privateKey, err := crypto.HexToECDSA(clientCon.SignerKey)<br/>	if err != nil {<br/>		log.Fatalln("Invalid private key: ", err)<br/>	}<br/><br/>	publicKey := privateKey.Public()<br/>	publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey)<br/><br/>	if !ok {<br/>		log.Fatalln("cannot assert type: publicKey is not of type *ecdsa.PublicKey")<br/>	}<br/><br/>	return privateKey, publicKey, publicKeyECDSA, err<br/>}<br/><br/>func (clientCon *ClientConnection) DeployUSDC() (common.Address, *types.Transaction) {<br/>	contract, trx, _, err := ethereum.DeployUSDC(clientCon.trxOpts, clientCon.Client)<br/><br/>	if err != nil {<br/>		log.Fatalln("Could not deploy USDC contract: ", err)<br/>	}<br/><br/>	return contract, trx<br/>}</span></pre><p id="50ad" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">现在我们已经有了这些方法，我们可以开始在我们的智能契约上调用方法。打开以太坊包下的<code class="eh mw mx my mn b">USDC.go</code>文件，在第<code class="eh mw mx my mn b">46</code>行你会注意到函数<code class="eh mw mx my mn b">DeployUSDC</code>，可以调用它来部署<code class="eh mw mx my mn b">USDC</code>契约。</p><figure class="mi mj mk ml fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff nb"><img src="../Images/163b11bb4ebf78dcd94c9cf3db3a5ebf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*F0o4TwWqRvQf8BcV.png"/></div></div></figure><p id="5fcb" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">我们需要从一个控制器调用这个函数，并向它传递所需的两个参数。幸运的是，我们可以同时提供这两者，但是首先在controllers下，创建一个新的go文件<code class="eh mw mx my mn b">deployer_controller.go</code>，然后添加以下内容来定义一个将从<code class="eh mw mx my mn b">/api/v1/deploy/usdc</code>调用的<code class="eh mw mx my mn b">DeployUSDC</code>控制器。</p><p id="ede4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">内部<code class="eh mw mx my mn b">deployer_controller.go</code>把这个粘贴进去。</p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="9ce7" class="mr kp ht mn b be ms mt l mu mv">package controllers<br/><br/>import (<br/>	"github.com/alofeoluwafemi/go-ethereum-api/pkg/blockchain"<br/>	"github.com/gofiber/fiber/v2"<br/>)<br/><br/>func DeployUSDC(c *fiber.Ctx) error {<br/><br/>	conn := blockchain.CurrentConnection<br/><br/>	address, transaction := conn.DeployUSDC()<br/><br/>	return c.Status(fiber.StatusOK).JSON(fiber.Map{<br/>		"address": address.String(),<br/>		"hash":    transaction.Hash(),<br/>	})<br/>}</span></pre><p id="3311" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">区块链包的<code class="eh mw mx my mn b">DeployUSDC</code>方法尚未定义。让我们通过定义它来解决这个问题，它简单地调用<code class="eh mw mx my mn b">USDC.go</code>上的<code class="eh mw mx my mn b">DeployUSDC</code>函数。</p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="b917" class="mr kp ht mn b be ms mt l mu mv">func (clientCon *ClientConnection) DeployUSDC() (common.Address, *types.Transaction) {<br/>	contract, trx, _, err := ethereum.DeployUSDC(clientCon.trxOpts, clientCon.Client)<br/><br/>	if err != nil {<br/>		log.Fatalln("Could not deploy USDC contract: ", err)<br/>	}<br/><br/>	return contract, trx<br/>}</span></pre><p id="0e7d" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在<code class="eh mw mx my mn b">api_router.go</code>中，为新的URL添加一个路由器</p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="837e" class="mr kp ht mn b be ms mt l mu mv">deploy := api.Group("/deploy")<br/>	deploy.Get("/usdc", controllers.DeployUSDC)</span></pre><p id="5cf4" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">最后，如果您停止并重新运行该命令，使用。</p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="72f0" class="mr kp ht mn b be ms mt l mu mv">go run main.go</span></pre><p id="4f29" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">当您访问<a class="ae kn" href="http://127.0.0.1:3000/api/v1/deploy/usdc" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:3000/API/v1/deploy/usdc</a>时，您将获得一个响应，其中包含合同地址和用于部署usdc合同地址的事务的哈希。</p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="cd47" class="mr kp ht mn b be ms mt l mu mv">{<br/>	"address": "0xb3f2504110eeea6a522218048D0519B829788DDD",<br/>	"hash": "0xaeabc29be2bb6d2e84466edebf8e38b0ca833f250bc70eeb733509365b5f787b"<br/>}</span></pre><p id="fe9a" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在我的例子中，如果我访问Etherscan并使用事务散列进行搜索。</p><figure class="mi mj mk ml fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff nb"><img src="../Images/6dd85ae6b244e24dbc3358c1157981fe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uGXUaDiHSfG-mkEx.png"/></div></div></figure><h1 id="c4e7" class="ko kp ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">使用POST而不是GET</h1><p id="6bd3" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">我们在部署USDC路由上使用的当前HTTP方法是GET，现在将其改为POST，这样。</p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="31a8" class="mr kp ht mn b be ms mt l mu mv">deploy.Post("/usdc", controllers.DeployUSDC)</span></pre><p id="17a3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">再次重启服务器，从Postman向<a class="ae kn" href="http://127.0.0.1:3000/api/v1/deploy/usdc" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:3000/API/v1/deploy/usdc</a>发出GET请求，一个新的智能合约将被部署。您可以使用事务哈希进行确认。</p><figure class="mi mj mk ml fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff nh"><img src="../Images/5e5d185a1dbd6355ff76146a3445114b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1eimgLs8TNcrbcS5.png"/></div></div></figure><p id="bbc5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">请务必记下已部署契约的地址，供我们以后使用。</p><p id="546b" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">接下来，让我们创建一个新的路由来部署工厂契约。在<code class="eh mw mx my mn b">DeployUSDC</code>的正下方添加该控制器功能。</p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="fb0f" class="mr kp ht mn b be ms mt l mu mv">func DeployFactory(c *fiber.Ctx) error {</span></pre><pre class="ng mm mn ni nj aw nk dt"><span id="a66c" class="lu kp ht mn b fv nl nm l nn mv">	conn := blockchain.CurrentConnection</span><span id="2d85" class="lu kp ht mn b fv no nm l nn mv">	address, transaction := conn.DeployFactory()</span><span id="c25c" class="lu kp ht mn b fv no nm l nn mv">	return c.Status(fiber.StatusOK).JSON(fiber.Map{<br/>		"address": address.String(),<br/>		"hash":    transaction.Hash(),<br/>	})<br/>}</span></pre><p id="83d8" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">它与之前的控制器功能没有任何不同，因此无需解释。</p><p id="14b5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">这同样适用于区块链一揽子权利下的<code class="eh mw mx my mn b">DeployUSDC</code>方法。添加一个新方法<code class="eh mw mx my mn b">DeployFactory</code>，它调用Factory.go文件中的DeployFactory。<code class="eh mw mx my mn b">DeployFactory</code>还部署了<code class="eh mw mx my mn b">Escrow</code>和<code class="eh mw mx my mn b">CustodianWalletLogic</code>合同，您将在后面看到。</p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="5f70" class="mr kp ht mn b be ms mt l mu mv">func (clientCon *ClientConnection) DeployFactory() (common.Address, *types.Transaction) {<br/>	contract, trx, _, err := ethereum.DeployFactory(clientCon.trxOpts, clientCon.Client)<br/><br/>	if err != nil {<br/>		log.Fatalln("Could not deploy Factory contract: ", err)<br/>	}<br/><br/>	return contract, trx<br/>}</span></pre><p id="e142" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">重启fiber服务器，在Postman中向<a class="ae kn" href="http://127.0.0.1:3000/api/v1/deploy/factory" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:3000/API/v1/deploy/Factory</a>发出POST请求，工厂契约将被部署。</p><figure class="mi mj mk ml fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff np"><img src="../Images/d379801704777ce1fbc1dbb8bc1508ea.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*WfS1zC5yRpcpB7VT.png"/></div></div></figure><p id="0b44" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">请记住，我提到过部署工厂契约也要部署托管&amp; WalletLogic契约。您可以通过查看工厂合同构造函数来确认这一点。</p><figure class="mi mj mk ml fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff nq"><img src="../Images/1db9a822356deaefb2fa72ea92020ca8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*CGeXZR8iwkUXDjsJ.png"/></div></div></figure><h1 id="e3ca" class="ko kp ht bd kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li lj lk ll dt translated">获取CustodianWalletLogic地址</h1><p id="bc54" class="pw-post-body-paragraph jb jc ht jd b je lm jg jh ji ln jk jl jm lo jo jp jq lp js jt ju lq jw jx jy hm dt translated">为了使用工厂合同，我们将在区块链包中创建一个<code class="eh mw mx my mn b">factory.go</code>文件。就像在<code class="eh mw mx my mn b">blockchain.go</code>文件中我们定义了一个单例变量来保存连接实例一样，我们也将定义一个变量<code class="eh mw mx my mn b">FactoryInstance</code>来保存已部署工厂契约的实例。</p><p id="83e3" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">然后一个<code class="eh mw mx my mn b">NewFactory</code>方法使用契约地址得到一个实例。</p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="7024" class="mr kp ht mn b be ms mt l mu mv">var FactoryInstance *Factory<br/><br/>type Factory struct {<br/>	Address  common.Address<br/>	Instance *ethereum.Factory<br/>}<br/><br/>func (clientCon ClientConnection) NewFactory(address string) {<br/>	FactoryInstance = new(Factory)<br/><br/>	contractAddress := common.HexToAddress(address)<br/><br/>	FactoryInstance.Address = contractAddress<br/><br/>	instance, err := ethereum.NewFactory(contractAddress, clientCon.Client)<br/>	if err != nil {<br/>		log.Fatalln("Cannot get Factory contract at address ", address, " due to: ", err)<br/>	}<br/><br/>	FactoryInstance.Instance = instance<br/>}</span></pre><p id="b203" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">最后是<code class="eh mw mx my mn b">GetLogicAddress</code>方法。</p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="6d7f" class="mr kp ht mn b be ms mt l mu mv">func (clientCon ClientConnection) GetLogicAddress() common.Address {<br/><br/>	address, err := FactoryInstance.Instance.CustodianWalletLogic(clientCon.callOpts)<br/><br/>	if err != nil {<br/>		log.Fatalln("Cannot make call to Factory at ", FactoryInstance.Address, "due to: ", err)<br/>	}<br/><br/>	return address<br/>}</span></pre><p id="e93f" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">将所有这些放在一起<code class="eh mw mx my mn b">pkg/blockchain/factory.go</code>看起来应该完全是这样的。</p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="4789" class="mr kp ht mn b be ms mt l mu mv">package blockchain<br/><br/>import (<br/>	"github.com/alofeoluwafemi/go-ethereum-api/pkg/ethereum"<br/>	"github.com/ethereum/go-ethereum/common"<br/>	"log"<br/>)<br/><br/>var FactoryInstance *Factory<br/><br/>type Factory struct {<br/>	Address  common.Address<br/>	Instance *ethereum.Factory<br/>}<br/><br/>func (clientCon ClientConnection) NewFactory(address string) {<br/>	FactoryInstance = new(Factory)<br/><br/>	contractAddress := common.HexToAddress(address)<br/><br/>	FactoryInstance.Address = contractAddress<br/><br/>	instance, err := ethereum.NewFactory(contractAddress, clientCon.Client)<br/>	if err != nil {<br/>		log.Fatalln("Cannot get Factory contract at address ", address, " due to: ", err)<br/>	}<br/><br/>	FactoryInstance.Instance = instance<br/>}<br/><br/>// GetLogicAddress 0x505A066E89Be22D3e56f16e1666de31f9328572e<br/>func (clientCon ClientConnection) GetLogicAddress() common.Address {<br/><br/>	address, err := FactoryInstance.Instance.CustodianWalletLogic(clientCon.callOpts)<br/><br/>	if err != nil {<br/>		log.Fatalln("Cannot make call to Factory at ", FactoryInstance.Address, "due to: ", err)<br/>	}<br/><br/>	return address<br/>}</span></pre><p id="2ab0" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在<code class="eh mw mx my mn b">api_router.go</code>文件中，添加路由以调用刚刚添加的新控制器方法。</p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="5940" class="mr kp ht mn b be ms mt l mu mv">api.Get("/wallet-logic-address", controllers.GetCustodianWalletLogicAddress)</span></pre><p id="2f39" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated"><code class="eh mw mx my mn b">GetCustodianWalletLogicAddress</code>控制器方法尚未定义。让我们将工厂逻辑从主控制器和部署者控制器中分离出来，出于这些原因，创建一个新的控制器<code class="eh mw mx my mn b">factory_controller.go</code>并将其粘贴到内部。</p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="c6fe" class="mr kp ht mn b be ms mt l mu mv">package controllers<br/><br/>import (<br/>	"github.com/alofeoluwafemi/go-ethereum-api/pkg/blockchain"<br/>	"github.com/gofiber/fiber/v2"<br/>)<br/><br/>func GetCustodianWalletLogicAddress(c *fiber.Ctx) error {<br/>	conn := blockchain.CurrentConnection<br/><br/>	address := conn.GetLogicAddress()<br/><br/>	return c.Status(fiber.StatusOK).JSON(fiber.Map{<br/>		"address": address.String(),<br/>	})<br/>}</span></pre><p id="8d09" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">最后在<code class="eh mw mx my mn b">factory.go</code>中添加从控制器调用的方法。</p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="4d06" class="mr kp ht mn b be ms mt l mu mv">func (clientCon ClientConnection) GetLogicAddress() common.Address {<br/><br/>	address, err := getFactory().CustodianWalletLogic(clientCon.callOpts)<br/><br/>	if err != nil {<br/>		log.Fatalln("Cannot make call to Factory at ", FactoryInstance.Address, "due to: ", err)<br/>	}<br/><br/>	return address<br/>}</span></pre><p id="67d2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">重启光纤服务器并使用Postman向<a class="ae kn" href="http://127.0.0.1:3000/api/v1/wallet-logic-address" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:3000/API/v1/wallet-logic-address</a>发出GET请求。</p><figure class="mi mj mk ml fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff nr"><img src="../Images/d3bb39f8811afae8a262fd9b3e45fd23.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*z9R1L3t4mOgjaYlH.png"/></div></div></figure><p id="8725" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">添加一个新的类似路由，以获取工厂部署的托管合同地址。</p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="093e" class="mr kp ht mn b be ms mt l mu mv">api.Get("/escrow-address", controllers.GetEscrowAddress)</span></pre><p id="1638" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在工厂控制器中创建<code class="eh mw mx my mn b">GetEscrowAddress</code>函数，几乎和GetLogicAddress控制器一样。</p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="6af3" class="mr kp ht mn b be ms mt l mu mv">func GetEscrowAddress(c *fiber.Ctx) error {  <br/>   conn := blockchain.CurrentConnection  <br/>  <br/>  address := conn.GetEscrowAddress()  <br/>  <br/>   return c.Status(fiber.StatusOK).JSON(fiber.Map{  <br/>      "address": address.String(),  <br/>   })  <br/>}</span></pre><p id="d6f2" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">最后，将<code class="eh mw mx my mn b">GetEscrowAddress</code>方法添加到<code class="eh mw mx my mn b">factory.go</code>中</p><pre class="mi mj mk ml fq mm mn mo bn mp mq bi"><span id="9ae2" class="mr kp ht mn b be ms mt l mu mv">func (clientCon ClientConnection) GetEscrowAddress() common.Address {  <br/>  <br/>   address, err := getFactory().EscrowContractAddress(clientCon.callOpts)  <br/>  <br/>   if err != nil {  <br/>      log.Fatalln("Cannot make call to Factory at ", FactoryInstance.Address, "due to: ", err)  <br/>   }  <br/>  <br/>   return address  <br/>}</span></pre><p id="c9f5" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">重启光纤服务器并使用Postman向<a class="ae kn" href="http://127.0.0.1:3000/api/v1/escrow-address" rel="noopener ugc nofollow" target="_blank">http://127 . 0 . 0 . 1:3000/API/v1/escrow-address</a>发出GET请求。</p><figure class="mi mj mk ml fq iu fe ff paragraph-image"><div role="button" tabindex="0" class="iv iw di ix bf iy"><div class="fe ff ns"><img src="../Images/26fffbe6e3ad4331d90340b555a121c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*KNlMarXEsUgAGWMd.png"/></div></div></figure><p id="be64" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">到目前为止，我们已经做到了以下几点:</p><ul class=""><li id="0ed4" class="jz ka ht jd b je jf ji jj jm kb jq kc ju kd jy ke kf kg kh dt translated">设置Go Fiber框架并构建它以构建API</li><li id="00f5" class="jz ka ht jd b je ki ji kj jm kk jq kl ju km jy ke kf kg kh dt translated">设置API端点以部署工厂和USDC合同</li><li id="749e" class="jz ka ht jd b je ki ji kj jm kk jq kl ju km jy ke kf kg kh dt translated">设置API端点，以便在部署工厂合同时部署托管和钱包逻辑地址。我们直接从部署的工厂合同中读取这些信息</li></ul><p id="e185" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">在最后一篇文章中，我们将完成与托管契约交互的另一个端点，以执行与订单相关的操作。</p><p id="ff20" class="pw-post-body-paragraph jb jc ht jd b je jf jg jh ji jj jk jl jm jn jo jp jq jr js jt ju jv jw jx jy hm dt translated">感谢你坚持到现在，如果你喜欢这篇文章，你可以通过为这篇文章鼓掌和订阅我的<a class="ae kn" href="https://www.youtube.com/channel/UCO3mWoCZ_iqRPRvUeg9oG2A" rel="noopener ugc nofollow" target="_blank"> youtube频道</a>来支持我。</p><blockquote class="nt"><p id="6bf9" class="nu nv ht bd nw nx ny nz oa ob oc jy ek translated">交易新手？尝试<a class="ae kn" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae kn" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>