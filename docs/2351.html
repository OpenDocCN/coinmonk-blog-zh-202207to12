<html>
<head>
<title>Immutable String Variables</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">不可变字符串变量</h1>
<blockquote>原文：<a href="https://medium.com/coinmonks/immutable-string-variables-2a35fc385a41?source=collection_archive---------8-----------------------#2022-08-18">https://medium.com/coinmonks/immutable-string-variables-2a35fc385a41?source=collection_archive---------8-----------------------#2022-08-18</a></blockquote><div><div class="ef hh hi hj hk hl"/><div class="hm hn ho hp hq"><h2 id="5fb5" class="hr hs ht bd b gc hu hv hw hx hy hz ek ia translated" aria-label="kicker paragraph">可靠性作弊</h2><div class=""/><div class=""><h2 id="9024" class="pw-subtitle-paragraph iz ic ht bd b ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq ek translated">…在编译器不支持它们之前使用它们</h2></div><figure class="js jt ju jv fq jw fe ff paragraph-image"><div class="fe ff jr"><img src="../Images/99df59a63a0698cc789ffdcede31795b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*u1w67yrzOySMFQKpK9-PLQ.jpeg"/></div></figure><p id="92c7" class="pw-post-body-paragraph jz ka ht kb b kc kd jd ke kf kg jg kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">这是一篇关于Solidity编程语言的文章:一种用于为以太坊和其他兼容的区块链编写智能合约的特殊语言。</p><p id="13ba" class="pw-post-body-paragraph jz ka ht kb b kc kd jd ke kf kg jg kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">不可变变量是巨大的。它们实际上与编译时常数一样有效，但是它们的值可以在部署时设置。</p><p id="e0e6" class="pw-post-body-paragraph jz ka ht kb b kc kd jd ke kf kg jg kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">一个重要的缺点是目前Solidity只支持原语类型的不可变变量，比如<code class="eh kv kw kx ky b">uint</code>或者<code class="eh kv kw kx ky b">bytes32</code>。让我们看看下面来自OpenZeppelin的代码:</p><figure class="js jt ju jv fq jw fe ff paragraph-image"><div class="fe ff kz"><img src="../Images/e37760641cd94b003bb7e0d3193f78ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1290/format:webp/1*ZtpBonAn427mVpPOWuLvnw.png"/></div><figcaption class="la lb fg fe ff lc ld bd b be z ek"><a class="ae le" href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L42-L57" rel="noopener ugc nofollow" target="_blank">https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L42-L57</a></figcaption></figure><p id="9302" class="pw-post-body-paragraph jz ka ht kb b kc kd jd ke kf kg jg kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated"><code class="eh kv kw kx ky b">_name</code>和<code class="eh kv kw kx ky b">_symbol</code>变量是在构造函数中设置的，并且永远不会改变，但是它们没有被声明为<code class="eh kv kw kx ky b">immutable</code>，因为编译器不允许这样做。因此，读取这些变量的成本很高，初始化起来更费钱。</p><p id="5782" class="pw-post-body-paragraph jz ka ht kb b kc kd jd ke kf kg jg kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">以下是一个可能有所帮助的诀窍:</p><figure class="js jt ju jv fq jw"><div class="bz el l di"><div class="lf lg l"/></div></figure><p id="a1d9" class="pw-post-body-paragraph jz ka ht kb b kc kd jd ke kf kg jg kh ki kj kk kl km kn ko kp kq kr ks kt ku hm dt translated">这个简单的库有效地将一个短字符串(短于32字节)打包成一个<code class="eh kv kw kx ky b">bytes32</code>值，该值可以存储在一个不可变的变量中。稍后，同一个库可以用来有效地将打包的<code class="eh kv kw kx ky b">bytes32</code>值解包回正常的Solidity字符串。</p><blockquote class="lh"><p id="c13a" class="li lj ht bd lk ll lm ln lo lp lq ku ek translated">交易新手？尝试<a class="ae le" rel="noopener" href="/coinmonks/crypto-trading-bot-c2ffce8acb2a">加密交易机器人</a>或<a class="ae le" rel="noopener" href="/coinmonks/top-10-crypto-copy-trading-platforms-for-beginners-d0c37c7d698c">复制交易</a></p></blockquote></div></div>    
</body>
</html>